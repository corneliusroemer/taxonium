(self["webpackChunktaxonium"] = self["webpackChunktaxonium"] || []).push([["vendors-node_modules_jbrowse_plugin-alignments_esm_BamAdapter_BamAdapter_js"],{

/***/ "./node_modules/@gmod/bam/esm/bai.js":
/*!*******************************************!*\
  !*** ./node_modules/@gmod/bam/esm/bai.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BAI; }
/* harmony export */ });
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _virtualOffset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./virtualOffset */ "./node_modules/@gmod/bam/esm/virtualOffset.js");
/* harmony import */ var _chunk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk */ "./node_modules/@gmod/bam/esm/chunk.js");
/* harmony import */ var _indexFile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./indexFile */ "./node_modules/@gmod/bam/esm/indexFile.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/bam/esm/util.js");





const BAI_MAGIC = 21578050; // BAI\1
function roundDown(n, multiple) {
    return n - (n % multiple);
}
function roundUp(n, multiple) {
    return n - (n % multiple) + multiple;
}
class BAI extends _indexFile__WEBPACK_IMPORTED_MODULE_3__["default"] {
    parsePseudoBin(bytes, offset) {
        const lineCount = (0,_util__WEBPACK_IMPORTED_MODULE_4__.longToNumber)(long__WEBPACK_IMPORTED_MODULE_0___default().fromBytesLE(Array.prototype.slice.call(bytes, offset + 16, offset + 24), true));
        return { lineCount };
    }
    async lineCount(refId, opts = {}) {
        const prom = await this.parse(opts);
        const index = prom.indices[refId];
        if (!index) {
            return -1;
        }
        const ret = index.stats || {};
        return ret.lineCount === undefined ? -1 : ret.lineCount;
    }
    fetchBai(opts = {}) {
        if (!this.baiP) {
            this.baiP = this.filehandle.readFile(opts).catch(e => {
                this.baiP = undefined;
                throw e;
            });
        }
        return this.baiP;
    }
    // fetch and parse the index
    async _parse() {
        const data = { bai: true, maxBlockSize: 1 << 16 };
        const bytes = await this.fetchBai();
        // check BAI magic numbers
        if (bytes.readUInt32LE(0) !== BAI_MAGIC) {
            throw new Error('Not a BAI file');
        }
        data.refCount = bytes.readInt32LE(4);
        const depth = 5;
        const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7;
        // read the indexes for each reference sequence
        data.indices = new Array(data.refCount);
        let currOffset = 8;
        for (let i = 0; i < data.refCount; i += 1) {
            // the binning index
            const binCount = bytes.readInt32LE(currOffset);
            let stats;
            currOffset += 4;
            const binIndex = {};
            for (let j = 0; j < binCount; j += 1) {
                const bin = bytes.readUInt32LE(currOffset);
                currOffset += 4;
                if (bin === binLimit + 1) {
                    currOffset += 4;
                    stats = this.parsePseudoBin(bytes, currOffset);
                    currOffset += 32;
                }
                else if (bin > binLimit + 1) {
                    throw new Error('bai index contains too many bins, please use CSI');
                }
                else {
                    const chunkCount = bytes.readInt32LE(currOffset);
                    currOffset += 4;
                    const chunks = new Array(chunkCount);
                    for (let k = 0; k < chunkCount; k += 1) {
                        const u = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_1__.fromBytes)(bytes, currOffset);
                        const v = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_1__.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16;
                        this._findFirstData(data, u);
                        chunks[k] = new _chunk__WEBPACK_IMPORTED_MODULE_2__["default"](u, v, bin);
                    }
                    binIndex[bin] = chunks;
                }
            }
            const linearCount = bytes.readInt32LE(currOffset);
            currOffset += 4;
            // as we're going through the linear index, figure out
            // the smallest virtual offset in the indexes, which
            // tells us where the BAM header ends
            const linearIndex = new Array(linearCount);
            for (let k = 0; k < linearCount; k += 1) {
                linearIndex[k] = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_1__.fromBytes)(bytes, currOffset);
                currOffset += 8;
                this._findFirstData(data, linearIndex[k]);
            }
            data.indices[i] = { binIndex, linearIndex, stats };
        }
        return data;
    }
    async indexCov(seqId, start, end, opts = {}) {
        const v = 16384;
        const range = start !== undefined;
        const indexData = await this.parse(opts);
        const seqIdx = indexData.indices[seqId];
        if (!seqIdx) {
            return [];
        }
        const { linearIndex = [], stats } = seqIdx;
        if (!linearIndex.length) {
            return [];
        }
        const e = end !== undefined ? roundUp(end, v) : (linearIndex.length - 1) * v;
        const s = start !== undefined ? roundDown(start, v) : 0;
        let depths;
        if (range) {
            depths = new Array((e - s) / v);
        }
        else {
            depths = new Array(linearIndex.length - 1);
        }
        const totalSize = linearIndex[linearIndex.length - 1].blockPosition;
        if (e > (linearIndex.length - 1) * v) {
            throw new Error('query outside of range of linear index');
        }
        let currentPos = linearIndex[s / v].blockPosition;
        for (let i = s / v, j = 0; i < e / v; i++, j++) {
            depths[j] = {
                score: linearIndex[i + 1].blockPosition - currentPos,
                start: i * v,
                end: i * v + v,
            };
            currentPos = linearIndex[i + 1].blockPosition;
        }
        return depths.map(d => {
            return { ...d, score: (d.score * stats.lineCount) / totalSize };
        });
    }
    /**
     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
     * @returns {Array[number]}
     */
    reg2bins(beg, end) {
        end -= 1;
        return [
            [0, 0],
            [1 + (beg >> 26), 1 + (end >> 26)],
            [9 + (beg >> 23), 9 + (end >> 23)],
            [73 + (beg >> 20), 73 + (end >> 20)],
            [585 + (beg >> 17), 585 + (end >> 17)],
            [4681 + (beg >> 14), 4681 + (end >> 14)],
        ];
    }
    async blocksForRange(refId, min, max, opts = {}) {
        if (min < 0) {
            min = 0;
        }
        const indexData = await this.parse(opts);
        if (!indexData) {
            return [];
        }
        const ba = indexData.indices[refId];
        if (!ba) {
            return [];
        }
        // List of bin #s that overlap min, max
        const overlappingBins = this.reg2bins(min, max);
        const chunks = [];
        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned
        for (const [start, end] of overlappingBins) {
            for (let bin = start; bin <= end; bin++) {
                if (ba.binIndex[bin]) {
                    const binChunks = ba.binIndex[bin];
                    for (let c = 0; c < binChunks.length; ++c) {
                        chunks.push(new _chunk__WEBPACK_IMPORTED_MODULE_2__["default"](binChunks[c].minv, binChunks[c].maxv, bin));
                    }
                }
            }
        }
        // Use the linear index to find minimum file position of chunks that could
        // contain alignments in the region
        const nintv = ba.linearIndex.length;
        let lowest = null;
        const minLin = Math.min(min >> 14, nintv - 1);
        const maxLin = Math.min(max >> 14, nintv - 1);
        for (let i = minLin; i <= maxLin; ++i) {
            const vp = ba.linearIndex[i];
            if (vp) {
                if (!lowest || vp.compareTo(lowest) < 0) {
                    lowest = vp;
                }
            }
        }
        return (0,_util__WEBPACK_IMPORTED_MODULE_4__.optimizeChunks)(chunks, lowest);
    }
}
//# sourceMappingURL=bai.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/bamFile.js":
/*!***********************************************!*\
  !*** ./node_modules/@gmod/bam/esm/bamFile.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BAM_MAGIC": function() { return /* binding */ BAM_MAGIC; },
/* harmony export */   "default": function() { return /* binding */ BamFile; }
/* harmony export */ });
/* harmony import */ var buffer_crc32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer-crc32 */ "./node_modules/buffer-crc32/index.js");
/* harmony import */ var buffer_crc32__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer_crc32__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gmod/bgzf-filehandle */ "./node_modules/@gmod/bgzf-filehandle/esm/index.js");
/* harmony import */ var object_entries_ponyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! object.entries-ponyfill */ "./node_modules/object.entries-ponyfill/index.js");
/* harmony import */ var object_entries_ponyfill__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(object_entries_ponyfill__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var generic_filehandle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! generic-filehandle */ "./node_modules/generic-filehandle/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! abortable-promise-cache */ "./node_modules/abortable-promise-cache/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(abortable_promise_cache__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! quick-lru */ "./node_modules/quick-lru/index.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(quick_lru__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _bai__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bai */ "./node_modules/@gmod/bam/esm/bai.js");
/* harmony import */ var _csi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./csi */ "./node_modules/@gmod/bam/esm/csi.js");
/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./record */ "./node_modules/@gmod/bam/esm/record.js");
/* harmony import */ var _sam__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sam */ "./node_modules/@gmod/bam/esm/sam.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/bam/esm/util.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];






//locals





const BAM_MAGIC = 21840194;
const blockLen = 1 << 16;
function flat(arr) {
    return [].concat(...arr);
}
async function gen2array(gen) {
    const out = [];
    for await (const x of gen) {
        out.push(x);
    }
    return out;
}
class BamFile {
    /**
     * @param {object} args
     * @param {string} [args.bamPath]
     * @param {FileHandle} [args.bamFilehandle]
     * @param {string} [args.baiPath]
     * @param {FileHandle} [args.baiFilehandle]
     */
    constructor({ bamFilehandle, bamPath, bamUrl, baiPath, baiFilehandle, baiUrl, csiPath, csiFilehandle, csiUrl, fetchSizeLimit, chunkSizeLimit, yieldThreadTime = 100, renameRefSeqs = n => n, }) {
        this.featureCache = new (abortable_promise_cache__WEBPACK_IMPORTED_MODULE_4___default())({
            //@ts-ignore
            cache: new (quick_lru__WEBPACK_IMPORTED_MODULE_5___default())({
                maxSize: 50,
            }),
            //@ts-ignore
            fill: async ({ chunk, opts }, signal) => {
                const { data, cpositions, dpositions } = await this._readChunk({
                    chunk,
                    opts: { ...opts, signal },
                });
                const feats = await this.readBamFeatures(data, cpositions, dpositions, chunk);
                return feats;
            },
        });
        this.renameRefSeq = renameRefSeqs;
        if (bamFilehandle) {
            this.bam = bamFilehandle;
        }
        else if (bamPath) {
            this.bam = new generic_filehandle__WEBPACK_IMPORTED_MODULE_3__.LocalFile(bamPath);
        }
        else if (bamUrl) {
            this.bam = new generic_filehandle__WEBPACK_IMPORTED_MODULE_3__.RemoteFile(bamUrl);
        }
        else {
            throw new Error('unable to initialize bam');
        }
        if (csiFilehandle) {
            this.index = new _csi__WEBPACK_IMPORTED_MODULE_7__["default"]({ filehandle: csiFilehandle });
        }
        else if (csiPath) {
            this.index = new _csi__WEBPACK_IMPORTED_MODULE_7__["default"]({ filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_3__.LocalFile(csiPath) });
        }
        else if (csiUrl) {
            this.index = new _csi__WEBPACK_IMPORTED_MODULE_7__["default"]({ filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_3__.RemoteFile(csiUrl) });
        }
        else if (baiFilehandle) {
            this.index = new _bai__WEBPACK_IMPORTED_MODULE_6__["default"]({ filehandle: baiFilehandle });
        }
        else if (baiPath) {
            this.index = new _bai__WEBPACK_IMPORTED_MODULE_6__["default"]({ filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_3__.LocalFile(baiPath) });
        }
        else if (baiUrl) {
            this.index = new _bai__WEBPACK_IMPORTED_MODULE_6__["default"]({ filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_3__.RemoteFile(baiUrl) });
        }
        else if (bamPath) {
            this.index = new _bai__WEBPACK_IMPORTED_MODULE_6__["default"]({ filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_3__.LocalFile(`${bamPath}.bai`) });
        }
        else if (bamUrl) {
            this.index = new _bai__WEBPACK_IMPORTED_MODULE_6__["default"]({ filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_3__.RemoteFile(`${bamUrl}.bai`) });
        }
        else {
            throw new Error('unable to infer index format');
        }
        this.fetchSizeLimit = fetchSizeLimit || 500000000; // 500MB
        this.chunkSizeLimit = chunkSizeLimit || 300000000; // 300MB
        this.yieldThreadTime = yieldThreadTime;
    }
    async getHeader(origOpts = {}) {
        const opts = (0,_util__WEBPACK_IMPORTED_MODULE_10__.makeOpts)(origOpts);
        const indexData = await this.index.parse(opts);
        const ret = indexData.firstDataLine
            ? indexData.firstDataLine.blockPosition + 65535
            : undefined;
        let buffer;
        if (ret) {
            const res = await this.bam.read(Buffer.alloc(ret + blockLen), 0, ret + blockLen, 0, opts);
            const { bytesRead } = res;
            ({ buffer } = res);
            if (!bytesRead) {
                throw new Error('Error reading header');
            }
            if (bytesRead < ret) {
                buffer = buffer.subarray(0, bytesRead);
            }
            else {
                buffer = buffer.subarray(0, ret);
            }
        }
        else {
            buffer = (await this.bam.readFile(opts));
        }
        const uncba = await (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_1__.unzip)(buffer);
        if (uncba.readInt32LE(0) !== BAM_MAGIC) {
            throw new Error('Not a BAM file');
        }
        const headLen = uncba.readInt32LE(4);
        this.header = uncba.toString('utf8', 8, 8 + headLen);
        const { chrToIndex, indexToChr } = await this._readRefSeqs(headLen + 8, 65535, opts);
        this.chrToIndex = chrToIndex;
        this.indexToChr = indexToChr;
        return (0,_sam__WEBPACK_IMPORTED_MODULE_9__.parseHeaderText)(this.header);
    }
    async getHeaderText(opts = {}) {
        await this.getHeader(opts);
        return this.header;
    }
    // the full length of the refseq block is not given in advance so this grabs
    // a chunk and doubles it if all refseqs haven't been processed
    async _readRefSeqs(start, refSeqBytes, opts = {}) {
        if (start > refSeqBytes) {
            return this._readRefSeqs(start, refSeqBytes * 2, opts);
        }
        const size = refSeqBytes + blockLen;
        const { bytesRead, buffer } = await this.bam.read(Buffer.alloc(size), 0, refSeqBytes, 0, opts);
        if (!bytesRead) {
            throw new Error('Error reading refseqs from header');
        }
        const uncba = await (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_1__.unzip)(buffer.subarray(0, Math.min(bytesRead, refSeqBytes)));
        const nRef = uncba.readInt32LE(start);
        let p = start + 4;
        const chrToIndex = {};
        const indexToChr = [];
        for (let i = 0; i < nRef; i += 1) {
            const lName = uncba.readInt32LE(p);
            const refName = this.renameRefSeq(uncba.toString('utf8', p + 4, p + 4 + lName - 1));
            const lRef = uncba.readInt32LE(p + lName + 4);
            chrToIndex[refName] = i;
            indexToChr.push({ refName, length: lRef });
            p = p + 8 + lName;
            if (p > uncba.length) {
                console.warn(`BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`);
                return this._readRefSeqs(start, refSeqBytes * 2, opts);
            }
        }
        return { chrToIndex, indexToChr };
    }
    async getRecordsForRange(chr, min, max, opts = {
        viewAsPairs: false,
        pairAcrossChr: false,
        maxInsertSize: 200000,
    }) {
        return flat(await gen2array(this.streamRecordsForRange(chr, min, max, opts)));
    }
    async *streamRecordsForRange(chr, min, max, opts = {}) {
        const { signal } = opts;
        const chrId = this.chrToIndex && this.chrToIndex[chr];
        let chunks;
        if (!(chrId >= 0)) {
            chunks = [];
        }
        else {
            chunks = await this.index.blocksForRange(chrId, min - 1, max, opts);
            if (!chunks) {
                throw new Error('Error in index fetch');
            }
        }
        for (let i = 0; i < chunks.length; i += 1) {
            await (0,_util__WEBPACK_IMPORTED_MODULE_10__.abortBreakPoint)(signal);
            const size = chunks[i].fetchedSize();
            if (size > this.chunkSizeLimit) {
                throw new Error(`Too many BAM features. BAM chunk size ${size} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit}`);
            }
        }
        const totalSize = chunks
            .map(s => s.fetchedSize())
            .reduce((a, b) => a + b, 0);
        if (totalSize > this.fetchSizeLimit) {
            throw new Error(`data size of ${totalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);
        }
        yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts);
    }
    async *_fetchChunkFeatures(chunks, chrId, min, max, opts) {
        const { viewAsPairs = false } = opts;
        const feats = [];
        let done = false;
        for (let i = 0; i < chunks.length; i++) {
            const c = chunks[i];
            const records = (await this.featureCache.get(c.toString(), {
                chunk: c,
                opts,
            }, opts.signal));
            const recs = [];
            for (let i = 0; i < records.length; i += 1) {
                const feature = records[i];
                if (feature.seq_id() === chrId) {
                    if (feature.get('start') >= max) {
                        // past end of range, can stop iterating
                        done = true;
                        break;
                    }
                    else if (feature.get('end') >= min) {
                        // must be in range
                        recs.push(feature);
                    }
                }
            }
            feats.push(recs);
            yield recs;
            if (done) {
                break;
            }
        }
        (0,_util__WEBPACK_IMPORTED_MODULE_10__.checkAbortSignal)(opts.signal);
        if (viewAsPairs) {
            yield this.fetchPairs(chrId, feats, opts);
        }
    }
    async fetchPairs(chrId, feats, opts) {
        const { pairAcrossChr = false, maxInsertSize = 200000 } = opts;
        const unmatedPairs = {};
        const readIds = {};
        feats.map(ret => {
            const readNames = {};
            for (let i = 0; i < ret.length; i++) {
                const name = ret[i].name();
                const id = ret[i].id();
                if (!readNames[name]) {
                    readNames[name] = 0;
                }
                readNames[name]++;
                readIds[id] = 1;
            }
            object_entries_ponyfill__WEBPACK_IMPORTED_MODULE_2___default()(readNames).forEach(([k, v]) => {
                if (v === 1) {
                    unmatedPairs[k] = true;
                }
            });
        });
        const matePromises = [];
        feats.map(ret => {
            for (let i = 0; i < ret.length; i++) {
                const f = ret[i];
                const name = f.name();
                const start = f.get('start');
                const pnext = f._next_pos();
                const rnext = f._next_refid();
                if (unmatedPairs[name] &&
                    (pairAcrossChr ||
                        (rnext === chrId && Math.abs(start - pnext) < maxInsertSize))) {
                    matePromises.push(this.index.blocksForRange(rnext, pnext, pnext + 1, opts));
                }
            }
        });
        // filter out duplicate chunks (the blocks are lists of chunks, blocks are
        // concatenated, then filter dup chunks)
        const mateChunks = flat(await Promise.all(matePromises))
            .sort()
            .filter((item, pos, ary) => !pos || item.toString() !== ary[pos - 1].toString());
        const mateTotalSize = mateChunks
            .map(s => s.fetchedSize())
            .reduce((a, b) => a + b, 0);
        if (mateTotalSize > this.fetchSizeLimit) {
            throw new Error(`data size of ${mateTotalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);
        }
        const mateFeatPromises = mateChunks.map(async (c) => {
            const { data, cpositions, dpositions, chunk } = await this._readChunk({
                chunk: c,
                opts,
            });
            const feats = await this.readBamFeatures(data, cpositions, dpositions, chunk);
            const mateRecs = [];
            for (let i = 0; i < feats.length; i += 1) {
                const feature = feats[i];
                if (unmatedPairs[feature.get('name')] && !readIds[feature.id()]) {
                    mateRecs.push(feature);
                }
            }
            return mateRecs;
        });
        return flat(await Promise.all(mateFeatPromises));
    }
    async _readChunk({ chunk, opts }) {
        const size = chunk.fetchedSize();
        const { buffer, bytesRead } = await this.bam.read(Buffer.alloc(size), 0, size, chunk.minv.blockPosition, opts);
        const { buffer: data, cpositions, dpositions, } = await (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_1__.unzipChunkSlice)(buffer.subarray(0, Math.min(bytesRead, size)), chunk);
        return { data, cpositions, dpositions, chunk };
    }
    async readBamFeatures(ba, cpositions, dpositions, chunk) {
        let blockStart = 0;
        const sink = [];
        let pos = 0;
        let last = +Date.now();
        while (blockStart + 4 < ba.length) {
            const blockSize = ba.readInt32LE(blockStart);
            const blockEnd = blockStart + 4 + blockSize - 1;
            // increment position to the current decompressed status
            if (dpositions) {
                while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]) { }
                pos--;
            }
            // only try to read the feature if we have all the bytes for it
            if (blockEnd < ba.length) {
                const feature = new _record__WEBPACK_IMPORTED_MODULE_8__["default"]({
                    bytes: {
                        byteArray: ba,
                        start: blockStart,
                        end: blockEnd,
                    },
                    // the below results in an automatically calculated file-offset based ID
                    // if the info for that is available, otherwise crc32 of the features
                    //
                    // cpositions[pos] refers to actual file offset of a bgzip block boundaries
                    //
                    // we multiply by (1 <<8) in order to make sure each block has a "unique"
                    // address space so that data in that block could never overlap
                    //
                    // then the blockStart-dpositions is an uncompressed file offset from
                    // that bgzip block boundary, and since the cpositions are multiplied by
                    // (1 << 8) these uncompressed offsets get a unique space
                    //
                    // this has an extra chunk.minv.dataPosition added on because it blockStart
                    // starts at 0 instead of chunk.minv.dataPosition
                    //
                    // the +1 is just to avoid any possible uniqueId 0 but this does not realistically happen
                    fileOffset: cpositions
                        ? cpositions[pos] * (1 << 8) +
                            (blockStart - dpositions[pos]) +
                            chunk.minv.dataPosition +
                            1
                        : // must be slice, not subarray for buffer polyfill on web
                            buffer_crc32__WEBPACK_IMPORTED_MODULE_0___default().signed(ba.slice(blockStart, blockEnd)),
                });
                sink.push(feature);
                if (this.yieldThreadTime && +Date.now() - last > this.yieldThreadTime) {
                    await (0,_util__WEBPACK_IMPORTED_MODULE_10__.timeout)(1);
                    last = +Date.now();
                }
            }
            blockStart = blockEnd + 1;
        }
        return sink;
    }
    async hasRefSeq(seqName) {
        const refId = this.chrToIndex && this.chrToIndex[seqName];
        return this.index.hasRefSeq(refId);
    }
    async lineCount(seqName) {
        const refId = this.chrToIndex && this.chrToIndex[seqName];
        return this.index.lineCount(refId);
    }
    async indexCov(seqName, start, end) {
        await this.index.parse();
        const seqId = this.chrToIndex && this.chrToIndex[seqName];
        return this.index.indexCov(seqId, start, end);
    }
    async blocksForRange(seqName, start, end, opts) {
        await this.index.parse();
        const seqId = this.chrToIndex && this.chrToIndex[seqName];
        return this.index.blocksForRange(seqId, start, end, opts);
    }
}
//# sourceMappingURL=bamFile.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/chunk.js":
/*!*********************************************!*\
  !*** ./node_modules/@gmod/bam/esm/chunk.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Chunk; }
/* harmony export */ });
// little class representing a chunk in the index
class Chunk {
    /**
     * @param {VirtualOffset} minv
     * @param {VirtualOffset} maxv
     * @param {number} bin
     * @param {number} [fetchedSize]
     */
    constructor(minv, maxv, bin, fetchedSize = undefined) {
        this.minv = minv;
        this.maxv = maxv;
        this.bin = bin;
        this._fetchedSize = fetchedSize;
    }
    toUniqueString() {
        return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;
    }
    toString() {
        return this.toUniqueString();
    }
    compareTo(b) {
        return (this.minv.compareTo(b.minv) ||
            this.maxv.compareTo(b.maxv) ||
            this.bin - b.bin);
    }
    fetchedSize() {
        if (this._fetchedSize !== undefined) {
            return this._fetchedSize;
        }
        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;
    }
}
//# sourceMappingURL=chunk.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/@gmod/bam/esm/constants.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
    //  the read is paired in sequencing, no matter whether it is mapped in a pair
    BAM_FPAIRED: 1,
    //  the read is mapped in a proper pair
    BAM_FPROPER_PAIR: 2,
    //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR
    BAM_FUNMAP: 4,
    //  the mate is unmapped
    BAM_FMUNMAP: 8,
    //  the read is mapped to the reverse strand
    BAM_FREVERSE: 16,
    //  the mate is mapped to the reverse strand
    BAM_FMREVERSE: 32,
    //  this is read1
    BAM_FREAD1: 64,
    //  this is read2
    BAM_FREAD2: 128,
    //  not primary alignment
    BAM_FSECONDARY: 256,
    //  QC failure
    BAM_FQCFAIL: 512,
    //  optical or PCR duplicate
    BAM_FDUP: 1024,
    //  supplementary alignment
    BAM_FSUPPLEMENTARY: 2048,
});
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/csi.js":
/*!*******************************************!*\
  !*** ./node_modules/@gmod/bam/esm/csi.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ CSI; }
/* harmony export */ });
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gmod/bgzf-filehandle */ "./node_modules/@gmod/bgzf-filehandle/esm/index.js");
/* harmony import */ var _virtualOffset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./virtualOffset */ "./node_modules/@gmod/bam/esm/virtualOffset.js");
/* harmony import */ var _chunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk */ "./node_modules/@gmod/bam/esm/chunk.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/bam/esm/util.js");
/* harmony import */ var _indexFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./indexFile */ "./node_modules/@gmod/bam/esm/indexFile.js");






const CSI1_MAGIC = 21582659; // CSI\1
const CSI2_MAGIC = 38359875; // CSI\2
function lshift(num, bits) {
    return num * 2 ** bits;
}
function rshift(num, bits) {
    return Math.floor(num / 2 ** bits);
}
class CSI extends _indexFile__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(args) {
        super(args);
        this.maxBinNumber = 0;
        this.depth = 0;
        this.minShift = 0;
    }
    async lineCount(refId) {
        const indexData = await this.parse();
        if (!indexData) {
            return -1;
        }
        const idx = indexData.indices[refId];
        if (!idx) {
            return -1;
        }
        const { stats } = indexData.indices[refId];
        if (stats) {
            return stats.lineCount;
        }
        return -1;
    }
    async indexCov() {
        return [];
    }
    parseAuxData(bytes, offset, auxLength) {
        if (auxLength < 30) {
            return {};
        }
        const data = {};
        data.formatFlags = bytes.readInt32LE(offset);
        data.coordinateType =
            data.formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
        data.format = { 0: 'generic', 1: 'SAM', 2: 'VCF' }[data.formatFlags & 0xf];
        if (!data.format) {
            throw new Error(`invalid Tabix preset format flags ${data.formatFlags}`);
        }
        data.columnNumbers = {
            ref: bytes.readInt32LE(offset + 4),
            start: bytes.readInt32LE(offset + 8),
            end: bytes.readInt32LE(offset + 12),
        };
        data.metaValue = bytes.readInt32LE(offset + 16);
        data.metaChar = data.metaValue ? String.fromCharCode(data.metaValue) : '';
        data.skipLines = bytes.readInt32LE(offset + 20);
        const nameSectionLength = bytes.readInt32LE(offset + 24);
        Object.assign(data, this._parseNameBytes(bytes.subarray(offset + 28, offset + 28 + nameSectionLength)));
        return data;
    }
    _parseNameBytes(namesBytes) {
        let currRefId = 0;
        let currNameStart = 0;
        const refIdToName = [];
        const refNameToId = {};
        for (let i = 0; i < namesBytes.length; i += 1) {
            if (!namesBytes[i]) {
                if (currNameStart < i) {
                    let refName = namesBytes.toString('utf8', currNameStart, i);
                    refName = this.renameRefSeq(refName);
                    refIdToName[currRefId] = refName;
                    refNameToId[refName] = currRefId;
                }
                currNameStart = i + 1;
                currRefId += 1;
            }
        }
        return { refNameToId, refIdToName };
    }
    // fetch and parse the index
    async _parse(opts) {
        const data = { csi: true, maxBlockSize: 1 << 16 };
        const buffer = (await this.filehandle.readFile(opts));
        const bytes = await (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_1__.unzip)(buffer);
        // check TBI magic numbers
        if (bytes.readUInt32LE(0) === CSI1_MAGIC) {
            data.csiVersion = 1;
        }
        else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {
            data.csiVersion = 2;
        }
        else {
            throw new Error('Not a CSI file');
            // TODO: do we need to support big-endian CSI files?
        }
        this.minShift = bytes.readInt32LE(4);
        this.depth = bytes.readInt32LE(8);
        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;
        const auxLength = bytes.readInt32LE(12);
        if (auxLength) {
            Object.assign(data, this.parseAuxData(bytes, 16, auxLength));
        }
        data.refCount = bytes.readInt32LE(16 + auxLength);
        // read the indexes for each reference sequence
        data.indices = new Array(data.refCount);
        let currOffset = 16 + auxLength + 4;
        for (let i = 0; i < data.refCount; i += 1) {
            await (0,_util__WEBPACK_IMPORTED_MODULE_4__.abortBreakPoint)(opts.signal);
            // the binning index
            const binCount = bytes.readInt32LE(currOffset);
            currOffset += 4;
            const binIndex = {};
            let stats; // < provided by parsing a pseudo-bin, if present
            for (let j = 0; j < binCount; j += 1) {
                const bin = bytes.readUInt32LE(currOffset);
                if (bin > this.maxBinNumber) {
                    // this is a fake bin that actually has stats information
                    // about the reference sequence in it
                    stats = this.parsePseudoBin(bytes, currOffset + 4);
                    currOffset += 4 + 8 + 4 + 16 + 16;
                }
                else {
                    const loffset = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_2__.fromBytes)(bytes, currOffset + 4);
                    this._findFirstData(data, loffset);
                    const chunkCount = bytes.readInt32LE(currOffset + 12);
                    currOffset += 16;
                    const chunks = new Array(chunkCount);
                    for (let k = 0; k < chunkCount; k += 1) {
                        const u = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_2__.fromBytes)(bytes, currOffset);
                        const v = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_2__.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16;
                        // this._findFirstData(data, u)
                        chunks[k] = new _chunk__WEBPACK_IMPORTED_MODULE_3__["default"](u, v, bin);
                    }
                    binIndex[bin] = chunks;
                }
            }
            data.indices[i] = { binIndex, stats };
        }
        return data;
    }
    parsePseudoBin(bytes, offset) {
        const lineCount = (0,_util__WEBPACK_IMPORTED_MODULE_4__.longToNumber)(long__WEBPACK_IMPORTED_MODULE_0___default().fromBytesLE(Array.prototype.slice.call(bytes, offset + 28, offset + 36), true));
        return { lineCount };
    }
    async blocksForRange(refId, min, max, opts = {}) {
        if (min < 0) {
            min = 0;
        }
        const indexData = await this.parse(opts);
        if (!indexData) {
            return [];
        }
        const ba = indexData.indices[refId];
        if (!ba) {
            return [];
        }
        const overlappingBins = this.reg2bins(min, max); // List of bin #s that overlap min, max
        const chunks = [];
        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned
        for (const [start, end] of overlappingBins) {
            for (let bin = start; bin <= end; bin++) {
                if (ba.binIndex[bin]) {
                    const binChunks = ba.binIndex[bin];
                    for (let c = 0; c < binChunks.length; ++c) {
                        chunks.push(new _chunk__WEBPACK_IMPORTED_MODULE_3__["default"](binChunks[c].minv, binChunks[c].maxv, bin));
                    }
                }
            }
        }
        return (0,_util__WEBPACK_IMPORTED_MODULE_4__.optimizeChunks)(chunks, new _virtualOffset__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0));
    }
    /**
     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
     * @returns {Array[number]}
     */
    reg2bins(beg, end) {
        beg -= 1; // < convert to 1-based closed
        if (beg < 1) {
            beg = 1;
        }
        if (end > 2 ** 50) {
            end = 2 ** 34;
        } // 17 GiB ought to be enough for anybody
        end -= 1;
        let l = 0;
        let t = 0;
        let s = this.minShift + this.depth * 3;
        const bins = [];
        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {
            const b = t + rshift(beg, s);
            const e = t + rshift(end, s);
            if (e - b + bins.length > this.maxBinNumber) {
                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);
            }
            bins.push([b, e]);
        }
        return bins;
    }
}
//# sourceMappingURL=csi.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/htsget.js":
/*!**********************************************!*\
  !*** ./node_modules/@gmod/bam/esm/htsget.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ HtsgetFile; }
/* harmony export */ });
/* harmony import */ var _bamFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bamFile */ "./node_modules/@gmod/bam/esm/bamFile.js");
/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cross-fetch/polyfill */ "./node_modules/cross-fetch/dist/browser-polyfill.js");
/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @gmod/bgzf-filehandle */ "./node_modules/@gmod/bgzf-filehandle/esm/index.js");
/* harmony import */ var _sam__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sam */ "./node_modules/@gmod/bam/esm/sam.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];




async function concat(arr, opts) {
    const res = await Promise.all(arr.map(async (chunk) => {
        const { url, headers } = chunk;
        if (url.startsWith('data:')) {
            return Buffer.from(url.split(',')[1], 'base64');
        }
        else {
            //remove referer header, it is not even allowed to be specified
            //@ts-ignore
            //eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { referer, ...rest } = headers;
            const res = await fetch(url, {
                ...opts,
                headers: { ...opts.headers, ...rest },
            });
            if (!res.ok) {
                throw new Error(`Failed to fetch ${res.statusText}`);
            }
            return Buffer.from(await res.arrayBuffer());
        }
    }));
    return Buffer.concat(await Promise.all(res.map(elt => (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_2__.unzip)(elt))));
}
class HtsgetFile extends _bamFile__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(args) {
        // @ts-ignore override bam defaults
        super({ bamFilehandle: '?', baiFilehandle: '?' });
        this.baseUrl = args.baseUrl;
        this.trackId = args.trackId;
    }
    async *streamRecordsForRange(chr, min, max, opts = {
        viewAsPairs: false,
        pairAcrossChr: false,
        maxInsertSize: 200000,
    }) {
        const base = `${this.baseUrl}/${this.trackId}`;
        const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`;
        const chrId = this.chrToIndex && this.chrToIndex[chr];
        const result = await fetch(url, { ...opts });
        if (!result.ok) {
            throw new Error(result.statusText);
        }
        const data = await result.json();
        const uncba = await concat(data.htsget.urls.slice(1), opts);
        const chunk = {
            buffer: uncba,
            chunk: { minv: { dataPosition: 0 } },
            toString() {
                return `${chr}_${min}_${max}`;
            },
        };
        yield* this._fetchChunkFeatures(
        // @ts-ignore
        [chunk], chrId, min, max, opts);
    }
    //@ts-ignore
    async _readChunk(params) {
        const { chunk } = params;
        const { buffer, chunk: c2 } = chunk;
        return { data: buffer, cpositions: null, dpositions: null, chunk: c2 };
    }
    async getHeader(opts = {}) {
        const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`;
        const result = await fetch(url, opts);
        if (!result.ok) {
            throw new Error(`Failed to fetch ${result.statusText}`);
        }
        const data = await result.json();
        const uncba = await concat(data.htsget.urls, opts);
        if (uncba.readInt32LE(0) !== _bamFile__WEBPACK_IMPORTED_MODULE_0__.BAM_MAGIC) {
            throw new Error('Not a BAM file');
        }
        const headLen = uncba.readInt32LE(4);
        const headerText = uncba.toString('utf8', 8, 8 + headLen);
        const samHeader = (0,_sam__WEBPACK_IMPORTED_MODULE_3__.parseHeaderText)(headerText);
        // use the @SQ lines in the header to figure out the
        // mapping between ref ref ID numbers and names
        const idToName = [];
        const nameToId = {};
        const sqLines = samHeader.filter((l) => l.tag === 'SQ');
        sqLines.forEach((sqLine, refId) => {
            sqLine.data.forEach((item) => {
                if (item.tag === 'SN') {
                    // this is the ref name
                    const refName = item.value;
                    nameToId[refName] = refId;
                    idToName[refId] = refName;
                }
            });
        });
        this.chrToIndex = nameToId;
        this.indexToChr = idToName;
        return samHeader;
    }
}
//# sourceMappingURL=htsget.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@gmod/bam/esm/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BAI": function() { return /* reexport safe */ _bai__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   "BamFile": function() { return /* reexport safe */ _bamFile__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "BamRecord": function() { return /* reexport safe */ _record__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   "CSI": function() { return /* reexport safe */ _csi__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "HtsgetFile": function() { return /* reexport safe */ _htsget__WEBPACK_IMPORTED_MODULE_3__["default"]; }
/* harmony export */ });
/* harmony import */ var _bai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bai */ "./node_modules/@gmod/bam/esm/bai.js");
/* harmony import */ var _csi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./csi */ "./node_modules/@gmod/bam/esm/csi.js");
/* harmony import */ var _bamFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bamFile */ "./node_modules/@gmod/bam/esm/bamFile.js");
/* harmony import */ var _htsget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./htsget */ "./node_modules/@gmod/bam/esm/htsget.js");
/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./record */ "./node_modules/@gmod/bam/esm/record.js");






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/indexFile.js":
/*!*************************************************!*\
  !*** ./node_modules/@gmod/bam/esm/indexFile.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ IndexFile; }
/* harmony export */ });
class IndexFile {
    /**
     * @param {filehandle} filehandle
     * @param {function} [renameRefSeqs]
     */
    constructor({ filehandle, renameRefSeq = (n) => n, }) {
        this.filehandle = filehandle;
        this.renameRefSeq = renameRefSeq;
    }
    _findFirstData(data, virtualOffset) {
        const currentFdl = data.firstDataLine;
        if (currentFdl) {
            data.firstDataLine =
                currentFdl.compareTo(virtualOffset) > 0 ? virtualOffset : currentFdl;
        }
        else {
            data.firstDataLine = virtualOffset;
        }
    }
    async parse(opts = {}) {
        if (!this.setupP) {
            this.setupP = this._parse(opts).catch(e => {
                this.setupP = undefined;
                throw e;
            });
        }
        return this.setupP;
    }
    async hasRefSeq(seqId, opts = {}) {
        return !!((await this.parse(opts)).indices[seqId] || {}).binIndex;
    }
}
//# sourceMappingURL=indexFile.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/record.js":
/*!**********************************************!*\
  !*** ./node_modules/@gmod/bam/esm/record.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BamRecord; }
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@gmod/bam/esm/constants.js");
/* eslint-disable @typescript-eslint/no-empty-function */

const SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('');
const CIGAR_DECODER = 'MIDNSHP=X???????'.split('');
/**
 * Class of each BAM record returned by this API.
 */
class BamRecord {
    constructor(args) {
        this.data = {};
        this._tagList = [];
        this._allTagsParsed = false;
        const { bytes, fileOffset } = args;
        const { byteArray, start } = bytes;
        this.data = {};
        this.bytes = bytes;
        this._id = fileOffset;
        this._refID = byteArray.readInt32LE(start + 4);
        this.data.start = byteArray.readInt32LE(start + 8);
        this.flags = (byteArray.readInt32LE(start + 16) & 0xffff0000) >> 16;
    }
    get(field) {
        //@ts-ignore
        if (this[field]) {
            //@ts-ignore
            if (this.data[field]) {
                return this.data[field];
            }
            //@ts-ignore
            this.data[field] = this[field]();
            return this.data[field];
        }
        return this._get(field.toLowerCase());
    }
    end() {
        return this.get('start') + this.get('length_on_ref');
    }
    seq_id() {
        return this._refID;
    }
    // same as get(), except requires lower-case arguments.  used
    // internally to save lots of calls to field.toLowerCase()
    _get(field) {
        if (field in this.data) {
            return this.data[field];
        }
        this.data[field] = this._parseTag(field);
        return this.data[field];
    }
    _tags() {
        this._parseAllTags();
        let tags = ['seq'];
        if (!this.isSegmentUnmapped()) {
            tags.push('start', 'end', 'strand', 'score', 'qual', 'MQ', 'CIGAR', 'length_on_ref', 'template_length');
        }
        if (this.isPaired()) {
            tags.push('next_segment_position', 'pair_orientation');
        }
        tags = tags.concat(this._tagList || []);
        Object.keys(this.data).forEach(k => {
            if (k[0] !== '_' && k !== 'next_seq_id') {
                tags.push(k);
            }
        });
        const seen = {};
        return tags.filter(t => {
            if ((t in this.data && this.data[t] === undefined) ||
                t === 'CG' ||
                t === 'cg') {
                return false;
            }
            const lt = t.toLowerCase();
            const s = seen[lt];
            seen[lt] = true;
            return !s;
        });
    }
    parent() {
        return undefined;
    }
    children() {
        return this.get('subfeatures');
    }
    id() {
        return this._id;
    }
    // special parsers
    /**
     * Mapping quality score.
     */
    mq() {
        const mq = (this.get('_bin_mq_nl') & 0xff00) >> 8;
        return mq === 255 ? undefined : mq;
    }
    score() {
        return this.get('mq');
    }
    qual() {
        var _a;
        return (_a = this.qualRaw()) === null || _a === void 0 ? void 0 : _a.join(' ');
    }
    qualRaw() {
        if (this.isSegmentUnmapped()) {
            return undefined;
        }
        const { start, byteArray } = this.bytes;
        const p = start +
            36 +
            this.get('_l_read_name') +
            this.get('_n_cigar_op') * 4 +
            this.get('_seq_bytes');
        const lseq = this.get('seq_length');
        return byteArray.subarray(p, p + lseq);
    }
    strand() {
        return this.isReverseComplemented() ? -1 : 1;
    }
    multi_segment_next_segment_strand() {
        if (this.isMateUnmapped()) {
            return undefined;
        }
        return this.isMateReverseComplemented() ? -1 : 1;
    }
    name() {
        return this.get('_read_name');
    }
    _read_name() {
        const nl = this.get('_l_read_name');
        const { byteArray, start } = this.bytes;
        return byteArray.toString('ascii', start + 36, start + 36 + nl - 1);
    }
    /**
     * Get the value of a tag, parsing the tags as far as necessary.
     * Only called if we have not already parsed that field.
     */
    _parseTag(tagName) {
        // if all of the tags have been parsed and we're still being
        // called, we already know that we have no such tag, because
        // it would already have been cached.
        if (this._allTagsParsed) {
            return undefined;
        }
        const { byteArray, start } = this.bytes;
        let p = this._tagOffset ||
            start +
                36 +
                this.get('_l_read_name') +
                this.get('_n_cigar_op') * 4 +
                this.get('_seq_bytes') +
                this.get('seq_length');
        const blockEnd = this.bytes.end;
        let lcTag;
        while (p < blockEnd && lcTag !== tagName) {
            const tag = String.fromCharCode(byteArray[p], byteArray[p + 1]);
            lcTag = tag.toLowerCase();
            const type = String.fromCharCode(byteArray[p + 2]);
            p += 3;
            let value;
            switch (type) {
                case 'A':
                    value = String.fromCharCode(byteArray[p]);
                    p += 1;
                    break;
                case 'i':
                    value = byteArray.readInt32LE(p);
                    p += 4;
                    break;
                case 'I':
                    value = byteArray.readUInt32LE(p);
                    p += 4;
                    break;
                case 'c':
                    value = byteArray.readInt8(p);
                    p += 1;
                    break;
                case 'C':
                    value = byteArray.readUInt8(p);
                    p += 1;
                    break;
                case 's':
                    value = byteArray.readInt16LE(p);
                    p += 2;
                    break;
                case 'S':
                    value = byteArray.readUInt16LE(p);
                    p += 2;
                    break;
                case 'f':
                    value = byteArray.readFloatLE(p);
                    p += 4;
                    break;
                case 'Z':
                case 'H':
                    value = '';
                    while (p <= blockEnd) {
                        const cc = byteArray[p++];
                        if (cc === 0) {
                            break;
                        }
                        else {
                            value += String.fromCharCode(cc);
                        }
                    }
                    break;
                case 'B': {
                    value = '';
                    const cc = byteArray[p++];
                    const Btype = String.fromCharCode(cc);
                    const limit = byteArray.readInt32LE(p);
                    p += 4;
                    if (Btype === 'i') {
                        if (tag === 'CG') {
                            for (let k = 0; k < limit; k++) {
                                const cigop = byteArray.readInt32LE(p);
                                const lop = cigop >> 4;
                                const op = CIGAR_DECODER[cigop & 0xf];
                                value += lop + op;
                                p += 4;
                            }
                        }
                        else {
                            for (let k = 0; k < limit; k++) {
                                value += byteArray.readInt32LE(p);
                                if (k + 1 < limit) {
                                    value += ',';
                                }
                                p += 4;
                            }
                        }
                    }
                    if (Btype === 'I') {
                        if (tag === 'CG') {
                            for (let k = 0; k < limit; k++) {
                                const cigop = byteArray.readUInt32LE(p);
                                const lop = cigop >> 4;
                                const op = CIGAR_DECODER[cigop & 0xf];
                                value += lop + op;
                                p += 4;
                            }
                        }
                        else {
                            for (let k = 0; k < limit; k++) {
                                value += byteArray.readUInt32LE(p);
                                if (k + 1 < limit) {
                                    value += ',';
                                }
                                p += 4;
                            }
                        }
                    }
                    if (Btype === 's') {
                        for (let k = 0; k < limit; k++) {
                            value += byteArray.readInt16LE(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 2;
                        }
                    }
                    if (Btype === 'S') {
                        for (let k = 0; k < limit; k++) {
                            value += byteArray.readUInt16LE(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 2;
                        }
                    }
                    if (Btype === 'c') {
                        for (let k = 0; k < limit; k++) {
                            value += byteArray.readInt8(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 1;
                        }
                    }
                    if (Btype === 'C') {
                        for (let k = 0; k < limit; k++) {
                            value += byteArray.readUInt8(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 1;
                        }
                    }
                    if (Btype === 'f') {
                        for (let k = 0; k < limit; k++) {
                            value += byteArray.readFloatLE(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 4;
                        }
                    }
                    break;
                }
                default:
                    console.warn(`Unknown BAM tag type '${type}', tags may be incomplete`);
                    value = undefined;
                    p = blockEnd; // stop parsing tags
            }
            this._tagOffset = p;
            this._tagList.push(tag);
            if (lcTag === tagName) {
                return value;
            }
            this.data[lcTag] = value;
        }
        this._allTagsParsed = true;
        return undefined;
    }
    _parseAllTags() {
        this._parseTag('');
    }
    _parseCigar(cigar) {
        return (
        //@ts-ignore
        cigar
            .match(/\d+\D/g)
            //@ts-ignore
            .map(op => [op.match(/\D/)[0].toUpperCase(), parseInt(op, 10)]));
    }
    /**
     * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped
     */
    isPaired() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FPAIRED);
    }
    /** @returns {boolean} true if the read is paired, and both segments are mapped */
    isProperlyPaired() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FPROPER_PAIR);
    }
    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */
    isSegmentUnmapped() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FUNMAP);
    }
    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */
    isMateUnmapped() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FMUNMAP);
    }
    /** @returns {boolean} true if the read is mapped to the reverse strand */
    isReverseComplemented() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FREVERSE);
    }
    /** @returns {boolean} true if the mate is mapped to the reverse strand */
    isMateReverseComplemented() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FMREVERSE);
    }
    /** @returns {boolean} true if this is read number 1 in a pair */
    isRead1() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FREAD1);
    }
    /** @returns {boolean} true if this is read number 2 in a pair */
    isRead2() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FREAD2);
    }
    /** @returns {boolean} true if this is a secondary alignment */
    isSecondary() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FSECONDARY);
    }
    /** @returns {boolean} true if this read has failed QC checks */
    isFailedQc() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FQCFAIL);
    }
    /** @returns {boolean} true if the read is an optical or PCR duplicate */
    isDuplicate() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FDUP);
    }
    /** @returns {boolean} true if this is a supplementary alignment */
    isSupplementary() {
        return !!(this.flags & _constants__WEBPACK_IMPORTED_MODULE_0__["default"].BAM_FSUPPLEMENTARY);
    }
    cigar() {
        if (this.isSegmentUnmapped()) {
            return undefined;
        }
        const { byteArray, start } = this.bytes;
        const numCigarOps = this.get('_n_cigar_op');
        let p = start + 36 + this.get('_l_read_name');
        const seqLen = this.get('seq_length');
        let cigar = '';
        let lref = 0;
        // check for CG tag by inspecting whether the CIGAR field
        // contains a clip that consumes entire seqLen
        let cigop = byteArray.readInt32LE(p);
        let lop = cigop >> 4;
        let op = CIGAR_DECODER[cigop & 0xf];
        if (op === 'S' && lop === seqLen) {
            // if there is a CG the second CIGAR field will
            // be a N tag the represents the length on ref
            p += 4;
            cigop = byteArray.readInt32LE(p);
            lop = cigop >> 4;
            op = CIGAR_DECODER[cigop & 0xf];
            if (op !== 'N') {
                console.warn('CG tag with no N tag');
            }
            this.data.length_on_ref = lop;
            return this.get('CG');
        }
        else {
            for (let c = 0; c < numCigarOps; ++c) {
                cigop = byteArray.readInt32LE(p);
                lop = cigop >> 4;
                op = CIGAR_DECODER[cigop & 0xf];
                cigar += lop + op;
                // soft clip, hard clip, and insertion don't count toward
                // the length on the reference
                if (op !== 'H' && op !== 'S' && op !== 'I') {
                    lref += lop;
                }
                p += 4;
            }
            this.data.length_on_ref = lref;
            return cigar;
        }
    }
    _flags() { }
    length_on_ref() {
        if (this.data.length_on_ref) {
            return this.data.length_on_ref;
        }
        else {
            this.get('cigar'); // the length_on_ref is set as a side effect
            return this.data.length_on_ref;
        }
    }
    _n_cigar_op() {
        return this.get('_flag_nc') & 0xffff;
    }
    _l_read_name() {
        return this.get('_bin_mq_nl') & 0xff;
    }
    /**
     * number of bytes in the sequence field
     */
    _seq_bytes() {
        return (this.get('seq_length') + 1) >> 1;
    }
    getReadBases() {
        return this.seq();
    }
    seq() {
        const { byteArray, start } = this.bytes;
        const p = start + 36 + this.get('_l_read_name') + this.get('_n_cigar_op') * 4;
        const seqBytes = this.get('_seq_bytes');
        const len = this.get('seq_length');
        let buf = '';
        let i = 0;
        for (let j = 0; j < seqBytes; ++j) {
            const sb = byteArray[p + j];
            buf += SEQRET_DECODER[(sb & 0xf0) >> 4];
            i++;
            if (i < len) {
                buf += SEQRET_DECODER[sb & 0x0f];
                i++;
            }
        }
        return buf;
    }
    // adapted from igv.js
    getPairOrientation() {
        if (!this.isSegmentUnmapped() &&
            !this.isMateUnmapped() &&
            this._refID === this._next_refid()) {
            const s1 = this.isReverseComplemented() ? 'R' : 'F';
            const s2 = this.isMateReverseComplemented() ? 'R' : 'F';
            let o1 = ' ';
            let o2 = ' ';
            if (this.isRead1()) {
                o1 = '1';
                o2 = '2';
            }
            else if (this.isRead2()) {
                o1 = '2';
                o2 = '1';
            }
            const tmp = [];
            const isize = this.template_length();
            if (isize > 0) {
                tmp[0] = s1;
                tmp[1] = o1;
                tmp[2] = s2;
                tmp[3] = o2;
            }
            else {
                tmp[2] = s1;
                tmp[3] = o1;
                tmp[0] = s2;
                tmp[1] = o2;
            }
            return tmp.join('');
        }
        return null;
    }
    _bin_mq_nl() {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 12);
    }
    _flag_nc() {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 16);
    }
    seq_length() {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 20);
    }
    _next_refid() {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 24);
    }
    _next_pos() {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 28);
    }
    template_length() {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 32);
    }
    toJSON() {
        const data = {};
        Object.keys(this).forEach(k => {
            if (k.charAt(0) === '_' || k === 'bytes') {
                return;
            }
            //@ts-ignore
            data[k] = this[k];
        });
        return data;
    }
}
//# sourceMappingURL=record.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/sam.js":
/*!*******************************************!*\
  !*** ./node_modules/@gmod/bam/esm/sam.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseHeaderText": function() { return /* binding */ parseHeaderText; }
/* harmony export */ });
function parseHeaderText(text) {
    const lines = text.split(/\r?\n/);
    const data = [];
    lines.forEach(line => {
        const [tag, ...fields] = line.split(/\t/);
        const parsedFields = fields.map(f => {
            const [fieldTag, value] = f.split(':', 2);
            return { tag: fieldTag, value };
        });
        if (tag) {
            data.push({ tag: tag.substr(1), data: parsedFields });
        }
    });
    return data;
}
//# sourceMappingURL=sam.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/util.js":
/*!********************************************!*\
  !*** ./node_modules/@gmod/bam/esm/util.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abortBreakPoint": function() { return /* binding */ abortBreakPoint; },
/* harmony export */   "canMergeBlocks": function() { return /* binding */ canMergeBlocks; },
/* harmony export */   "checkAbortSignal": function() { return /* binding */ checkAbortSignal; },
/* harmony export */   "longToNumber": function() { return /* binding */ longToNumber; },
/* harmony export */   "makeOpts": function() { return /* binding */ makeOpts; },
/* harmony export */   "optimizeChunks": function() { return /* binding */ optimizeChunks; },
/* harmony export */   "timeout": function() { return /* binding */ timeout; }
/* harmony export */ });
function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function longToNumber(long) {
    if (long.greaterThan(Number.MAX_SAFE_INTEGER) ||
        long.lessThan(Number.MIN_SAFE_INTEGER)) {
        throw new Error('integer overflow');
    }
    return long.toNumber();
}
/**
 * Properly check if the given AbortSignal is aborted.
 * Per the standard, if the signal reads as aborted,
 * this function throws either a DOMException AbortError, or a regular error
 * with a `code` attribute set to `ERR_ABORTED`.
 *
 * For convenience, passing `undefined` is a no-op
 *
 * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute
 * @returns nothing
 */
function checkAbortSignal(signal) {
    if (!signal) {
        return;
    }
    if (signal.aborted) {
        // console.log('bam aborted!')
        if (typeof DOMException !== 'undefined') {
            throw new DOMException('aborted', 'AbortError');
        }
        else {
            const e = new Error('aborted');
            //@ts-ignore
            e.code = 'ERR_ABORTED';
            throw e;
        }
    }
}
/**
 * Skips to the next tick, then runs `checkAbortSignal`.
 * Await this to inside an otherwise synchronous loop to
 * provide a place to break when an abort signal is received.
 * @param {AbortSignal} signal
 */
async function abortBreakPoint(signal) {
    await Promise.resolve();
    checkAbortSignal(signal);
}
function canMergeBlocks(chunk1, chunk2) {
    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&
        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);
}
function makeOpts(obj = {}) {
    return 'aborted' in obj ? { signal: obj } : obj;
}
function optimizeChunks(chunks, lowest) {
    const mergedChunks = [];
    let lastChunk = null;
    if (chunks.length === 0) {
        return chunks;
    }
    chunks.sort((c0, c1) => {
        const dif = c0.minv.blockPosition - c1.minv.blockPosition;
        if (dif !== 0) {
            return dif;
        }
        else {
            return c0.minv.dataPosition - c1.minv.dataPosition;
        }
    });
    chunks.forEach(chunk => {
        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {
            if (lastChunk === null) {
                mergedChunks.push(chunk);
                lastChunk = chunk;
            }
            else {
                if (canMergeBlocks(lastChunk, chunk)) {
                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {
                        lastChunk.maxv = chunk.maxv;
                    }
                }
                else {
                    mergedChunks.push(chunk);
                    lastChunk = chunk;
                }
            }
        }
    });
    return mergedChunks;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@gmod/bam/esm/virtualOffset.js":
/*!*****************************************************!*\
  !*** ./node_modules/@gmod/bam/esm/virtualOffset.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ VirtualOffset; },
/* harmony export */   "fromBytes": function() { return /* binding */ fromBytes; }
/* harmony export */ });
class VirtualOffset {
    constructor(blockPosition, dataPosition) {
        this.blockPosition = blockPosition; // < offset of the compressed data block
        this.dataPosition = dataPosition; // < offset into the uncompressed data
    }
    toString() {
        return `${this.blockPosition}:${this.dataPosition}`;
    }
    compareTo(b) {
        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);
    }
    static min(...args) {
        let min;
        let i = 0;
        for (; !min; i += 1) {
            min = args[i];
        }
        for (; i < args.length; i += 1) {
            if (min.compareTo(args[i]) > 0) {
                min = args[i];
            }
        }
        return min;
    }
}
function fromBytes(bytes, offset = 0, bigendian = false) {
    if (bigendian) {
        throw new Error('big-endian virtual file offsets not implemented');
    }
    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +
        bytes[offset + 6] * 0x100000000 +
        bytes[offset + 5] * 0x1000000 +
        bytes[offset + 4] * 0x10000 +
        bytes[offset + 3] * 0x100 +
        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);
}
//# sourceMappingURL=virtualOffset.js.map

/***/ }),

/***/ "./node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamAdapter.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamAdapter.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BamAdapter; }
/* harmony export */ });
/* harmony import */ var _gmod_bam__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @gmod/bam */ "./node_modules/@gmod/bam/esm/index.js");
/* harmony import */ var _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jbrowse/core/data_adapters/BaseAdapter */ "./node_modules/@jbrowse/core/data_adapters/BaseAdapter.js");
/* harmony import */ var _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jbrowse_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jbrowse/core/util */ "./node_modules/@jbrowse/core/util/index.js");
/* harmony import */ var _jbrowse_core_util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jbrowse/core/util/io */ "./node_modules/@jbrowse/core/util/io/index.js");
/* harmony import */ var _jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jbrowse_core_util_rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jbrowse/core/util/rxjs */ "./node_modules/@jbrowse/core/util/rxjs.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/internal/operators/toArray.js");
/* harmony import */ var _jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jbrowse/core/configuration */ "./node_modules/@jbrowse/core/configuration/index.js");
/* harmony import */ var _jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _BamSlightlyLazyFeature__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BamSlightlyLazyFeature */ "./node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamSlightlyLazyFeature.js");








class BamAdapter extends _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseFeatureDataAdapter {
    // derived classes may not use the same configuration so a custom
    // configure method allows derived classes to override this behavior
    async configure() {
        if (!this.configured) {
            const bamLocation = (0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(this.config, 'bamLocation');
            const location = (0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(this.config, ['index', 'location']);
            const indexType = (0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(this.config, ['index', 'indexType']);
            const bam = new _gmod_bam__WEBPACK_IMPORTED_MODULE_0__.BamFile({
                bamFilehandle: (0,_jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_3__.openLocation)(bamLocation, this.pluginManager),
                csiFilehandle: indexType === 'CSI'
                    ? (0,_jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_3__.openLocation)(location, this.pluginManager)
                    : undefined,
                baiFilehandle: indexType !== 'CSI'
                    ? (0,_jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_3__.openLocation)(location, this.pluginManager)
                    : undefined,
                // chunkSizeLimit and fetchSizeLimit are more troublesome than
                // helpful, and have given overly large values on the ultra long
                // nanopore reads even with 500MB limits, so disabled with infinity
                chunkSizeLimit: Infinity,
                fetchSizeLimit: Infinity,
                yieldThreadTime: Infinity,
            });
            const adapterConfig = (0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(this.config, 'sequenceAdapter');
            if (adapterConfig && this.getSubAdapter) {
                this.configured = this.getSubAdapter(adapterConfig).then(({ dataAdapter }) => ({
                    bam,
                    sequenceAdapter: dataAdapter,
                }));
            }
            else {
                this.configured = Promise.resolve({ bam });
            }
        }
        return this.configured;
    }
    async getHeader(opts) {
        const { bam } = await this.configure();
        return bam.getHeaderText(opts);
    }
    async setupPre(opts) {
        const { statusCallback = () => { } } = opts || {};
        const { bam } = await this.configure();
        this.samHeader = await (0,_jbrowse_core_util__WEBPACK_IMPORTED_MODULE_2__.updateStatus)('Downloading index', statusCallback, async () => {
            const samHeader = await bam.getHeader(opts);
            // use the @SQ lines in the header to figure out the
            // mapping between ref ref ID numbers and names
            const idToName = [];
            const nameToId = {};
            samHeader
                .filter(l => l.tag === 'SQ')
                .forEach((sqLine, refId) => {
                sqLine.data.forEach(item => {
                    if (item.tag === 'SN') {
                        // this is the ref name
                        const refName = item.value;
                        nameToId[refName] = refId;
                        idToName[refId] = refName;
                    }
                });
            });
            return { idToName, nameToId };
        });
        return this.samHeader;
    }
    async setup(opts) {
        if (!this.setupP) {
            this.setupP = this.setupPre(opts).catch(e => {
                this.setupP = undefined;
                throw e;
            });
        }
        return this.setupP;
    }
    async getRefNames(opts) {
        const { idToName } = await this.setup(opts);
        return idToName;
    }
    async seqFetch(refName, start, end) {
        const { sequenceAdapter } = await this.configure();
        const refSeqStore = sequenceAdapter;
        if (!refSeqStore) {
            return undefined;
        }
        if (!refName) {
            return undefined;
        }
        const features = refSeqStore.getFeatures({
            refName,
            start,
            end,
            assemblyName: '',
        });
        const seqChunks = await features.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.toArray)()).toPromise();
        let sequence = '';
        seqChunks
            .sort((a, b) => a.get('start') - b.get('start'))
            .forEach(chunk => {
            const chunkStart = chunk.get('start');
            const chunkEnd = chunk.get('end');
            const trimStart = Math.max(start - chunkStart, 0);
            const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);
            const trimLength = trimEnd - trimStart;
            const chunkSeq = chunk.get('seq') || chunk.get('residues');
            sequence += chunkSeq.substr(trimStart, trimLength);
        });
        if (sequence.length !== end - start) {
            throw new Error(`sequence fetch failed: fetching ${refName}:${(start - 1).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(end - start).toLocaleString()}`);
        }
        return sequence;
    }
    getFeatures(region, opts) {
        const { refName, start, end, originalRefName } = region;
        const { signal, filterBy, statusCallback = () => { } } = opts || {};
        return (0,_jbrowse_core_util_rxjs__WEBPACK_IMPORTED_MODULE_4__.ObservableCreate)(async (observer) => {
            const { bam } = await this.configure();
            await this.setup(opts);
            statusCallback('Downloading alignments');
            const records = await bam.getRecordsForRange(refName, start, end, opts);
            const { flagInclude = 0, flagExclude = 0, tagFilter, readName, } = filterBy || {};
            for (const record of records) {
                let ref;
                if (!record.get('MD')) {
                    ref = await this.seqFetch(originalRefName || refName, record.get('start'), record.get('end'));
                }
                const flags = record.flags;
                if (!((flags & flagInclude) === flagInclude && !(flags & flagExclude))) {
                    continue;
                }
                if (tagFilter) {
                    const val = record.get(tagFilter.tag);
                    if (!(val === '*' ? val !== undefined : val === tagFilter.value)) {
                        continue;
                    }
                }
                if (readName && record.get('name') !== readName) {
                    continue;
                }
                observer.next(new _BamSlightlyLazyFeature__WEBPACK_IMPORTED_MODULE_6__["default"](record, this, ref));
            }
            statusCallback('');
            observer.complete();
        }, signal);
    }
    async estimateRegionsStats(regions, opts) {
        const { bam } = await this.configure();
        // this is a method to avoid calling on htsget adapters
        // @ts-ignore
        if (bam.index.filehandle !== '?') {
            const bytes = await (0,_jbrowse_core_util__WEBPACK_IMPORTED_MODULE_2__.bytesForRegions)(regions, bam);
            const fetchSizeLimit = (0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(this.config, 'fetchSizeLimit');
            return { bytes, fetchSizeLimit };
        }
        else {
            return super.estimateRegionsStats(regions, opts);
        }
    }
    freeResources( /* { region } */) { }
    // depends on setup being called before the BAM constructor
    refIdToName(refId) {
        var _a;
        return (_a = this.samHeader) === null || _a === void 0 ? void 0 : _a.idToName[refId];
    }
}
//# sourceMappingURL=BamAdapter.js.map

/***/ }),

/***/ "./node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamSlightlyLazyFeature.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamSlightlyLazyFeature.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BamSlightlyLazyFeature; }
/* harmony export */ });
/* harmony import */ var _MismatchParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MismatchParser */ "./node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/MismatchParser.js");

class BamSlightlyLazyFeature {
    // uses parameter properties to automatically create fields on the class
    // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties
    constructor(record, adapter, ref) {
        this.record = record;
        this.adapter = adapter;
        this.ref = ref;
    }
    _get_name() {
        return this.record.get('name');
    }
    _get_type() {
        return 'match';
    }
    _get_score() {
        return this.record.get('mq');
    }
    _get_flags() {
        return this.record.flags;
    }
    _get_strand() {
        return this.record.isReverseComplemented() ? -1 : 1;
    }
    _get_pair_orientation() {
        return this.record.isPaired() ? this.record.getPairOrientation() : undefined;
    }
    _get_next_seq_id() {
        return this.record._next_refid();
    }
    _get_seq_id() {
        // @ts-ignore
        return this.record._refID;
    }
    _get_next_refName() {
        return this.adapter.refIdToName(this.record._next_refid());
    }
    _get_next_segment_position() {
        const { record, adapter } = this;
        return record.isPaired()
            ? `${adapter.refIdToName(record._next_refid())}:${record._next_pos() + 1}`
            : undefined;
    }
    _get_seq() {
        return this.record.getReadBases();
    }
    qualRaw() {
        return this.record.qualRaw();
    }
    set() { }
    tags() {
        const properties = Object.getOwnPropertyNames(BamSlightlyLazyFeature.prototype);
        return [
            ...new Set(properties
                .filter(prop => prop.startsWith('_get_') &&
                prop !== '_get_mismatches' &&
                prop !== '_get_tags' &&
                prop !== '_get_next_seq_id' &&
                prop !== '_get_seq_id')
                .map(methodName => methodName.replace('_get_', ''))
                .concat(this.record._tags())),
        ];
    }
    id() {
        return `${this.adapter.id}-${this.record.id()}`;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get(field) {
        const methodName = `_get_${field}`;
        // @ts-ignore
        if (this[methodName]) {
            // @ts-ignore
            return this[methodName]();
        }
        return this.record.get(field);
    }
    _get_refName() {
        return this.adapter.refIdToName(this.record.seq_id());
    }
    parent() {
        return undefined;
    }
    children() {
        return undefined;
    }
    pairedFeature() {
        return false;
    }
    toJSON() {
        return {
            ...Object.fromEntries(this.tags()
                .map(t => [t, this.get(t)])
                .filter(elt => elt[1] !== undefined)),
            uniqueId: this.id(),
        };
    }
    _get_mismatches() {
        return (0,_MismatchParser__WEBPACK_IMPORTED_MODULE_0__.getMismatches)(this.get('CIGAR'), this.get('MD'), this.get('seq'), this.ref, this.qualRaw());
    }
    _get_clipPos() {
        const cigar = this.get('CIGAR') || '';
        return this.get('strand') === -1
            ? +(cigar.match(/(\d+)[SH]$/) || [])[1] || 0
            : +(cigar.match(/^(\d+)([SH])/) || [])[1] || 0;
    }
}
//# sourceMappingURL=BamSlightlyLazyFeature.js.map

/***/ }),

/***/ "./node_modules/cross-fetch/dist/browser-polyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-polyfill.js ***!
  \***********************************************************/
/***/ (function() {

(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(typeof self !== 'undefined' ? self : this);


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jbrowse_plugin-alignments_esm_BamAdapter_BamAdapter_js.bundle.js.map