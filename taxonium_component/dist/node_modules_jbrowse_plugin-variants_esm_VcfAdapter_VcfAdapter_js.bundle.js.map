{"version":3,"file":"node_modules_jbrowse_plugin-variants_esm_VcfAdapter_VcfAdapter_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAkF;AAC7B;AACM;AACE;AACR;AACP;AAClB;AAC2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACe,yBAAyB,2FAAsB;AAC9D;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,2BAA2B,iDAAG,GAAG,gBAAgB;AACjD;AACA;AACA;AACA;AACA,6BAA6B,mEAAY,CAAC,2EAAc;AACxD,2CAA2C,4DAAK;AAChD;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA,+BAA+B,iEAAY;AAC3C;AACA;AACA;AACA,SAAS,IAAI;AACb,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B;AAC5B,gBAAgB,eAAe;AAC/B;AACA;AACA,iCAAiC;AACjC,eAAe,yEAAgB;AAC/B;AACA;AACA,wBAAwB,sBAAsB;AAC9C,wBAAwB,uBAAuB;AAC/C,mCAAmC,iDAAG,GAAG,gBAAgB;AACzD,yIAAyI,mEAAU;AACnJ;AACA;AACA,2BAA2B,QAAQ,GAAG,KAAK;AAC3C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;AClGA;;;;;;;;;;ACAA","sources":["webpack://taxonium/./node_modules/@jbrowse/plugin-variants/esm/VcfAdapter/VcfAdapter.js","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|./localFile","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|file-uri-to-path"],"sourcesContent":["import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { readConfObject } from '@jbrowse/core/configuration';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport { unzip } from '@gmod/bgzf-filehandle';\nimport VCF from '@gmod/vcf';\nimport VcfFeature from '../VcfTabixAdapter/VcfFeature';\nconst readVcf = (f) => {\n    const lines = f.split('\\n');\n    const header = [];\n    const rest = [];\n    lines.forEach(line => {\n        if (line.startsWith('#')) {\n            header.push(line);\n        }\n        else if (line) {\n            rest.push(line);\n        }\n    });\n    return { header: header.join('\\n'), lines: rest };\n};\nfunction isGzip(buf) {\n    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;\n}\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n    async getHeader() {\n        const { header } = await this.setup();\n        return header;\n    }\n    async getMetadata() {\n        const { header } = await this.setup();\n        const parser = new VCF({ header: header });\n        return parser.getMetadata();\n    }\n    // converts lines into an interval tree\n    async setupP() {\n        const buffer = await openLocation(readConfObject(this.config, 'vcfLocation'), this.pluginManager).readFile();\n        const buf = isGzip(buffer) ? await unzip(buffer) : buffer;\n        // 512MB  max chrome string length is 512MB\n        if (buf.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const str = new TextDecoder().decode(buf);\n        const { header, lines } = readVcf(str);\n        const intervalTree = lines\n            .map((line, id) => {\n            var _a;\n            const [refName, startP, , ref, , , , info] = line.split('\\t');\n            const start = +startP - 1;\n            const end = +(((_a = info.match(/END=(\\d+)/)) === null || _a === void 0 ? void 0 : _a[1].trim()) || start + ref.length);\n            return { line, refName, start, end, id };\n        })\n            .reduce((acc, obj) => {\n            const key = obj.refName;\n            if (!acc[key]) {\n                acc[key] = new IntervalTree();\n            }\n            acc[key].insert([obj.start, obj.end], obj);\n            return acc;\n        }, {});\n        return { header, intervalTree };\n    }\n    async setup() {\n        if (!this.vcfFeatures) {\n            this.vcfFeatures = this.setupP().catch(e => {\n                this.vcfFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.vcfFeatures;\n    }\n    async getRefNames(_ = {}) {\n        const { intervalTree } = await this.setup();\n        return Object.keys(intervalTree);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = region;\n                const { header, intervalTree } = await this.setup();\n                const parser = new VCF({ header: header });\n                (_a = intervalTree[refName]) === null || _a === void 0 ? void 0 : _a.search([start, end]).forEach(f => observer.next(new VcfFeature({\n                    variant: parser.parseLine(f.line),\n                    parser,\n                    id: `${this.id}-${f.id}`,\n                })));\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.signal);\n    }\n    freeResources() { }\n}\nVcfAdapter.capabilities = ['getFeatures', 'getRefNames'];\n//# sourceMappingURL=VcfAdapter.js.map","/* (ignored) */","/* (ignored) */"],"names":[],"sourceRoot":""}