{"version":3,"file":"node_modules_jbrowse_plugin-gff3_esm_Gff3TabixAdapter_Gff3TabixAdapter_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACkF;AACxB;AACL;AACM;AACE;AACd;AACnB;AACkC;AAC9D,+DAAe,cAAc,2FAAsB;AACnD;AACA;AACA,8BAA8B,2EAAc;AAC5C,0BAA0B,2EAAc;AACxC,yBAAyB,2EAAc;AACvC,+BAA+B,2EAAc;AAC7C;AACA,uBAAuB,yDAAgB;AACvC,wBAAwB,mEAAY;AACpC;AACA,kBAAkB,mEAAY;AAC9B;AACA;AACA,kBAAkB,mEAAY;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,eAAe,yEAAgB;AAC/B;AACA;AACA,SAAS;AACT;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY,oBAAoB;AAClF;AACA;AACA;AACA,wDAAwD,oBAAoB;AAC5E;AACA;AACA,aAAa;AACb;AACA,6BAA6B,iEAAmB;AAChD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB,wEAAc;AAClC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wEAAa;AAC9D;AACA;AACA,mBAAmB,QAAQ,UAAU,mCAAmC;AACxE,SAAS;AACT;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,CAAC;AACD;;;;;;;;;;ACzLA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA","sources":["webpack://taxonium/./node_modules/@jbrowse/plugin-gff3/esm/Gff3TabixAdapter/Gff3TabixAdapter.js","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|./localFile","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|file-uri-to-path","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/readable-stream/lib/internal/streams|util","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/readable-stream/lib|util"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { doesIntersect2 } from '@jbrowse/core/util/range';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { TabixIndexedFile } from '@gmod/tabix';\nimport gff from '@gmod/gff';\nimport { readConfObject, } from '@jbrowse/core/configuration';\nexport default class extends BaseFeatureDataAdapter {\n    constructor(config, getSubAdapter, pluginManager) {\n        super(config, getSubAdapter, pluginManager);\n        const gffGzLocation = readConfObject(config, 'gffGzLocation');\n        const indexType = readConfObject(config, ['index', 'indexType']);\n        const location = readConfObject(config, ['index', 'location']);\n        const dontRedispatch = readConfObject(config, 'dontRedispatch');\n        this.dontRedispatch = dontRedispatch || ['chromosome', 'contig', 'region'];\n        this.gff = new TabixIndexedFile({\n            filehandle: openLocation(gffGzLocation, this.pluginManager),\n            csiFilehandle: indexType === 'CSI'\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            tbiFilehandle: indexType !== 'CSI'\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n            renameRefSeqs: (n) => n,\n        });\n    }\n    async getRefNames(opts = {}) {\n        return this.gff.getReferenceSequenceNames(opts);\n    }\n    async getHeader() {\n        return this.gff.getHeader();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const metadata = await this.gff.getMetadata();\n            this.getFeaturesHelper(query, opts, metadata, observer, true);\n        }, opts.signal);\n    }\n    async getFeaturesHelper(query, opts = {}, metadata, observer, allowRedispatch, originalQuery = query) {\n        try {\n            const lines = [];\n            await this.gff.getLines(query.refName, query.start, query.end, (line, fileOffset) => {\n                lines.push(this.parseLine(metadata.columnNumbers, line, fileOffset));\n            });\n            if (allowRedispatch && lines.length) {\n                let minStart = Infinity;\n                let maxEnd = -Infinity;\n                lines.forEach(line => {\n                    const featureType = line.fields[2];\n                    // only expand redispatch range if feature is not a \"dontRedispatch\" type\n                    // skips large regions like chromosome,region\n                    if (!this.dontRedispatch.includes(featureType)) {\n                        const start = line.start - 1; // gff is 1-based\n                        if (start < minStart) {\n                            minStart = start;\n                        }\n                        if (line.end > maxEnd) {\n                            maxEnd = line.end;\n                        }\n                    }\n                });\n                if (maxEnd > query.end || minStart < query.start) {\n                    // make a new feature callback to only return top-level features\n                    // in the original query range\n                    this.getFeaturesHelper({ ...query, start: minStart, end: maxEnd }, opts, metadata, observer, false, query);\n                    return;\n                }\n            }\n            const gff3 = lines\n                .map((lineRecord) => {\n                if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n                    if (!lineRecord.fields[8].includes('_lineHash')) {\n                        lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`;\n                    }\n                }\n                else {\n                    lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`;\n                }\n                return lineRecord.fields.join('\\t');\n            })\n                .join('\\n');\n            const features = gff.parseStringSync(gff3, {\n                parseFeatures: true,\n                parseComments: false,\n                parseDirectives: false,\n                parseSequences: false,\n            });\n            features.forEach(featureLocs => this.formatFeatures(featureLocs).forEach(f => {\n                if (doesIntersect2(f.get('start'), f.get('end'), originalQuery.start, originalQuery.end)) {\n                    observer.next(f);\n                }\n            }));\n            observer.complete();\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n    parseLine(columnNumbers, line, fileOffset) {\n        const fields = line.split('\\t');\n        // note: index column numbers are 1-based\n        return {\n            start: +fields[columnNumbers.start - 1],\n            end: +fields[columnNumbers.end - 1],\n            lineHash: fileOffset,\n            fields,\n        };\n    }\n    formatFeatures(featureLocs) {\n        return featureLocs.map(featureLoc => new SimpleFeature({\n            data: this.featureData(featureLoc),\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            id: `${this.id}-offset-${featureLoc.attributes._lineHash[0]}`,\n        }));\n    }\n    featureData(data) {\n        const f = { ...data };\n        f.start -= 1; // convert to interbase\n        if (data.strand === '+') {\n            f.strand = 1;\n        }\n        else if (data.strand === '-') {\n            f.strand = -1;\n        }\n        else if (data.strand === '.') {\n            f.strand = 0;\n        }\n        else {\n            f.strand = undefined;\n        }\n        f.phase = Number(data.phase);\n        f.refName = data.seq_id;\n        if (data.score === null) {\n            delete f.score;\n        }\n        if (data.phase === null) {\n            delete f.score;\n        }\n        const defaultFields = [\n            'start',\n            'end',\n            'seq_id',\n            'score',\n            'type',\n            'source',\n            'phase',\n            'strand',\n        ];\n        const dataAttributes = data.attributes || {};\n        Object.keys(dataAttributes).forEach(a => {\n            let b = a.toLowerCase();\n            if (defaultFields.includes(b)) {\n                // add \"suffix\" to tag name if it already exists\n                // reproduces behavior of NCList\n                b += '2';\n            }\n            if (dataAttributes[a] !== null) {\n                let attr = dataAttributes[a];\n                if (Array.isArray(attr) && attr.length === 1) {\n                    ;\n                    [attr] = attr;\n                }\n                f[b] = attr;\n            }\n        });\n        f.refName = f.seq_id;\n        // the SimpleFeature constructor takes care of recursively inflating subfeatures\n        if (data.child_features && data.child_features.length) {\n            f.subfeatures = data.child_features\n                .map(childLocs => childLocs.map(childLoc => this.featureData(childLoc)))\n                .flat();\n        }\n        delete f.child_features;\n        delete f.data;\n        delete f.derived_features;\n        delete f._linehash;\n        delete f.attributes;\n        delete f.seq_id;\n        return f;\n    }\n    freeResources( /* { region } */) { }\n}\n//# sourceMappingURL=Gff3TabixAdapter.js.map","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */"],"names":[],"sourceRoot":""}