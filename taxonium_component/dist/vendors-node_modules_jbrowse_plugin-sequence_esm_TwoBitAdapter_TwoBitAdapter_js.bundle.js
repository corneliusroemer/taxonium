"use strict";
(self["webpackChunktaxonium"] = self["webpackChunktaxonium"] || []).push([["vendors-node_modules_jbrowse_plugin-sequence_esm_TwoBitAdapter_TwoBitAdapter_js"],{

/***/ "./node_modules/@gmod/twobit/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@gmod/twobit/esm/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TwoBitFile": function() { return /* reexport safe */ _twoBitFile__WEBPACK_IMPORTED_MODULE_0__["default"]; }
/* harmony export */ });
/* harmony import */ var _twoBitFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./twoBitFile */ "./node_modules/@gmod/twobit/esm/twoBitFile.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@gmod/twobit/esm/twoBitFile.js":
/*!*****************************************************!*\
  !*** ./node_modules/@gmod/twobit/esm/twoBitFile.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TwoBitFile; }
/* harmony export */ });
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var generic_filehandle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! generic-filehandle */ "./node_modules/generic-filehandle/esm/index.js");
/* harmony import */ var _gmod_binary_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @gmod/binary-parser */ "./node_modules/@gmod/binary-parser/dist/binary_parser.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];



const TWOBIT_MAGIC = 0x1a412743;
function tinyMemoize(_class, methodName) {
    const method = _class.prototype[methodName];
    const memoAttrName = `_memo_${methodName}`;
    _class.prototype[methodName] = function _tinyMemoized() {
        if (!(memoAttrName in this)) {
            this[memoAttrName] = method.call(this);
        }
        return this[memoAttrName];
    };
}
const twoBit = ['T', 'C', 'A', 'G'];
// byteTo4Bases is an array of byteValue -> 'ACTG'
// the weird `...keys()` incantation generates an array of numbers 0 to 255
const byteTo4Bases = [];
for (let i = 0; i < 256; i++) {
    byteTo4Bases.push(twoBit[(i >> 6) & 3] +
        twoBit[(i >> 4) & 3] +
        twoBit[(i >> 2) & 3] +
        twoBit[i & 3]);
}
const maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase());
class TwoBitFile {
    /**
     * @param {object} args
     * @param {string} [args.path] filesystem path for the .2bit file to open
     * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.
     *  Only needs to support `filehandle.read(buffer, offset, length, position)`
     */
    constructor({ filehandle, path, }) {
        if (filehandle) {
            this.filehandle = filehandle;
        }
        else if (path) {
            this.filehandle = new generic_filehandle__WEBPACK_IMPORTED_MODULE_1__.LocalFile(path);
        }
        else {
            throw new Error('must supply path or filehandle');
        }
        this.isBigEndian = undefined;
    }
    async _getParser(name) {
        const parser = (await this._getParsers())[name];
        if (!parser) {
            throw new Error(`parser ${name} not found`);
        }
        return parser;
    }
    async _detectEndianness() {
        const ret = await this.filehandle.read(Buffer.allocUnsafe(8), 0, 8, 0);
        const { buffer } = ret;
        if (buffer.readInt32LE(0) === TWOBIT_MAGIC) {
            this.isBigEndian = false;
            this.version = buffer.readInt32LE(4);
        }
        else if (buffer.readInt32BE(0) === TWOBIT_MAGIC) {
            this.isBigEndian = true;
            this.version = buffer.readInt32BE(4);
        }
        else {
            throw new Error('not a 2bit file');
        }
    }
    // memoize
    /**
     * @private
     * detects the file's endianness and instantiates our binary parsers accordingly
     */
    async _getParsers() {
        await this._detectEndianness();
        const endianess = this.isBigEndian ? 'big' : 'little';
        const lebe = this.isBigEndian ? 'be' : 'le';
        let indexEntryParser = new _gmod_binary_parser__WEBPACK_IMPORTED_MODULE_2__.Parser()
            .endianess(endianess)
            .uint8('nameLength')
            .string('name', { length: 'nameLength' });
        if (this.version === 1) {
            indexEntryParser = indexEntryParser.buffer('offsetBytes', {
                length: 8,
            });
        }
        else {
            indexEntryParser = indexEntryParser.uint32('offset');
        }
        /* istanbul ignore next */
        const header = new _gmod_binary_parser__WEBPACK_IMPORTED_MODULE_2__.Parser()
            .endianess(endianess)
            .int32('magic', {
            assert: (m) => m === 0x1a412743,
        })
            .int32('version', {
            /* istanbul ignore next */
            assert: (v) => v === 0 || v === 1,
        })
            .uint32('sequenceCount', {
            /* istanbul ignore next */
            assert: (v) => v >= 0,
        })
            .uint32('reserved');
        return {
            header,
            index: new _gmod_binary_parser__WEBPACK_IMPORTED_MODULE_2__.Parser()
                .endianess(endianess)
                .uint32('sequenceCount')
                .uint32('reserved')
                .array('index', {
                length: 'sequenceCount',
                type: indexEntryParser,
            }),
            record1: new _gmod_binary_parser__WEBPACK_IMPORTED_MODULE_2__.Parser()
                .endianess(endianess)
                .uint32('dnaSize')
                .uint32('nBlockCount'),
            record2: new _gmod_binary_parser__WEBPACK_IMPORTED_MODULE_2__.Parser()
                .endianess(endianess)
                .uint32('nBlockCount')
                .array('nBlockStarts', {
                length: 'nBlockCount',
                type: `uint32${lebe}`,
            })
                .array('nBlockSizes', {
                length: 'nBlockCount',
                type: `uint32${lebe}`,
            })
                .uint32('maskBlockCount'),
            record3: new _gmod_binary_parser__WEBPACK_IMPORTED_MODULE_2__.Parser()
                .endianess(endianess)
                .uint32('maskBlockCount')
                .array('maskBlockStarts', {
                length: 'maskBlockCount',
                type: `uint32${lebe}`,
            })
                .array('maskBlockSizes', {
                length: 'maskBlockCount',
                type: `uint32${lebe}`,
            })
                .int32('reserved'),
            // .buffer('packedDna', { length: 'dnaSize' }),
        };
    }
    // memoize
    /**
     * @returns {Promise} for object with the file's header information, like
     *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`
     */
    async getHeader() {
        await this._detectEndianness();
        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(16), 0, 16, 0);
        const headerParser = await this._getParser('header');
        return headerParser.parse(buffer).result;
    }
    // memoize
    /**
     * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`
     */
    async getIndex() {
        const header = await this.getHeader();
        const maxIndexLength = 8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));
        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(maxIndexLength), 0, maxIndexLength, 8);
        const indexParser = await this._getParser('index');
        const indexData = indexParser.parse(buffer).result.index;
        const index = {};
        if (this.version === 1) {
            indexData.forEach(({ name, offsetBytes }) => {
                const long = long__WEBPACK_IMPORTED_MODULE_0___default().fromBytes(offsetBytes, true, !this.isBigEndian);
                if (long.greaterThan(Number.MAX_SAFE_INTEGER)) {
                    throw new Error('integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.');
                }
                index[name] = long.toNumber();
            });
        }
        else {
            indexData.forEach(({ name, offset }) => {
                index[name] = offset;
            });
        }
        return index;
    }
    /**
     * @returns {Promise} for an array of string sequence names that are found in the file
     */
    async getSequenceNames() {
        const index = await this.getIndex();
        return Object.keys(index);
    }
    /**
     * @returns {Promise} for an object listing the lengths of all sequences like `{seqName: length, ...}`
     */
    async getSequenceSizes() {
        const index = await this.getIndex();
        const seqNames = Object.keys(index);
        const sizePromises = Object.values(index).map(offset => this._getSequenceSize(offset));
        const sizes = await Promise.all(sizePromises);
        const returnObject = {};
        for (let i = 0; i < seqNames.length; i += 1) {
            returnObject[seqNames[i]] = sizes[i];
        }
        return returnObject;
    }
    /**
     * @param {string} seqName name of the sequence
     * @returns {Promise} for the sequence's length, or undefined if it is not in the file
     */
    async getSequenceSize(seqName) {
        const index = await this.getIndex();
        const offset = index[seqName];
        if (!offset) {
            return undefined;
        }
        return this._getSequenceSize(offset);
    }
    async _getSequenceSize(offset) {
        // we have to parse the sequence record in 3 parts, because we have to buffer 3 fixed-length file reads
        if (offset === undefined || offset < 0) {
            throw new Error('invalid offset');
        }
        const rec1 = await this._parseItem(offset, 8, 'record1');
        return rec1.dnaSize;
    }
    async _getSequenceRecord(offset) {
        // we have to parse the sequence record in 3 parts, because we have to buffer 3 fixed-length file reads
        if (offset === undefined || offset < 0) {
            throw new Error('invalid offset');
        }
        const rec1 = await this._parseItem(offset, 8, 'record1');
        const rec2DataLength = rec1.nBlockCount * 8 + 8;
        const rec2 = await this._parseItem(offset + 4, rec2DataLength, 'record2');
        const rec3DataLength = rec2.maskBlockCount * 8 + 8;
        const rec3 = await this._parseItem(offset + 4 + rec2DataLength - 4, rec3DataLength, 'record3');
        const rec = {
            dnaSize: rec1.dnaSize,
            nBlocks: { starts: rec2.nBlockStarts, sizes: rec2.nBlockSizes },
            maskBlocks: { starts: rec3.maskBlockStarts, sizes: rec3.maskBlockSizes },
            dnaPosition: offset + 4 + rec2DataLength - 4 + rec3DataLength,
        };
        return rec;
    }
    async _parseItem(offset, length, parserName) {
        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(length), 0, length, offset);
        const parser = await this._getParser(parserName);
        return parser.parse(buffer).result;
    }
    /**
     * @param {string} seqName name of the sequence you want
     * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.
     * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence
     * @returns {Promise} for a string of sequence bases
     */
    async getSequence(seqName, regionStart = 0, regionEnd) {
        const index = await this.getIndex();
        const offset = index[seqName];
        if (!offset) {
            return undefined;
        }
        // fetch the record for the seq
        const record = await this._getSequenceRecord(offset);
        if (regionStart < 0) {
            throw new TypeError('regionStart cannot be less than 0');
        }
        // end defaults to the end of the sequence
        if (regionEnd === undefined || regionEnd > record.dnaSize) {
            regionEnd = record.dnaSize;
        }
        const nBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.nBlocks.starts, record.nBlocks.sizes);
        const maskBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.maskBlocks.starts, record.maskBlocks.sizes);
        const baseBytes = Buffer.allocUnsafe(Math.ceil((regionEnd - regionStart) / 4) + 1);
        const baseBytesOffset = Math.floor(regionStart / 4);
        const { buffer } = await this.filehandle.read(baseBytes, 0, baseBytes.length, record.dnaPosition + baseBytesOffset);
        let sequenceBases = '';
        for (let genomicPosition = regionStart; genomicPosition < regionEnd; genomicPosition += 1) {
            // check whether we are currently masked
            while (maskBlocks.length && maskBlocks[0].end <= genomicPosition) {
                maskBlocks.shift();
            }
            const baseIsMasked = maskBlocks[0] &&
                maskBlocks[0].start <= genomicPosition &&
                maskBlocks[0].end > genomicPosition;
            // process the N block if we have one
            if (nBlocks[0] &&
                genomicPosition >= nBlocks[0].start &&
                genomicPosition < nBlocks[0].end) {
                const currentNBlock = nBlocks.shift();
                for (; genomicPosition < currentNBlock.end && genomicPosition < regionEnd; genomicPosition += 1) {
                    sequenceBases += baseIsMasked ? 'n' : 'N';
                }
                genomicPosition -= 1;
            }
            else {
                const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;
                const subPosition = genomicPosition % 4;
                const byte = buffer[bytePosition];
                sequenceBases += baseIsMasked
                    ? maskedByteTo4Bases[byte][subPosition]
                    : byteTo4Bases[byte][subPosition];
            }
        }
        return sequenceBases;
    }
    _getOverlappingBlocks(regionStart, regionEnd, blockStarts, blockSizes) {
        // find the start and end indexes of the blocks that match
        let startIndex;
        let endIndex;
        for (let i = 0; i < blockStarts.length; i += 1) {
            const blockStart = blockStarts[i];
            const blockSize = blockSizes[i];
            if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {
                // block does not overlap the region
                if (startIndex !== undefined) {
                    endIndex = i;
                    break;
                }
            }
            else if (startIndex === undefined) {
                startIndex = i;
            } // block does overlap the region, record this if it is the first
        }
        if (startIndex === undefined) {
            return [];
        }
        // now format some block objects to return
        if (endIndex === undefined) {
            endIndex = blockStarts.length;
        }
        const blocks = new Array(endIndex - startIndex);
        for (let blockNum = startIndex; blockNum < endIndex; blockNum += 1) {
            blocks[blockNum - startIndex] = {
                start: blockStarts[blockNum],
                end: blockStarts[blockNum] + blockSizes[blockNum],
                size: blockSizes[blockNum],
            };
        }
        return blocks;
    }
}
tinyMemoize(TwoBitFile, '_getParsers');
tinyMemoize(TwoBitFile, 'getIndex');
tinyMemoize(TwoBitFile, 'getHeader');
//# sourceMappingURL=twoBitFile.js.map

/***/ }),

/***/ "./node_modules/@jbrowse/plugin-sequence/esm/TwoBitAdapter/TwoBitAdapter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-sequence/esm/TwoBitAdapter/TwoBitAdapter.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TwoBitAdapter; }
/* harmony export */ });
/* harmony import */ var _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jbrowse/core/data_adapters/BaseAdapter */ "./node_modules/@jbrowse/core/data_adapters/BaseAdapter.js");
/* harmony import */ var _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jbrowse/core/util/io */ "./node_modules/@jbrowse/core/util/io/index.js");
/* harmony import */ var _jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jbrowse_core_util_rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jbrowse/core/util/rxjs */ "./node_modules/@jbrowse/core/util/rxjs.js");
/* harmony import */ var _jbrowse_core_util_simpleFeature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jbrowse/core/util/simpleFeature */ "./node_modules/@jbrowse/core/util/simpleFeature.js");
/* harmony import */ var _gmod_twobit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @gmod/twobit */ "./node_modules/@gmod/twobit/esm/index.js");
/* harmony import */ var _jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jbrowse/core/configuration */ "./node_modules/@jbrowse/core/configuration/index.js");
/* harmony import */ var _jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__);






class TwoBitAdapter extends _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_0__.BaseSequenceAdapter {
    constructor(config, getSubAdapter, pluginManager) {
        super(config, getSubAdapter, pluginManager);
        this.chromSizesData = this.initChromSizes();
        this.twobit = new _gmod_twobit__WEBPACK_IMPORTED_MODULE_4__.TwoBitFile({
            filehandle: (0,_jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_1__.openLocation)((0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(config, 'twoBitLocation'), this.pluginManager),
        });
    }
    async initChromSizes() {
        const conf = (0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(this.config, 'chromSizesLocation');
        // check against default and empty in case someone makes the field blank in
        // config editor, may want better way to check "optional config slots" in
        // future
        if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {
            const file = (0,_jbrowse_core_util_io__WEBPACK_IMPORTED_MODULE_1__.openLocation)(conf, this.pluginManager);
            const data = await file.readFile('utf8');
            return Object.fromEntries(data === null || data === void 0 ? void 0 : data.split('\n').filter(line => !!line.trim()).map(line => {
                const [name, length] = line.split('\t');
                return [name, +length];
            }));
        }
        return undefined;
    }
    async getRefNames() {
        const chromSizesData = await this.chromSizesData;
        if (chromSizesData) {
            return Object.keys(chromSizesData);
        }
        return this.twobit.getSequenceNames();
    }
    async getRegions() {
        const chromSizesData = await this.chromSizesData;
        if (chromSizesData) {
            return Object.keys(chromSizesData).map(refName => ({
                refName,
                start: 0,
                end: chromSizesData[refName],
            }));
        }
        const refSizes = await this.twobit.getSequenceSizes();
        return Object.keys(refSizes).map(refName => ({
            refName,
            start: 0,
            end: refSizes[refName],
        }));
    }
    /**
     * Fetch features for a certain region
     * @param param -
     * @returns Observable of Feature objects in the region
     */
    getFeatures({ refName, start, end }) {
        return (0,_jbrowse_core_util_rxjs__WEBPACK_IMPORTED_MODULE_2__.ObservableCreate)(async (observer) => {
            const size = await this.twobit.getSequenceSize(refName);
            const regionEnd = size !== undefined ? Math.min(size, end) : end;
            const seq = await this.twobit.getSequence(refName, start, regionEnd);
            if (seq) {
                observer.next(new _jbrowse_core_util_simpleFeature__WEBPACK_IMPORTED_MODULE_3__["default"]({
                    id: `${refName} ${start}-${regionEnd}`,
                    data: { refName, start, end: regionEnd, seq },
                }));
            }
            observer.complete();
        });
    }
    /**
     * called to provide a hint that data tied to a certain region
     * will not be needed for the forseeable future and can be purged
     * from caches, etc
     */
    freeResources( /* { region } */) { }
}
//# sourceMappingURL=TwoBitAdapter.js.map

/***/ }),

/***/ "./node_modules/generic-filehandle/esm/blobFile.js":
/*!*********************************************************!*\
  !*** ./node_modules/generic-filehandle/esm/blobFile.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BlobFile; }
/* harmony export */ });
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

// Using this you can "await" the file like a normal promise
// https://blog.shovonhasan.com/using-promises-with-filereader/
function readBlobAsArrayBuffer(blob) {
    const fileReader = new FileReader();
    return new Promise((resolve, reject) => {
        fileReader.onerror = () => {
            fileReader.abort();
            reject(new Error('problem reading blob'));
        };
        fileReader.onabort = () => {
            reject(new Error('blob reading was aborted'));
        };
        fileReader.onload = () => {
            if (fileReader.result && typeof fileReader.result !== 'string') {
                resolve(fileReader.result);
            }
            else {
                reject(new Error('unknown error reading blob'));
            }
        };
        fileReader.readAsArrayBuffer(blob);
    });
}
function readBlobAsText(blob) {
    const fileReader = new FileReader();
    return new Promise((resolve, reject) => {
        fileReader.onerror = () => {
            fileReader.abort();
            reject(new Error('problem reading blob'));
        };
        fileReader.onabort = () => {
            reject(new Error('blob reading was aborted'));
        };
        fileReader.onload = () => {
            if (fileReader.result && typeof fileReader.result === 'string') {
                resolve(fileReader.result);
            }
            else {
                reject(new Error('unknown error reading blob'));
            }
        };
        fileReader.readAsText(blob);
    });
}
/**
 * Blob of binary data fetched from a local file (with FileReader).
 *
 * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in
 * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.
 */
class BlobFile {
    constructor(blob) {
        this.blob = blob;
        this.size = blob.size;
    }
    async read(buffer, offset = 0, length, position = 0) {
        // short-circuit a read of 0 bytes here, because browsers actually sometimes
        // crash if you try to read 0 bytes from a local file!
        if (!length) {
            return { bytesRead: 0, buffer };
        }
        const start = position;
        const end = start + length;
        const result = await readBlobAsArrayBuffer(this.blob.slice(start, end));
        const resultBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(result);
        const bytesCopied = resultBuffer.copy(buffer, offset);
        return { bytesRead: bytesCopied, buffer: resultBuffer };
    }
    async readFile(options) {
        let encoding;
        if (typeof options === 'string') {
            encoding = options;
        }
        else {
            encoding = options && options.encoding;
        }
        if (encoding === 'utf8') {
            return readBlobAsText(this.blob);
        }
        if (encoding) {
            throw new Error(`unsupported encoding: ${encoding}`);
        }
        const result = await readBlobAsArrayBuffer(this.blob);
        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(result);
    }
    async stat() {
        return { size: this.size };
    }
    async close() {
        return;
    }
}


/***/ }),

/***/ "./node_modules/generic-filehandle/esm/filehandle.js":
/*!***********************************************************!*\
  !*** ./node_modules/generic-filehandle/esm/filehandle.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./node_modules/generic-filehandle/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/generic-filehandle/esm/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobFile": function() { return /* reexport safe */ _blobFile__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "LocalFile": function() { return /* reexport default from dynamic */ _localFile__WEBPACK_IMPORTED_MODULE_0___default.a; },
/* harmony export */   "RemoteFile": function() { return /* reexport safe */ _remoteFile__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "fromUrl": function() { return /* binding */ fromUrl; },
/* harmony export */   "open": function() { return /* binding */ open; }
/* harmony export */ });
/* harmony import */ var _localFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./localFile */ "?3899");
/* harmony import */ var _localFile__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_localFile__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _remoteFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./remoteFile */ "./node_modules/generic-filehandle/esm/remoteFile.js");
/* harmony import */ var _blobFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blobFile */ "./node_modules/generic-filehandle/esm/blobFile.js");
/* harmony import */ var _filehandle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filehandle */ "./node_modules/generic-filehandle/esm/filehandle.js");




function fromUrl(source, opts = {}) {
    return new _remoteFile__WEBPACK_IMPORTED_MODULE_1__["default"](source, opts);
}
function open(maybeUrl, maybePath, maybeFilehandle, opts = {}) {
    if (maybeFilehandle !== undefined) {
        return maybeFilehandle;
    }
    if (maybeUrl !== undefined) {
        return fromUrl(maybeUrl, opts);
    }
    if (maybePath !== undefined) {
        return new (_localFile__WEBPACK_IMPORTED_MODULE_0___default())(maybePath, opts);
    }
    throw new Error('no url, path, or filehandle provided, cannot open');
}



/***/ }),

/***/ "./node_modules/generic-filehandle/esm/remoteFile.js":
/*!***********************************************************!*\
  !*** ./node_modules/generic-filehandle/esm/remoteFile.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RemoteFile; }
/* harmony export */ });
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
/* harmony import */ var file_uri_to_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-uri-to-path */ "?9a27");
/* harmony import */ var file_uri_to_path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(file_uri_to_path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! . */ "./node_modules/generic-filehandle/esm/index.js");



const myGlobal = typeof window !== 'undefined'
    ? window
    : typeof self !== 'undefined'
        ? self
        : { fetch: undefined };
class RemoteFile {
    constructor(source, opts = {}) {
        this.baseOverrides = {};
        this.url = source;
        // if it is a file URL, monkey-patch ourselves to act like a LocalFile
        if (source.startsWith('file://')) {
            const path = file_uri_to_path__WEBPACK_IMPORTED_MODULE_1___default()(source);
            if (!path) {
                throw new TypeError('invalid file url');
            }
            const localFile = new ___WEBPACK_IMPORTED_MODULE_2__.LocalFile(path);
            this.read = localFile.read.bind(localFile);
            this.readFile = localFile.readFile.bind(localFile);
            this.stat = localFile.stat.bind(localFile);
            // @ts-ignore
            this.fetchImplementation = () => {
                /* intentionally blank */
            };
            return;
        }
        const fetch = opts.fetch || (myGlobal.fetch && myGlobal.fetch.bind(myGlobal));
        if (!fetch) {
            throw new TypeError(`no fetch function supplied, and none found in global environment`);
        }
        if (opts.overrides) {
            this.baseOverrides = opts.overrides;
        }
        this.fetchImplementation = fetch;
    }
    async getBufferFromResponse(response) {
        if (typeof response.buffer === 'function') {
            return response.buffer();
        }
        else if (typeof response.arrayBuffer === 'function') {
            const resp = await response.arrayBuffer();
            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(resp);
        }
        else {
            throw new TypeError('invalid HTTP response object, has no buffer method, and no arrayBuffer method');
        }
    }
    async fetch(input, init) {
        let response;
        try {
            response = await this.fetchImplementation(input, init);
        }
        catch (e) {
            if (`${e}`.includes('Failed to fetch')) {
                // refetch to to help work around a chrome bug (discussed in
                // generic-filehandle issue #72) in which the chrome cache returns a
                // CORS error for content in its cache.  see also
                // https://github.com/GMOD/jbrowse-components/pull/1511
                console.warn(`generic-filehandle: refetching ${input} to attempt to work around chrome CORS header caching bug`);
                response = await this.fetchImplementation(input, {
                    ...init,
                    cache: 'reload',
                });
            }
            else {
                throw e;
            }
        }
        return response;
    }
    async read(buffer, offset = 0, length, position = 0, opts = {}) {
        const { headers = {}, signal, overrides = {} } = opts;
        if (length < Infinity) {
            headers.range = `bytes=${position}-${position + length}`;
        }
        else if (length === Infinity && position !== 0) {
            headers.range = `bytes=${position}-`;
        }
        const args = {
            ...this.baseOverrides,
            ...overrides,
            headers: {
                ...headers,
                ...overrides.headers,
                ...this.baseOverrides.headers,
            },
            method: 'GET',
            redirect: 'follow',
            mode: 'cors',
            signal,
        };
        const response = await this.fetch(this.url, args);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status} ${response.statusText} ${this.url}`);
        }
        if ((response.status === 200 && position === 0) ||
            response.status === 206) {
            const responseData = await this.getBufferFromResponse(response);
            const bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length));
            // try to parse out the size of the remote file
            const res = response.headers.get('content-range');
            const sizeMatch = /\/(\d+)$/.exec(res || '');
            if (sizeMatch && sizeMatch[1]) {
                this._stat = { size: parseInt(sizeMatch[1], 10) };
            }
            return { bytesRead: bytesCopied, buffer };
        }
        if (response.status === 200) {
            throw new Error('${this.url} fetch returned status 200, expected 206');
        }
        // TODO: try harder here to gather more information about what the problem is
        throw new Error(`HTTP ${response.status} fetching ${this.url}`);
    }
    async readFile(options = {}) {
        let encoding;
        let opts;
        if (typeof options === 'string') {
            encoding = options;
            opts = {};
        }
        else {
            encoding = options.encoding;
            opts = options;
            delete opts.encoding;
        }
        const { headers = {}, signal, overrides = {} } = opts;
        const args = {
            headers,
            method: 'GET',
            redirect: 'follow',
            mode: 'cors',
            signal,
            ...this.baseOverrides,
            ...overrides,
        };
        const response = await this.fetch(this.url, args);
        if (!response) {
            throw new Error('generic-filehandle failed to fetch');
        }
        if (response.status !== 200) {
            throw Object.assign(new Error(`HTTP ${response.status} fetching ${this.url}`), {
                status: response.status,
            });
        }
        if (encoding === 'utf8') {
            return response.text();
        }
        if (encoding) {
            throw new Error(`unsupported encoding: ${encoding}`);
        }
        return this.getBufferFromResponse(response);
    }
    async stat() {
        if (!this._stat) {
            const buf = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.allocUnsafe(10);
            await this.read(buf, 0, 10, 0);
            if (!this._stat) {
                throw new Error(`unable to determine size of file at ${this.url}`);
            }
        }
        return this._stat;
    }
    async close() {
        return;
    }
}


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jbrowse_plugin-sequence_esm_TwoBitAdapter_TwoBitAdapter_js.bundle.js.map