"use strict";
(self["webpackChunktaxonium"] = self["webpackChunktaxonium"] || []).push([["vendors-node_modules_gmod_gff_esm_index_js"],{

/***/ "./node_modules/@gmod/gff/esm/api.js":
/*!*******************************************!*\
  !*** ./node_modules/@gmod/gff/esm/api.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatFile": function() { return /* binding */ formatFile; },
/* harmony export */   "formatStream": function() { return /* binding */ formatStream; },
/* harmony export */   "formatSync": function() { return /* binding */ formatSync; },
/* harmony export */   "parseStream": function() { return /* binding */ parseStream; },
/* harmony export */   "parseStringSync": function() { return /* binding */ parseStringSync; }
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var string_decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse */ "./node_modules/@gmod/gff/esm/parse.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/gff/esm/util.js");
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");




// call a callback on the next process tick if running in
// an environment that supports it
function _callback(callback) {
    if (process && process.nextTick)
        process.nextTick(callback);
    else
        callback();
}
// shared arg processing for the parse routines
function _processParseOptions(options) {
    const out = {
        encoding: 'utf8',
        parseFeatures: true,
        parseDirectives: false,
        parseSequences: true,
        parseComments: false,
        bufferSize: 1000,
        ...options,
    };
    if (options.parseAll) {
        out.parseFeatures = true;
        out.parseDirectives = true;
        out.parseComments = true;
        out.parseSequences = true;
    }
    return out;
}
class GFFTransform extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {
    constructor(inputOptions = {}) {
        super({ objectMode: true });
        this.textBuffer = '';
        const options = _processParseOptions(inputOptions);
        this.encoding = inputOptions.encoding || 'utf8';
        this.decoder = new string_decoder__WEBPACK_IMPORTED_MODULE_1__.StringDecoder();
        const push = this.push.bind(this);
        this.parser = new _parse__WEBPACK_IMPORTED_MODULE_2__["default"]({
            featureCallback: options.parseFeatures ? push : undefined,
            directiveCallback: options.parseDirectives ? push : undefined,
            commentCallback: options.parseComments ? push : undefined,
            sequenceCallback: options.parseSequences ? push : undefined,
            errorCallback: (err) => this.emit('error', err),
            bufferSize: options.bufferSize,
        });
    }
    _addLine(data) {
        if (data) {
            this.parser.addLine(data);
        }
    }
    _nextText(buffer) {
        const pieces = (this.textBuffer + buffer).split(/\r?\n/);
        this.textBuffer = pieces.pop() || '';
        pieces.forEach((piece) => this._addLine(piece));
    }
    _transform(chunk, _encoding, callback) {
        this._nextText(this.decoder.write(chunk));
        _callback(callback);
    }
    _flush(callback) {
        if (this.decoder.end)
            this._nextText(this.decoder.end());
        if (this.textBuffer != null)
            this._addLine(this.textBuffer);
        this.parser.finish();
        _callback(callback);
    }
}
/**
 * Parse a stream of text data into a stream of feature, directive, comment,
 * an sequence objects.
 *
 * @param options - Parsing options
 * @returns stream (in objectMode) of parsed items
 */
function parseStream(options = {}) {
    return new GFFTransform(options);
}
function parseStringSync(str, inputOptions = {}) {
    if (!str)
        return [];
    const options = _processParseOptions(inputOptions);
    const items = [];
    const push = items.push.bind(items);
    const parser = new _parse__WEBPACK_IMPORTED_MODULE_2__["default"]({
        featureCallback: options.parseFeatures ? push : undefined,
        directiveCallback: options.parseDirectives ? push : undefined,
        commentCallback: options.parseComments ? push : undefined,
        sequenceCallback: options.parseSequences ? push : undefined,
        bufferSize: Infinity,
        errorCallback: (err) => {
            throw err;
        },
    });
    str.split(/\r?\n/).forEach(parser.addLine.bind(parser));
    parser.finish();
    return items;
}
/**
 * Format an array of GFF3 items (features,directives,comments) into string of
 * GFF3. Does not insert synchronization (###) marks.
 *
 * @param items - Array of features, directives, comments and/or sequences
 * @returns the formatted GFF3
 */
function formatSync(items) {
    // sort items into seq and other
    const other = [];
    const sequences = [];
    items.forEach((i) => {
        if ('sequence' in i)
            sequences.push(i);
        else
            other.push(i);
    });
    let str = other.map(_util__WEBPACK_IMPORTED_MODULE_3__.formatItem).join('');
    if (sequences.length) {
        str += '##FASTA\n';
        str += sequences.map(_util__WEBPACK_IMPORTED_MODULE_3__.formatSequence).join('');
    }
    return str;
}
class FormattingTransform extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {
    constructor(options = {}) {
        super(Object.assign(options, { objectMode: true }));
        this.linesSinceLastSyncMark = 0;
        this.haveWeEmittedData = false;
        this.fastaMode = false;
        this.minLinesBetweenSyncMarks = options.minSyncLines || 100;
        this.insertVersionDirective = options.insertVersionDirective || false;
    }
    _transform(chunk, _encoding, callback) {
        // if we have not emitted anything yet, and this first
        // chunk is not a gff-version directive, emit one
        let str;
        if (!this.haveWeEmittedData && this.insertVersionDirective) {
            const thisChunk = Array.isArray(chunk) ? chunk[0] : chunk;
            if ('directive' in thisChunk) {
                if (thisChunk.directive !== 'gff-version') {
                    this.push('##gff-version 3\n');
                }
            }
        }
        // if it's a sequence chunk coming down, emit a FASTA directive and
        // change to FASTA mode
        if ('sequence' in chunk && !this.fastaMode) {
            this.push('##FASTA\n');
            this.fastaMode = true;
        }
        if (Array.isArray(chunk))
            str = chunk.map(_util__WEBPACK_IMPORTED_MODULE_3__.formatItem).join('');
        else
            str = (0,_util__WEBPACK_IMPORTED_MODULE_3__.formatItem)(chunk);
        this.push(str);
        if (this.linesSinceLastSyncMark >= this.minLinesBetweenSyncMarks) {
            this.push('###\n');
            this.linesSinceLastSyncMark = 0;
        }
        else {
            // count the number of newlines in this chunk
            let count = 0;
            for (let i = 0; i < str.length; i += 1) {
                if (str[i] === '\n')
                    count += 1;
            }
            this.linesSinceLastSyncMark += count;
        }
        this.haveWeEmittedData = true;
        _callback(callback);
    }
}
/**
 * Format a stream of features, directives, comments and/or sequences into a
 * stream of GFF3 text.
 *
 * Inserts synchronization (###) marks automatically.
 *
 * @param options - parser options
 */
function formatStream(options = {}) {
    return new FormattingTransform(options);
}
/**
 * Format a stream of features, directives, comments and/or sequences into a
 * GFF3 file and write it to the filesystem.

 * Inserts synchronization (###) marks and a ##gff-version
 * directive automatically (if one is not already present).
 *
 * @param stream - the stream to write to the file
 * @param filename - the file path to write to
 * @param options - parser options
 * @returns promise for null that resolves when the stream has been written
 */
function formatFile(stream, writeStream, options = {}) {
    const newOptions = {
        insertVersionDirective: true,
        ...options,
    };
    return new Promise((resolve, reject) => {
        stream
            .pipe(new FormattingTransform(newOptions))
            .on('end', () => resolve(null))
            .on('error', reject)
            .pipe(writeStream);
    });
}
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@gmod/gff/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@gmod/gff/esm/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./node_modules/@gmod/gff/esm/api.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/gff/esm/util.js");


/* harmony default export */ __webpack_exports__["default"] = ({
    parseStream: _api__WEBPACK_IMPORTED_MODULE_0__.parseStream,
    parseStringSync: _api__WEBPACK_IMPORTED_MODULE_0__.parseStringSync,
    formatSync: _api__WEBPACK_IMPORTED_MODULE_0__.formatSync,
    formatStream: _api__WEBPACK_IMPORTED_MODULE_0__.formatStream,
    formatFile: _api__WEBPACK_IMPORTED_MODULE_0__.formatFile,
    util: _util__WEBPACK_IMPORTED_MODULE_1__,
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@gmod/gff/esm/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/@gmod/gff/esm/parse.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FASTAParser": function() { return /* binding */ FASTAParser; },
/* harmony export */   "default": function() { return /* binding */ Parser; }
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/gff/esm/util.js");

const containerAttributes = {
    Parent: 'child_features',
    Derives_from: 'derived_features',
};
class FASTAParser {
    constructor(seqCallback) {
        this.seqCallback = seqCallback;
        this.currentSequence = undefined;
    }
    addLine(line) {
        const defMatch = /^>\s*(\S+)\s*(.*)/.exec(line);
        if (defMatch) {
            this._flush();
            this.currentSequence = { id: defMatch[1], sequence: '' };
            if (defMatch[2])
                this.currentSequence.description = defMatch[2].trim();
        }
        else if (this.currentSequence && /\S/.test(line)) {
            this.currentSequence.sequence += line.replace(/\s/g, '');
        }
    }
    _flush() {
        if (this.currentSequence)
            this.seqCallback(this.currentSequence);
    }
    finish() {
        this._flush();
    }
}
class Parser {
    constructor(args) {
        this.fastaParser = undefined;
        // if this is true, the parser ignores the
        // rest of the lines in the file.  currently
        // set when the file switches over to FASTA
        this.eof = false;
        this.lineNumber = 0;
        // features that we have to keep on hand for now because they
        // might be referenced by something else
        this._underConstructionTopLevel = [];
        // index of the above by ID
        this._underConstructionById = {};
        this._completedReferences = {};
        // features that reference something we have not seen yet
        // structured as:
        // {  'some_id' : {
        //     'Parent' : [ orphans that have a Parent attr referencing it ],
        //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],
        //    }
        // }
        this._underConstructionOrphans = {};
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const nullFunc = () => { };
        this.featureCallback = args.featureCallback || nullFunc;
        this.endCallback = args.endCallback || nullFunc;
        this.commentCallback = args.commentCallback || nullFunc;
        this.errorCallback = args.errorCallback || nullFunc;
        this.directiveCallback = args.directiveCallback || nullFunc;
        this.sequenceCallback = args.sequenceCallback || nullFunc;
        // number of lines to buffer
        this.bufferSize = args.bufferSize === undefined ? 1000 : args.bufferSize;
    }
    addLine(line) {
        // if we have transitioned to a fasta section, just delegate to that parser
        if (this.fastaParser) {
            this.fastaParser.addLine(line);
            return;
        }
        if (this.eof) {
            // otherwise, if we are done, ignore this line
            return;
        }
        this.lineNumber += 1;
        if (/^\s*[^#\s>]/.test(line)) {
            // feature line, most common case
            this._bufferLine(line);
            return;
        }
        const match = /^\s*(#+)(.*)/.exec(line);
        if (match) {
            // directive or comment
            const [, hashsigns] = match;
            let [, , contents] = match;
            if (hashsigns.length === 3) {
                // sync directive, all forward-references are resolved.
                this._emitAllUnderConstructionFeatures();
            }
            else if (hashsigns.length === 2) {
                const directive = _util__WEBPACK_IMPORTED_MODULE_0__.parseDirective(line);
                if (directive) {
                    if (directive.directive === 'FASTA') {
                        this._emitAllUnderConstructionFeatures();
                        this.eof = true;
                        this.fastaParser = new FASTAParser(this.sequenceCallback);
                    }
                    else {
                        this._emitItem(directive);
                    }
                }
            }
            else {
                contents = contents.replace(/\s*/, '');
                this._emitItem({ comment: contents });
            }
        }
        else if (/^\s*$/.test(line)) {
            // blank line, do nothing
        }
        else if (/^\s*>/.test(line)) {
            // implicit beginning of a FASTA section
            this._emitAllUnderConstructionFeatures();
            this.eof = true;
            this.fastaParser = new FASTAParser(this.sequenceCallback);
            this.fastaParser.addLine(line);
        }
        else {
            // it's a parse error
            const errLine = line.replace(/\r?\n?$/g, '');
            throw new Error(`GFF3 parse error.  Cannot parse '${errLine}'.`);
        }
    }
    finish() {
        this._emitAllUnderConstructionFeatures();
        if (this.fastaParser)
            this.fastaParser.finish();
        this.endCallback();
    }
    _emitItem(i) {
        if (Array.isArray(i))
            this.featureCallback(i);
        else if ('directive' in i)
            this.directiveCallback(i);
        else if ('comment' in i)
            this.commentCallback(i);
    }
    _enforceBufferSizeLimit(additionalItemCount = 0) {
        const _unbufferItem = (item) => {
            if (item &&
                Array.isArray(item) &&
                item[0].attributes &&
                item[0].attributes.ID &&
                item[0].attributes.ID[0]) {
                const ids = item[0].attributes.ID;
                ids.forEach((id) => {
                    delete this._underConstructionById[id];
                    delete this._completedReferences[id];
                });
                item.forEach((i) => {
                    if (i.child_features)
                        i.child_features.forEach((c) => _unbufferItem(c));
                    if (i.derived_features)
                        i.derived_features.forEach((d) => _unbufferItem(d));
                });
            }
        };
        while (this._underConstructionTopLevel.length + additionalItemCount >
            this.bufferSize) {
            const item = this._underConstructionTopLevel.shift();
            if (item) {
                this._emitItem(item);
                _unbufferItem(item);
            }
        }
    }
    /**
     * return all under-construction features, called when we know
     * there will be no additional data to attach to them
     */
    _emitAllUnderConstructionFeatures() {
        this._underConstructionTopLevel.forEach(this._emitItem.bind(this));
        this._underConstructionTopLevel = [];
        this._underConstructionById = {};
        this._completedReferences = {};
        // if we have any orphans hanging around still, this is a
        // problem. die with a parse error
        if (Array.from(Object.values(this._underConstructionOrphans)).length) {
            throw new Error(`some features reference other features that do not exist in the file (or in the same '###' scope). ${JSON.stringify(this._underConstructionOrphans)}`);
        }
    }
    // do the right thing with a newly-parsed feature line
    _bufferLine(line) {
        var _a, _b, _c;
        const rawFeatureLine = _util__WEBPACK_IMPORTED_MODULE_0__.parseFeature(line);
        const featureLine = {
            ...rawFeatureLine,
            child_features: [],
            derived_features: [],
        };
        // featureLine._lineNumber = this.lineNumber //< debugging aid
        // NOTE: a feature is an arrayref of one or more feature lines.
        const ids = ((_a = featureLine.attributes) === null || _a === void 0 ? void 0 : _a.ID) || [];
        const parents = ((_b = featureLine.attributes) === null || _b === void 0 ? void 0 : _b.Parent) || [];
        const derives = ((_c = featureLine.attributes) === null || _c === void 0 ? void 0 : _c.Derives_from) || [];
        if (!ids.length && !parents.length && !derives.length) {
            // if it has no IDs and does not refer to anything, we can just
            // output it
            this._emitItem([featureLine]);
            return;
        }
        let feature = undefined;
        ids.forEach((id) => {
            const existing = this._underConstructionById[id];
            if (existing) {
                // another location of the same feature
                if (existing[existing.length - 1].type !== featureLine.type) {
                    this._parseError(`multi-line feature "${id}" has inconsistent types: "${featureLine.type}", "${existing[existing.length - 1].type}"`);
                }
                existing.push(featureLine);
                feature = existing;
            }
            else {
                // haven't seen it yet, so buffer it so we can attach
                // child features to it
                feature = [featureLine];
                this._enforceBufferSizeLimit(1);
                if (!parents.length && !derives.length) {
                    this._underConstructionTopLevel.push(feature);
                }
                this._underConstructionById[id] = feature;
                // see if we have anything buffered that refers to it
                this._resolveReferencesTo(feature, id);
            }
        });
        // try to resolve all its references
        this._resolveReferencesFrom(feature || [featureLine], { Parent: parents, Derives_from: derives }, ids);
    }
    _resolveReferencesTo(feature, id) {
        const references = this._underConstructionOrphans[id];
        //   references is of the form
        //   {
        //     'Parent' : [ orphans that have a Parent attr referencing this feature ],
        //     'Derives_from' : [ orphans that have a Derives_from attr referencing this feature ],
        //    }
        if (!references)
            return;
        feature.forEach((loc) => {
            loc.child_features.push(...references.Parent);
        });
        feature.forEach((loc) => {
            loc.derived_features.push(...references.Derives_from);
        });
        delete this._underConstructionOrphans[id];
    }
    _parseError(message) {
        this.eof = true;
        this.errorCallback(`${this.lineNumber}: ${message}`);
    }
    _resolveReferencesFrom(feature, references, ids) {
        // this is all a bit more awkward in javascript than it was in perl
        function postSet(obj, slot1, slot2) {
            let subObj = obj[slot1];
            if (!subObj) {
                subObj = {};
                obj[slot1] = subObj;
            }
            const returnVal = subObj[slot2] || false;
            subObj[slot2] = true;
            return returnVal;
        }
        references.Parent.forEach((toId) => {
            const otherFeature = this._underConstructionById[toId];
            if (otherFeature) {
                const pname = containerAttributes.Parent;
                if (!ids.filter((id) => postSet(this._completedReferences, id, `Parent,${toId}`)).length) {
                    otherFeature.forEach((location) => {
                        location[pname].push(feature);
                    });
                }
            }
            else {
                let ref = this._underConstructionOrphans[toId];
                if (!ref) {
                    ref = {
                        Parent: [],
                        Derives_from: [],
                    };
                    this._underConstructionOrphans[toId] = ref;
                }
                ref.Parent.push(feature);
            }
        });
        references.Derives_from.forEach((toId) => {
            const otherFeature = this._underConstructionById[toId];
            if (otherFeature) {
                const pname = containerAttributes.Derives_from;
                if (!ids.filter((id) => postSet(this._completedReferences, id, `Derives_from,${toId}`)).length) {
                    otherFeature.forEach((location) => {
                        location[pname].push(feature);
                    });
                }
            }
            else {
                let ref = this._underConstructionOrphans[toId];
                if (!ref) {
                    ref = {
                        Parent: [],
                        Derives_from: [],
                    };
                    this._underConstructionOrphans[toId] = ref;
                }
                ref.Derives_from.push(feature);
            }
        });
    }
}
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "./node_modules/@gmod/gff/esm/util.js":
/*!********************************************!*\
  !*** ./node_modules/@gmod/gff/esm/util.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "escape": function() { return /* binding */ escape; },
/* harmony export */   "escapeColumn": function() { return /* binding */ escapeColumn; },
/* harmony export */   "formatAttributes": function() { return /* binding */ formatAttributes; },
/* harmony export */   "formatComment": function() { return /* binding */ formatComment; },
/* harmony export */   "formatDirective": function() { return /* binding */ formatDirective; },
/* harmony export */   "formatFeature": function() { return /* binding */ formatFeature; },
/* harmony export */   "formatItem": function() { return /* binding */ formatItem; },
/* harmony export */   "formatSequence": function() { return /* binding */ formatSequence; },
/* harmony export */   "parseAttributes": function() { return /* binding */ parseAttributes; },
/* harmony export */   "parseDirective": function() { return /* binding */ parseDirective; },
/* harmony export */   "parseFeature": function() { return /* binding */ parseFeature; },
/* harmony export */   "unescape": function() { return /* binding */ unescape; }
/* harmony export */ });
// Fast, low-level functions for parsing and formatting GFF3.
// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.
/**
 * Unescape a string value used in a GFF3 attribute.
 *
 * @param stringVal - Escaped GFF3 string value
 * @returns An unescaped string value
 */
function unescape(stringVal) {
    return stringVal.replace(/%([0-9A-Fa-f]{2})/g, (_match, seq) => String.fromCharCode(parseInt(seq, 16)));
}
function _escape(regex, s) {
    return String(s).replace(regex, (ch) => {
        const hex = ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0');
        return `%${hex}`;
    });
}
/**
 * Escape a value for use in a GFF3 attribute value.
 *
 * @param rawVal - Raw GFF3 attribute value
 * @returns An escaped string value
 */
function escape(rawVal) {
    return _escape(/[\n;\r\t=%&,\x00-\x1f\x7f-\xff]/g, rawVal);
}
/**
 * Escape a value for use in a GFF3 column value.
 *
 * @param rawVal - Raw GFF3 column value
 * @returns An escaped column value
 */
function escapeColumn(rawVal) {
    return _escape(/[\n\r\t%\x00-\x1f\x7f-\xff]/g, rawVal);
}
/**
 * Parse the 9th column (attributes) of a GFF3 feature line.
 *
 * @param attrString - String of GFF3 9th column
 * @returns Parsed attributes
 */
function parseAttributes(attrString) {
    if (!(attrString && attrString.length) || attrString === '.')
        return {};
    const attrs = {};
    attrString
        .replace(/\r?\n$/, '')
        .split(';')
        .forEach((a) => {
        const nv = a.split('=', 2);
        if (!(nv[1] && nv[1].length))
            return;
        nv[0] = nv[0].trim();
        let arec = attrs[nv[0].trim()];
        if (!arec) {
            arec = [];
            attrs[nv[0]] = arec;
        }
        arec.push(...nv[1]
            .split(',')
            .map((s) => s.trim())
            .map(unescape));
    });
    return attrs;
}
/**
 * Parse a GFF3 feature line
 *
 * @param line - GFF3 feature line
 * @returns The parsed feature
 */
function parseFeature(line) {
    // split the line into columns and replace '.' with null in each column
    const f = line.split('\t').map((a) => (a === '.' || a === '' ? null : a));
    // unescape only the ref, source, and type columns
    const parsed = {
        seq_id: f[0] && unescape(f[0]),
        source: f[1] && unescape(f[1]),
        type: f[2] && unescape(f[2]),
        start: f[3] === null ? null : parseInt(f[3], 10),
        end: f[4] === null ? null : parseInt(f[4], 10),
        score: f[5] === null ? null : parseFloat(f[5]),
        strand: f[6],
        phase: f[7],
        attributes: f[8] === null ? null : parseAttributes(f[8]),
    };
    return parsed;
}
/**
 * Parse a GFF3 directive line.
 *
 * @param line - GFF3 directive line
 * @returns The parsed directive
 */
function parseDirective(line) {
    const match = /^\s*##\s*(\S+)\s*(.*)/.exec(line);
    if (!match)
        return null;
    const [, name] = match;
    let [, , contents] = match;
    const parsed = { directive: name };
    if (contents.length) {
        contents = contents.replace(/\r?\n$/, '');
        parsed.value = contents;
    }
    // do a little additional parsing for sequence-region and genome-build directives
    if (name === 'sequence-region') {
        const c = contents.split(/\s+/, 3);
        return {
            ...parsed,
            seq_id: c[0],
            start: c[1] && c[1].replace(/\D/g, ''),
            end: c[2] && c[2].replace(/\D/g, ''),
        };
    }
    else if (name === 'genome-build') {
        const [source, buildName] = contents.split(/\s+/, 2);
        return {
            ...parsed,
            source,
            buildName,
        };
    }
    return parsed;
}
/**
 * Format an attributes object into a string suitable for the 9th column of GFF3.
 *
 * @param attrs - Attributes
 * @returns GFF3 9th column string
 */
function formatAttributes(attrs) {
    const attrOrder = [];
    Object.entries(attrs).forEach(([tag, val]) => {
        if (!val)
            return;
        let valstring;
        if (val.hasOwnProperty('toString')) {
            valstring = escape(val.toString());
            // } else if (Array.isArray(val.values)) {
            //   valstring = val.values.map(escape).join(',')
        }
        else if (Array.isArray(val)) {
            valstring = val.map(escape).join(',');
        }
        else {
            valstring = escape(val);
        }
        attrOrder.push(`${escape(tag)}=${valstring}`);
    });
    return attrOrder.length ? attrOrder.join(';') : '.';
}
function _formatSingleFeature(f, seenFeature) {
    const attrString = f.attributes === null || f.attributes === undefined
        ? '.'
        : formatAttributes(f.attributes);
    const fields = [
        f.seq_id === null ? '.' : escapeColumn(f.seq_id),
        f.source === null ? '.' : escapeColumn(f.source),
        f.type === null ? '.' : escapeColumn(f.type),
        f.start === null ? '.' : escapeColumn(f.start),
        f.end === null ? '.' : escapeColumn(f.end),
        f.score === null ? '.' : escapeColumn(f.score),
        f.strand === null ? '.' : escapeColumn(f.strand),
        f.phase === null ? '.' : escapeColumn(f.phase),
        attrString,
    ];
    const formattedString = `${fields.join('\t')}\n`;
    // if we have already output this exact feature, skip it
    if (seenFeature[formattedString]) {
        return '';
    }
    seenFeature[formattedString] = true;
    return formattedString;
}
function _formatFeature(feature, seenFeature) {
    if (Array.isArray(feature)) {
        return feature.map((f) => _formatFeature(f, seenFeature)).join('');
    }
    const strings = [_formatSingleFeature(feature, seenFeature)];
    if (_isFeatureLineWithRefs(feature)) {
        strings.push(...feature.child_features.map((f) => _formatFeature(f, seenFeature)), ...feature.derived_features.map((f) => _formatFeature(f, seenFeature)));
    }
    return strings.join('');
}
/**
 * Format a feature object or array of feature objects into one or more lines of
 * GFF3.
 *
 * @param featureOrFeatures - A feature object or array of feature objects
 * @returns A string of one or more GFF3 lines
 */
function formatFeature(featureOrFeatures) {
    const seen = {};
    return _formatFeature(featureOrFeatures, seen);
}
/**
 * Format a directive into a line of GFF3.
 *
 * @param directive - A directive object
 * @returns A directive line string
 */
function formatDirective(directive) {
    let str = `##${directive.directive}`;
    if (directive.value)
        str += ` ${directive.value}`;
    str += '\n';
    return str;
}
/**
 * Format a comment into a GFF3 comment.
 * Yes I know this is just adding a # and a newline.
 *
 * @param comment - A comment object
 * @returns A comment line string
 */
function formatComment(comment) {
    return `# ${comment.comment}\n`;
}
/**
 * Format a sequence object as FASTA
 *
 * @param seq - A sequence object
 * @returns Formatted single FASTA sequence string
 */
function formatSequence(seq) {
    return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\n${seq.sequence}\n`;
}
/**
 * Format a directive, comment, sequence, or feature, or array of such items,
 * into one or more lines of GFF3.
 *
 * @param itemOrItems - A comment, sequence, or feature, or array of such items
 * @returns A formatted string or array of strings
 */
function formatItem(itemOrItems) {
    function formatSingleItem(item) {
        if ('attributes' in item)
            return formatFeature(item);
        if ('directive' in item)
            return formatDirective(item);
        if ('sequence' in item)
            return formatSequence(item);
        if ('comment' in item)
            return formatComment(item);
        return '# (invalid item found during format)\n';
    }
    if (Array.isArray(itemOrItems)) {
        return itemOrItems.map(formatSingleItem);
    }
    return formatSingleItem(itemOrItems);
}
function _isFeatureLineWithRefs(featureLine) {
    return (featureLine.child_features !== undefined &&
        featureLine.derived_features !== undefined);
}
//# sourceMappingURL=util.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_gmod_gff_esm_index_js.bundle.js.map