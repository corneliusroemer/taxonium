"use strict";
(self["webpackChunktaxonium"] = self["webpackChunktaxonium"] || []).push([["vendors-node_modules_gmod_tabix_esm_index_js"],{

/***/ "./node_modules/@gmod/tabix/esm/chunk.js":
/*!***********************************************!*\
  !*** ./node_modules/@gmod/tabix/esm/chunk.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Chunk; }
/* harmony export */ });
// little class representing a chunk in the index
class Chunk {
    /**
     * @param {VirtualOffset} minv
     * @param {VirtualOffset} maxv
     * @param {number} bin
     * @param {number} [fetchedSize]
     */
    constructor(minv, maxv, bin, fetchedSize = undefined) {
        this.minv = minv;
        this.maxv = maxv;
        this.bin = bin;
        this._fetchedSize = fetchedSize;
    }
    toUniqueString() {
        return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;
    }
    toString() {
        return this.toUniqueString();
    }
    compareTo(b) {
        return (this.minv.compareTo(b.minv) ||
            this.maxv.compareTo(b.maxv) ||
            this.bin - b.bin);
    }
    fetchedSize() {
        if (this._fetchedSize !== undefined) {
            return this._fetchedSize;
        }
        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;
    }
}
//# sourceMappingURL=chunk.js.map

/***/ }),

/***/ "./node_modules/@gmod/tabix/esm/csi.js":
/*!*********************************************!*\
  !*** ./node_modules/@gmod/tabix/esm/csi.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ CSI; }
/* harmony export */ });
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gmod/bgzf-filehandle */ "./node_modules/@gmod/bgzf-filehandle/esm/index.js");
/* harmony import */ var _virtualOffset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./virtualOffset */ "./node_modules/@gmod/tabix/esm/virtualOffset.js");
/* harmony import */ var _chunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk */ "./node_modules/@gmod/tabix/esm/chunk.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/tabix/esm/util.js");
/* harmony import */ var _indexFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./indexFile */ "./node_modules/@gmod/tabix/esm/indexFile.js");






const CSI1_MAGIC = 21582659; // CSI\1
const CSI2_MAGIC = 38359875; // CSI\2
function lshift(num, bits) {
    return num * 2 ** bits;
}
function rshift(num, bits) {
    return Math.floor(num / 2 ** bits);
}
class CSI extends _indexFile__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(args) {
        super(args);
        this.maxBinNumber = 0;
        this.depth = 0;
        this.minShift = 0;
    }
    async lineCount(refName, opts = {}) {
        const indexData = await this.parse(opts);
        if (!indexData) {
            return -1;
        }
        const refId = indexData.refNameToId[refName];
        const idx = indexData.indices[refId];
        if (!idx) {
            return -1;
        }
        const { stats } = indexData.indices[refId];
        if (stats) {
            return stats.lineCount;
        }
        return -1;
    }
    async indexCov() {
        throw new Error('CSI indexes do not support indexcov');
        return [];
    }
    parseAuxData(bytes, offset, auxLength) {
        if (auxLength < 30) {
            return {
                refIdToName: [],
                refNameToId: {},
            };
        }
        const formatFlags = bytes.readInt32LE(offset);
        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
        const format = { 0: 'generic', 1: 'SAM', 2: 'VCF' }[formatFlags & 0xf];
        if (!format) {
            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);
        }
        const columnNumbers = {
            ref: bytes.readInt32LE(offset + 4),
            start: bytes.readInt32LE(offset + 8),
            end: bytes.readInt32LE(offset + 12),
        };
        const metaValue = bytes.readInt32LE(offset + 16);
        const metaChar = metaValue ? String.fromCharCode(metaValue) : '';
        const skipLines = bytes.readInt32LE(offset + 20);
        const nameSectionLength = bytes.readInt32LE(offset + 24);
        const { refIdToName, refNameToId } = this._parseNameBytes(bytes.slice(offset + 28, offset + 28 + nameSectionLength));
        return {
            refIdToName,
            refNameToId,
            skipLines,
            metaChar,
            columnNumbers,
            format,
            coordinateType,
        };
    }
    _parseNameBytes(namesBytes) {
        let currRefId = 0;
        let currNameStart = 0;
        const refIdToName = [];
        const refNameToId = {};
        for (let i = 0; i < namesBytes.length; i += 1) {
            if (!namesBytes[i]) {
                if (currNameStart < i) {
                    let refName = namesBytes.toString('utf8', currNameStart, i);
                    refName = this.renameRefSeq(refName);
                    refIdToName[currRefId] = refName;
                    refNameToId[refName] = currRefId;
                }
                currNameStart = i + 1;
                currRefId += 1;
            }
        }
        return { refNameToId, refIdToName };
    }
    // fetch and parse the index
    async _parse(opts = {}) {
        const bytes = await (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_1__.unzip)((await this.filehandle.readFile(opts)));
        // check TBI magic numbers
        let csiVersion;
        if (bytes.readUInt32LE(0) === CSI1_MAGIC) {
            csiVersion = 1;
        }
        else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {
            csiVersion = 2;
        }
        else {
            throw new Error('Not a CSI file');
            // TODO: do we need to support big-endian CSI files?
        }
        this.minShift = bytes.readInt32LE(4);
        this.depth = bytes.readInt32LE(8);
        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;
        const maxRefLength = 2 ** (this.minShift + this.depth * 3);
        const auxLength = bytes.readInt32LE(12);
        let aux = {
            refIdToName: [],
            refNameToId: {},
        };
        if (auxLength) {
            aux = this.parseAuxData(bytes, 16, auxLength);
        }
        const refCount = bytes.readInt32LE(16 + auxLength);
        // read the indexes for each reference sequence
        let firstDataLine;
        let currOffset = 16 + auxLength + 4;
        const indices = new Array(refCount).fill(0).map(() => {
            // the binning index
            const binCount = bytes.readInt32LE(currOffset);
            currOffset += 4;
            const binIndex = {};
            let stats; // < provided by parsing a pseudo-bin, if present
            for (let j = 0; j < binCount; j += 1) {
                const bin = bytes.readUInt32LE(currOffset);
                if (bin > this.maxBinNumber) {
                    // this is a fake bin that actually has stats information
                    // about the reference sequence in it
                    stats = this.parsePseudoBin(bytes, currOffset + 4);
                    currOffset += 4 + 8 + 4 + 16 + 16;
                }
                else {
                    const loffset = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_2__.fromBytes)(bytes, currOffset + 4);
                    firstDataLine = this._findFirstData(firstDataLine, loffset);
                    const chunkCount = bytes.readInt32LE(currOffset + 12);
                    currOffset += 16;
                    const chunks = new Array(chunkCount);
                    for (let k = 0; k < chunkCount; k += 1) {
                        const u = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_2__.fromBytes)(bytes, currOffset);
                        const v = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_2__.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16;
                        // this._findFirstData(data, u)
                        chunks[k] = new _chunk__WEBPACK_IMPORTED_MODULE_3__["default"](u, v, bin);
                    }
                    binIndex[bin] = chunks;
                }
            }
            return { binIndex, stats };
        });
        return {
            ...aux,
            csi: true,
            refCount,
            maxBlockSize: 1 << 16,
            firstDataLine,
            csiVersion,
            indices,
            depth: this.depth,
            maxBinNumber: this.maxBinNumber,
            maxRefLength,
        };
    }
    parsePseudoBin(bytes, offset) {
        const lineCount = (0,_util__WEBPACK_IMPORTED_MODULE_4__.longToNumber)(long__WEBPACK_IMPORTED_MODULE_0___default().fromBytesLE(Array.prototype.slice.call(bytes, offset + 28, offset + 36), true));
        return { lineCount };
    }
    async blocksForRange(refName, min, max, opts = {}) {
        if (min < 0) {
            min = 0;
        }
        const indexData = await this.parse(opts);
        if (!indexData) {
            return [];
        }
        const refId = indexData.refNameToId[refName];
        const ba = indexData.indices[refId];
        if (!ba) {
            return [];
        }
        // const { linearIndex, binIndex } = indexes
        const overlappingBins = this.reg2bins(min, max); // List of bin #s that overlap min, max
        const chunks = [];
        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned
        for (const [start, end] of overlappingBins) {
            for (let bin = start; bin <= end; bin++) {
                if (ba.binIndex[bin]) {
                    const binChunks = ba.binIndex[bin];
                    for (let c = 0; c < binChunks.length; ++c) {
                        chunks.push(new _chunk__WEBPACK_IMPORTED_MODULE_3__["default"](binChunks[c].minv, binChunks[c].maxv, bin));
                    }
                }
            }
        }
        return (0,_util__WEBPACK_IMPORTED_MODULE_4__.optimizeChunks)(chunks, new _virtualOffset__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0));
    }
    /**
     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
     */
    reg2bins(beg, end) {
        beg -= 1; // < convert to 1-based closed
        if (beg < 1) {
            beg = 1;
        }
        if (end > 2 ** 50) {
            end = 2 ** 34;
        } // 17 GiB ought to be enough for anybody
        end -= 1;
        let l = 0;
        let t = 0;
        let s = this.minShift + this.depth * 3;
        const bins = [];
        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {
            const b = t + rshift(beg, s);
            const e = t + rshift(end, s);
            if (e - b + bins.length > this.maxBinNumber) {
                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);
            }
            bins.push([b, e]);
        }
        return bins;
    }
}
//# sourceMappingURL=csi.js.map

/***/ }),

/***/ "./node_modules/@gmod/tabix/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@gmod/tabix/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSI": function() { return /* reexport safe */ _csi__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "TBI": function() { return /* reexport safe */ _tbi__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "TabixIndexedFile": function() { return /* reexport safe */ _tabixIndexedFile__WEBPACK_IMPORTED_MODULE_0__["default"]; }
/* harmony export */ });
/* harmony import */ var _tabixIndexedFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tabixIndexedFile */ "./node_modules/@gmod/tabix/esm/tabixIndexedFile.js");
/* harmony import */ var _tbi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tbi */ "./node_modules/@gmod/tabix/esm/tbi.js");
/* harmony import */ var _csi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./csi */ "./node_modules/@gmod/tabix/esm/csi.js");




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@gmod/tabix/esm/indexFile.js":
/*!***************************************************!*\
  !*** ./node_modules/@gmod/tabix/esm/indexFile.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ IndexFile; }
/* harmony export */ });
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abortable-promise-cache */ "./node_modules/abortable-promise-cache/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(abortable_promise_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! quick-lru */ "./node_modules/@gmod/tabix/node_modules/quick-lru/index.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(quick_lru__WEBPACK_IMPORTED_MODULE_1__);


class IndexFile {
    /**
     * @param {filehandle} filehandle
     * @param {function} [renameRefSeqs]
     */
    constructor({ filehandle, renameRefSeqs = (n) => n, }) {
        this.filehandle = filehandle;
        this.renameRefSeq = renameRefSeqs;
    }
    async getMetadata(opts = {}) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { indices, ...rest } = await this.parse(opts);
        return rest;
    }
    _findFirstData(currentFdl, virtualOffset) {
        if (currentFdl) {
            return currentFdl.compareTo(virtualOffset) > 0
                ? virtualOffset
                : currentFdl;
        }
        else {
            return virtualOffset;
        }
    }
    async parse(opts = {}) {
        if (!this._parseCache) {
            this._parseCache = new (abortable_promise_cache__WEBPACK_IMPORTED_MODULE_0___default())({
                cache: new (quick_lru__WEBPACK_IMPORTED_MODULE_1___default())({ maxSize: 1 }),
                fill: () => this._parse(opts),
            });
        }
        return this._parseCache.get('index', null, undefined);
    }
    async hasRefSeq(seqId, opts = {}) {
        return !!((await this.parse(opts)).indices[seqId] || {}).binIndex;
    }
}
//# sourceMappingURL=indexFile.js.map

/***/ }),

/***/ "./node_modules/@gmod/tabix/esm/tabixIndexedFile.js":
/*!**********************************************************!*\
  !*** ./node_modules/@gmod/tabix/esm/tabixIndexedFile.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TabixIndexedFile; }
/* harmony export */ });
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abortable-promise-cache */ "./node_modules/abortable-promise-cache/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(abortable_promise_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! quick-lru */ "./node_modules/@gmod/tabix/node_modules/quick-lru/index.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(quick_lru__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var generic_filehandle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! generic-filehandle */ "./node_modules/generic-filehandle/esm/index.js");
/* harmony import */ var _gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @gmod/bgzf-filehandle */ "./node_modules/@gmod/bgzf-filehandle/esm/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/tabix/esm/util.js");
/* harmony import */ var _tbi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tbi */ "./node_modules/@gmod/tabix/esm/tbi.js");
/* harmony import */ var _csi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./csi */ "./node_modules/@gmod/tabix/esm/csi.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];







function timeout(time) {
    return new Promise(resolve => {
        setTimeout(resolve, time);
    });
}
class TabixIndexedFile {
    /**
     * @param {object} args
     * @param {string} [args.path]
     * @param {filehandle} [args.filehandle]
     * @param {string} [args.tbiPath]
     * @param {filehandle} [args.tbiFilehandle]
     * @param {string} [args.csiPath]
     * @param {filehandle} [args.csiFilehandle]
     * @param {chunkSizeLimit} default 50MiB
     * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform
     * reference sequence names for the purpose of indexing and querying. note that the data that is returned is
     * not altered, just the names of the reference sequences that are used for querying.
     * @param {number} [args.chunkCacheSize] maximum size in bytes of the chunk cache. default 5MB
     * @param {number} [args.blockCacheSize] maximum size in bytes of the block cache. default 5MB
     */
    constructor({ path, filehandle, tbiPath, tbiFilehandle, csiPath, csiFilehandle, chunkSizeLimit = 50000000, renameRefSeqs = n => n, chunkCacheSize = 5 * 2 ** 20, }) {
        if (filehandle) {
            this.filehandle = filehandle;
        }
        else if (path) {
            this.filehandle = new generic_filehandle__WEBPACK_IMPORTED_MODULE_2__.LocalFile(path);
        }
        else {
            throw new TypeError('must provide either filehandle or path');
        }
        if (tbiFilehandle) {
            this.index = new _tbi__WEBPACK_IMPORTED_MODULE_5__["default"]({
                filehandle: tbiFilehandle,
                renameRefSeqs,
            });
        }
        else if (csiFilehandle) {
            this.index = new _csi__WEBPACK_IMPORTED_MODULE_6__["default"]({
                filehandle: csiFilehandle,
                renameRefSeqs,
            });
        }
        else if (tbiPath) {
            this.index = new _tbi__WEBPACK_IMPORTED_MODULE_5__["default"]({
                filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_2__.LocalFile(tbiPath),
                renameRefSeqs,
            });
        }
        else if (csiPath) {
            this.index = new _csi__WEBPACK_IMPORTED_MODULE_6__["default"]({
                filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_2__.LocalFile(csiPath),
                renameRefSeqs,
            });
        }
        else if (path) {
            this.index = new _tbi__WEBPACK_IMPORTED_MODULE_5__["default"]({
                filehandle: new generic_filehandle__WEBPACK_IMPORTED_MODULE_2__.LocalFile(`${path}.tbi`),
                renameRefSeqs,
            });
        }
        else {
            throw new TypeError('must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath');
        }
        this.chunkSizeLimit = chunkSizeLimit;
        this.renameRefSeq = renameRefSeqs;
        this.chunkCache = new (abortable_promise_cache__WEBPACK_IMPORTED_MODULE_0___default())({
            cache: new (quick_lru__WEBPACK_IMPORTED_MODULE_1___default())({
                maxSize: Math.floor(chunkCacheSize / (1 << 16)),
            }),
            fill: this.readChunk.bind(this),
        });
    }
    /**
     * @param {string} refName name of the reference sequence
     * @param {number} start start of the region (in 0-based half-open coordinates)
     * @param {number} end end of the region (in 0-based half-open coordinates)
     * @param {function|object} lineCallback callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc
     * @returns {Promise} resolved when the whole read is finished, rejected on error
     */
    async getLines(refName, start, end, opts) {
        let signal;
        let options = {};
        let callback;
        if (typeof opts === 'undefined') {
            throw new TypeError('line callback must be provided');
        }
        if (typeof opts === 'function') {
            callback = opts;
        }
        else {
            options = opts;
            callback = opts.lineCallback;
        }
        if (refName === undefined) {
            throw new TypeError('must provide a reference sequence name');
        }
        if (!callback) {
            throw new TypeError('line callback must be provided');
        }
        const metadata = await this.index.getMetadata(options);
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.checkAbortSignal)(signal);
        if (!start) {
            start = 0;
        }
        if (!end) {
            end = metadata.maxRefLength;
        }
        if (!(start <= end)) {
            throw new TypeError('invalid start and end coordinates. start must be less than or equal to end');
        }
        if (start === end) {
            return;
        }
        const chunks = await this.index.blocksForRange(refName, start, end, options);
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.checkAbortSignal)(signal);
        // check the chunks for any that are over the size limit.  if
        // any are, don't fetch any of them
        for (let i = 0; i < chunks.length; i += 1) {
            const size = chunks[i].fetchedSize();
            if (size > this.chunkSizeLimit) {
                throw new Error(`Too much data. Chunk size ${size.toLocaleString()} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit.toLocaleString()}.`);
            }
        }
        // now go through each chunk and parse and filter the lines out of it
        let last = Date.now();
        for (let chunkNum = 0; chunkNum < chunks.length; chunkNum += 1) {
            let previousStartCoordinate;
            const c = chunks[chunkNum];
            const { buffer, cpositions, dpositions } = await this.chunkCache.get(c.toString(), c, signal);
            const lines = (typeof TextDecoder !== 'undefined'
                ? new TextDecoder('utf-8').decode(buffer)
                : buffer.toString()).split('\n');
            lines.pop();
            (0,_util__WEBPACK_IMPORTED_MODULE_4__.checkAbortSignal)(signal);
            let blockStart = c.minv.dataPosition;
            let pos;
            for (let i = 0; i < lines.length; i += 1) {
                const line = lines[i];
                for (pos = 0; blockStart >= dpositions[pos]; pos += 1) { }
                // filter the line for whether it is within the requested range
                const { startCoordinate, overlaps } = this.checkLine(metadata, refName, start, end, line);
                // do a small check just to make sure that the lines are really sorted by start coordinate
                if (previousStartCoordinate !== undefined &&
                    startCoordinate !== undefined &&
                    previousStartCoordinate > startCoordinate) {
                    throw new Error(`Lines not sorted by start coordinate (${previousStartCoordinate} > ${startCoordinate}), this file is not usable with Tabix.`);
                }
                previousStartCoordinate = startCoordinate;
                if (overlaps) {
                    callback(line.trim(), 
                    // cpositions[pos] refers to actual file offset of a bgzip block boundaries
                    //
                    // we multiply by (1 <<8) in order to make sure each block has a "unique"
                    // address space so that data in that block could never overlap
                    //
                    // then the blockStart-dpositions is an uncompressed file offset from
                    // that bgzip block boundary, and since the cpositions are multiplied by
                    // (1 << 8) these uncompressed offsets get a unique space
                    cpositions[pos] * (1 << 8) + (blockStart - dpositions[pos]));
                }
                else if (startCoordinate !== undefined && startCoordinate >= end) {
                    // the lines were overlapping the region, but now have stopped, so
                    // we must be at the end of the relevant data and we can stop
                    // processing data now
                    return;
                }
                blockStart += line.length + 1;
                // yield if we have emitted beyond the yield limit
                if (last - Date.now() > 500) {
                    last = Date.now();
                    (0,_util__WEBPACK_IMPORTED_MODULE_4__.checkAbortSignal)(signal);
                    await timeout(1);
                }
            }
        }
    }
    async getMetadata(opts = {}) {
        return this.index.getMetadata(opts);
    }
    /**
     * get a buffer containing the "header" region of
     * the file, which are the bytes up to the first
     * non-meta line
     *
     * @returns {Promise} for a buffer
     */
    async getHeaderBuffer(opts = {}) {
        const { firstDataLine, metaChar, maxBlockSize } = await this.getMetadata(opts);
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.checkAbortSignal)(opts.signal);
        const maxFetch = firstDataLine && firstDataLine.blockPosition
            ? firstDataLine.blockPosition + maxBlockSize
            : maxBlockSize;
        // TODO: what if we don't have a firstDataLine, and the header
        // actually takes up more than one block? this case is not covered here
        let bytes = await this._readRegion(0, maxFetch, opts);
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.checkAbortSignal)(opts.signal);
        try {
            bytes = await (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_3__.unzip)(bytes);
        }
        catch (e) {
            console.error(e);
            throw new Error(
            //@ts-ignore
            `error decompressing block ${e.code} at 0 (length ${maxFetch}) ${e}`);
        }
        // trim off lines after the last non-meta line
        if (metaChar) {
            // trim backward from the end
            let lastNewline = -1;
            const newlineByte = '\n'.charCodeAt(0);
            const metaByte = metaChar.charCodeAt(0);
            for (let i = 0; i < bytes.length; i += 1) {
                if (i === lastNewline + 1 && bytes[i] !== metaByte) {
                    break;
                }
                if (bytes[i] === newlineByte) {
                    lastNewline = i;
                }
            }
            bytes = bytes.slice(0, lastNewline + 1);
        }
        return bytes;
    }
    /**
     * get a string containing the "header" region of the
     * file, is the portion up to the first non-meta line
     *
     * @returns {Promise} for a string
     */
    async getHeader(opts = {}) {
        const bytes = await this.getHeaderBuffer(opts);
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.checkAbortSignal)(opts.signal);
        return bytes.toString('utf8');
    }
    /**
     * get an array of reference sequence names, in the order in which
     * they occur in the file.
     *
     * reference sequence renaming is not applied to these names.
     *
     * @returns {Promise} for an array of string sequence names
     */
    async getReferenceSequenceNames(opts = {}) {
        const metadata = await this.getMetadata(opts);
        return metadata.refIdToName;
    }
    /**
     * @param {object} metadata metadata object from the parsed index,
     * containing columnNumbers, metaChar, and format
     * @param {string} regionRefName
     * @param {number} regionStart region start coordinate (0-based-half-open)
     * @param {number} regionEnd region end coordinate (0-based-half-open)
     * @param {array[string]} line
     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,
     * true if line is a data line that overlaps the given region
     */
    checkLine({ columnNumbers, metaChar, coordinateType, format, }, regionRefName, regionStart, regionEnd, line) {
        // skip meta lines
        if (line.charAt(0) === metaChar) {
            return { overlaps: false };
        }
        // check ref/start/end using column metadata from index
        let { ref, start, end } = columnNumbers;
        if (!ref) {
            ref = 0;
        }
        if (!start) {
            start = 0;
        }
        if (!end) {
            end = 0;
        }
        if (format === 'VCF') {
            end = 8;
        }
        const maxColumn = Math.max(ref, start, end);
        // this code is kind of complex, but it is fairly fast.
        // basically, we want to avoid doing a split, because if the lines are really long
        // that could lead to us allocating a bunch of extra memory, which is slow
        let currentColumnNumber = 1; // cols are numbered starting at 1 in the index metadata
        let currentColumnStart = 0;
        let refSeq = '';
        let startCoordinate = -Infinity;
        for (let i = 0; i < line.length + 1; i += 1) {
            if (line[i] === '\t' || i === line.length) {
                if (currentColumnNumber === ref) {
                    if (this.renameRefSeq(line.slice(currentColumnStart, i)) !==
                        regionRefName) {
                        return { overlaps: false };
                    }
                }
                else if (currentColumnNumber === start) {
                    startCoordinate = parseInt(line.slice(currentColumnStart, i), 10);
                    // we convert to 0-based-half-open
                    if (coordinateType === '1-based-closed') {
                        startCoordinate -= 1;
                    }
                    if (startCoordinate >= regionEnd) {
                        return { startCoordinate, overlaps: false };
                    }
                    if (end === 0 || end === start) {
                        // if we have no end, we assume the feature is 1 bp long
                        if (startCoordinate + 1 <= regionStart) {
                            return { startCoordinate, overlaps: false };
                        }
                    }
                }
                else if (format === 'VCF' && currentColumnNumber === 4) {
                    refSeq = line.slice(currentColumnStart, i);
                }
                else if (currentColumnNumber === end) {
                    let endCoordinate;
                    // this will never match if there is no end column
                    if (format === 'VCF') {
                        endCoordinate = this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i));
                    }
                    else {
                        endCoordinate = parseInt(line.slice(currentColumnStart, i), 10);
                    }
                    if (endCoordinate <= regionStart) {
                        return { overlaps: false };
                    }
                }
                currentColumnStart = i + 1;
                currentColumnNumber += 1;
                if (currentColumnNumber > maxColumn) {
                    break;
                }
            }
        }
        return { startCoordinate, overlaps: true };
    }
    _getVcfEnd(startCoordinate, refSeq, info) {
        let endCoordinate = startCoordinate + refSeq.length;
        // ignore TRA features as they specify CHR2 and END
        // as being on a different chromosome
        // if CHR2 is on the same chromosome, still ignore it
        // because there should be another pairwise feature
        // at the end of this one
        const isTRA = info.indexOf('SVTYPE=TRA') !== -1;
        if (info[0] !== '.' && !isTRA) {
            let prevChar = ';';
            for (let j = 0; j < info.length; j += 1) {
                if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {
                    let valueEnd = info.indexOf(';', j);
                    if (valueEnd === -1) {
                        valueEnd = info.length;
                    }
                    endCoordinate = parseInt(info.slice(j + 4, valueEnd), 10);
                    break;
                }
                prevChar = info[j];
            }
        }
        else if (isTRA) {
            return startCoordinate + 1;
        }
        return endCoordinate;
    }
    /**
     * return the approximate number of data lines in the given reference sequence
     * @param {string} refSeq reference sequence name
     * @returns {Promise} for number of data lines present on that reference sequence
     */
    async lineCount(refName, opts = {}) {
        return this.index.lineCount(refName, opts);
    }
    async _readRegion(position, compressedSize, opts = {}) {
        const { bytesRead, buffer } = await this.filehandle.read(Buffer.alloc(compressedSize), 0, compressedSize, position, opts);
        return bytesRead < compressedSize ? buffer.slice(0, bytesRead) : buffer;
    }
    /**
     * read and uncompress the data in a chunk (composed of one or more
     * contiguous bgzip blocks) of the file
     * @param {Chunk} chunk
     * @returns {Promise} for a string chunk of the file
     */
    async readChunk(chunk, opts = {}) {
        // fetch the uncompressed data, uncompress carefully a block at a time,
        // and stop when done
        const compressedData = await this._readRegion(chunk.minv.blockPosition, chunk.fetchedSize(), opts);
        try {
            return (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_3__.unzipChunkSlice)(compressedData, chunk);
        }
        catch (e) {
            throw new Error(`error decompressing chunk ${chunk.toString()} ${e}`);
        }
    }
}
//# sourceMappingURL=tabixIndexedFile.js.map

/***/ }),

/***/ "./node_modules/@gmod/tabix/esm/tbi.js":
/*!*********************************************!*\
  !*** ./node_modules/@gmod/tabix/esm/tbi.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TabixIndex; }
/* harmony export */ });
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _virtualOffset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./virtualOffset */ "./node_modules/@gmod/tabix/esm/virtualOffset.js");
/* harmony import */ var _chunk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk */ "./node_modules/@gmod/tabix/esm/chunk.js");
/* harmony import */ var _gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @gmod/bgzf-filehandle */ "./node_modules/@gmod/bgzf-filehandle/esm/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/tabix/esm/util.js");
/* harmony import */ var _indexFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./indexFile */ "./node_modules/@gmod/tabix/esm/indexFile.js");






const TBI_MAGIC = 21578324; // TBI\1
const TAD_LIDX_SHIFT = 14;
/**
 * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
 */
function reg2bins(beg, end) {
    beg += 1; // < convert to 1-based closed
    end -= 1;
    return [
        [0, 0],
        [1 + (beg >> 26), 1 + (end >> 26)],
        [9 + (beg >> 23), 9 + (end >> 23)],
        [73 + (beg >> 20), 73 + (end >> 20)],
        [585 + (beg >> 17), 585 + (end >> 17)],
        [4681 + (beg >> 14), 4681 + (end >> 14)],
    ];
}
class TabixIndex extends _indexFile__WEBPACK_IMPORTED_MODULE_5__["default"] {
    async lineCount(refName, opts = {}) {
        const indexData = await this.parse(opts);
        if (!indexData) {
            return -1;
        }
        const refId = indexData.refNameToId[refName];
        const idx = indexData.indices[refId];
        if (!idx) {
            return -1;
        }
        const { stats } = indexData.indices[refId];
        if (stats) {
            return stats.lineCount;
        }
        return -1;
    }
    // memoize
    // fetch and parse the index
    async _parse(opts = {}) {
        const bytes = await (0,_gmod_bgzf_filehandle__WEBPACK_IMPORTED_MODULE_3__.unzip)((await this.filehandle.readFile(opts)));
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.checkAbortSignal)(opts.signal);
        // check TBI magic numbers
        if (bytes.readUInt32LE(0) !== TBI_MAGIC /* "TBI\1" */) {
            throw new Error('Not a TBI file');
            // TODO: do we need to support big-endian TBI files?
        }
        // number of reference sequences in the index
        const refCount = bytes.readInt32LE(4);
        const formatFlags = bytes.readInt32LE(8);
        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
        const formatOpts = {
            0: 'generic',
            1: 'SAM',
            2: 'VCF',
        };
        const format = formatOpts[formatFlags & 0xf];
        if (!format) {
            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);
        }
        const columnNumbers = {
            ref: bytes.readInt32LE(12),
            start: bytes.readInt32LE(16),
            end: bytes.readInt32LE(20),
        };
        const metaValue = bytes.readInt32LE(24);
        const depth = 5;
        const maxBinNumber = ((1 << ((depth + 1) * 3)) - 1) / 7;
        const maxRefLength = 2 ** (14 + depth * 3);
        const metaChar = metaValue ? String.fromCharCode(metaValue) : null;
        const skipLines = bytes.readInt32LE(28);
        // read sequence dictionary
        const nameSectionLength = bytes.readInt32LE(32);
        const { refNameToId, refIdToName } = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));
        // read the indexes for each reference sequence
        let currOffset = 36 + nameSectionLength;
        let firstDataLine;
        const indices = new Array(refCount).fill(0).map(() => {
            // the binning index
            const binCount = bytes.readInt32LE(currOffset);
            currOffset += 4;
            const binIndex = {};
            let stats;
            for (let j = 0; j < binCount; j += 1) {
                const bin = bytes.readUInt32LE(currOffset);
                currOffset += 4;
                if (bin > maxBinNumber + 1) {
                    throw new Error('tabix index contains too many bins, please use a CSI index');
                }
                else if (bin === maxBinNumber + 1) {
                    const chunkCount = bytes.readInt32LE(currOffset);
                    currOffset += 4;
                    if (chunkCount === 2) {
                        stats = this.parsePseudoBin(bytes, currOffset);
                    }
                    currOffset += 16 * chunkCount;
                }
                else {
                    const chunkCount = bytes.readInt32LE(currOffset);
                    currOffset += 4;
                    const chunks = new Array(chunkCount);
                    for (let k = 0; k < chunkCount; k += 1) {
                        const u = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_1__.fromBytes)(bytes, currOffset);
                        const v = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_1__.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16;
                        firstDataLine = this._findFirstData(firstDataLine, u);
                        chunks[k] = new _chunk__WEBPACK_IMPORTED_MODULE_2__["default"](u, v, bin);
                    }
                    binIndex[bin] = chunks;
                }
            }
            // the linear index
            const linearCount = bytes.readInt32LE(currOffset);
            currOffset += 4;
            const linearIndex = new Array(linearCount);
            for (let k = 0; k < linearCount; k += 1) {
                linearIndex[k] = (0,_virtualOffset__WEBPACK_IMPORTED_MODULE_1__.fromBytes)(bytes, currOffset);
                currOffset += 8;
                firstDataLine = this._findFirstData(firstDataLine, linearIndex[k]);
            }
            return { binIndex, linearIndex, stats };
        });
        return {
            indices,
            metaChar,
            maxBinNumber,
            maxRefLength,
            skipLines,
            firstDataLine,
            columnNumbers,
            coordinateType,
            format,
            refIdToName,
            refNameToId,
            maxBlockSize: 1 << 16,
        };
    }
    parsePseudoBin(bytes, offset) {
        const lineCount = (0,_util__WEBPACK_IMPORTED_MODULE_4__.longToNumber)(long__WEBPACK_IMPORTED_MODULE_0___default().fromBytesLE(bytes.slice(offset + 16, offset + 24), true));
        return { lineCount };
    }
    _parseNameBytes(namesBytes) {
        let currRefId = 0;
        let currNameStart = 0;
        const refIdToName = [];
        const refNameToId = {};
        for (let i = 0; i < namesBytes.length; i += 1) {
            if (!namesBytes[i]) {
                if (currNameStart < i) {
                    let refName = namesBytes.toString('utf8', currNameStart, i);
                    refName = this.renameRefSeq(refName);
                    refIdToName[currRefId] = refName;
                    refNameToId[refName] = currRefId;
                }
                currNameStart = i + 1;
                currRefId += 1;
            }
        }
        return { refNameToId, refIdToName };
    }
    async blocksForRange(refName, min, max, opts = {}) {
        if (min < 0) {
            min = 0;
        }
        const indexData = await this.parse(opts);
        if (!indexData) {
            return [];
        }
        const refId = indexData.refNameToId[refName];
        const ba = indexData.indices[refId];
        if (!ba) {
            return [];
        }
        const minOffset = ba.linearIndex.length
            ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length
                ? ba.linearIndex.length - 1
                : min >> TAD_LIDX_SHIFT]
            : new _virtualOffset__WEBPACK_IMPORTED_MODULE_1__["default"](0, 0);
        if (!minOffset) {
            console.warn('querying outside of possible tabix range');
        }
        // const { linearIndex, binIndex } = indexes
        const overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max
        const chunks = [];
        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned
        for (const [start, end] of overlappingBins) {
            for (let bin = start; bin <= end; bin++) {
                if (ba.binIndex[bin]) {
                    const binChunks = ba.binIndex[bin];
                    for (let c = 0; c < binChunks.length; ++c) {
                        chunks.push(new _chunk__WEBPACK_IMPORTED_MODULE_2__["default"](binChunks[c].minv, binChunks[c].maxv, bin));
                    }
                }
            }
        }
        // Use the linear index to find minimum file position of chunks that could
        // contain alignments in the region
        const nintv = ba.linearIndex.length;
        let lowest = null;
        const minLin = Math.min(min >> 14, nintv - 1);
        const maxLin = Math.min(max >> 14, nintv - 1);
        for (let i = minLin; i <= maxLin; ++i) {
            const vp = ba.linearIndex[i];
            if (vp) {
                if (!lowest || vp.compareTo(lowest) < 0) {
                    lowest = vp;
                }
            }
        }
        return (0,_util__WEBPACK_IMPORTED_MODULE_4__.optimizeChunks)(chunks, lowest);
    }
}
//# sourceMappingURL=tbi.js.map

/***/ }),

/***/ "./node_modules/@gmod/tabix/esm/util.js":
/*!**********************************************!*\
  !*** ./node_modules/@gmod/tabix/esm/util.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abortBreakPoint": function() { return /* binding */ abortBreakPoint; },
/* harmony export */   "canMergeBlocks": function() { return /* binding */ canMergeBlocks; },
/* harmony export */   "checkAbortSignal": function() { return /* binding */ checkAbortSignal; },
/* harmony export */   "longToNumber": function() { return /* binding */ longToNumber; },
/* harmony export */   "optimizeChunks": function() { return /* binding */ optimizeChunks; }
/* harmony export */ });
function longToNumber(long) {
    if (long.greaterThan(Number.MAX_SAFE_INTEGER) ||
        long.lessThan(Number.MIN_SAFE_INTEGER)) {
        throw new Error('integer overflow');
    }
    return long.toNumber();
}
class AbortError extends Error {
}
/**
 * Properly check if the given AbortSignal is aborted.
 * Per the standard, if the signal reads as aborted,
 * this function throws either a DOMException AbortError, or a regular error
 * with a `code` attribute set to `ERR_ABORTED`.
 *
 * For convenience, passing `undefined` is a no-op
 *
 * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute
 * @returns nothing
 */
function checkAbortSignal(signal) {
    if (!signal) {
        return;
    }
    if (signal.aborted) {
        // console.log('bam aborted!')
        if (typeof DOMException !== 'undefined') {
            // eslint-disable-next-line  no-undef
            throw new DOMException('aborted', 'AbortError');
        }
        else {
            const e = new AbortError('aborted');
            e.code = 'ERR_ABORTED';
            throw e;
        }
    }
}
/**
 * Skips to the next tick, then runs `checkAbortSignal`.
 * Await this to inside an otherwise synchronous loop to
 * provide a place to break when an abort signal is received.
 * @param {AbortSignal} signal
 */
async function abortBreakPoint(signal) {
    await Promise.resolve();
    checkAbortSignal(signal);
}
function canMergeBlocks(chunk1, chunk2) {
    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&
        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);
}
function optimizeChunks(chunks, lowest) {
    const mergedChunks = [];
    let lastChunk = null;
    if (chunks.length === 0) {
        return chunks;
    }
    chunks.sort(function (c0, c1) {
        const dif = c0.minv.blockPosition - c1.minv.blockPosition;
        if (dif !== 0) {
            return dif;
        }
        else {
            return c0.minv.dataPosition - c1.minv.dataPosition;
        }
    });
    chunks.forEach(chunk => {
        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {
            if (lastChunk === null) {
                mergedChunks.push(chunk);
                lastChunk = chunk;
            }
            else {
                if (canMergeBlocks(lastChunk, chunk)) {
                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {
                        lastChunk.maxv = chunk.maxv;
                    }
                }
                else {
                    mergedChunks.push(chunk);
                    lastChunk = chunk;
                }
            }
        }
        // else {
        //   console.log(`skipping chunk ${chunk}`)
        // }
    });
    return mergedChunks;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@gmod/tabix/esm/virtualOffset.js":
/*!*******************************************************!*\
  !*** ./node_modules/@gmod/tabix/esm/virtualOffset.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ VirtualOffset; },
/* harmony export */   "fromBytes": function() { return /* binding */ fromBytes; }
/* harmony export */ });
class VirtualOffset {
    constructor(blockPosition, dataPosition) {
        this.blockPosition = blockPosition; // < offset of the compressed data block
        this.dataPosition = dataPosition; // < offset into the uncompressed data
    }
    toString() {
        return `${this.blockPosition}:${this.dataPosition}`;
    }
    compareTo(b) {
        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);
    }
    static min(...args) {
        let min;
        let i = 0;
        for (; !min; i += 1) {
            min = args[i];
        }
        for (; i < args.length; i += 1) {
            if (min.compareTo(args[i]) > 0) {
                min = args[i];
            }
        }
        return min;
    }
}
function fromBytes(bytes, offset = 0, bigendian = false) {
    if (bigendian) {
        throw new Error('big-endian virtual file offsets not implemented');
    }
    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +
        bytes[offset + 6] * 0x100000000 +
        bytes[offset + 5] * 0x1000000 +
        bytes[offset + 4] * 0x10000 +
        bytes[offset + 3] * 0x100 +
        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);
}
//# sourceMappingURL=virtualOffset.js.map

/***/ }),

/***/ "./node_modules/@gmod/tabix/node_modules/quick-lru/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@gmod/tabix/node_modules/quick-lru/index.js ***!
  \******************************************************************/
/***/ (function(module) {



class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;
			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return this._size + oldCacheSize;
	}
}

module.exports = QuickLRU;


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_gmod_tabix_esm_index_js.bundle.js.map