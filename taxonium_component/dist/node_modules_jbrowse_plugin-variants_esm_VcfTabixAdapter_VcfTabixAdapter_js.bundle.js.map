{"version":3,"file":"node_modules_jbrowse_plugin-variants_esm_VcfTabixAdapter_VcfTabixAdapter_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAkF;AAC7B;AACA;AACM;AACZ;AACb;AAC2B;AACvB;AACtC,+DAAe,cAAc,2FAAsB;AACnD;AACA,8BAA8B,2EAAc;AAC5C,yBAAyB,2EAAc;AACvC,0BAA0B,2EAAc;AACxC,2BAA2B,mEAAY;AACvC;AACA,wBAAwB,yDAAgB;AACxC;AACA;AACA,kBAAkB,mEAAY;AAC9B;AACA;AACA,kBAAkB,mEAAY;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,iDAAS,GAAG,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B;AAC/B,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,gCAAgC;AAChC,eAAe,yEAAgB;AAC/B,oBAAoB,sBAAsB;AAC1C,oBAAoB,cAAc;AAClC;AACA;AACA,sCAAsC,mDAAU;AAChD;AACA;AACA,+BAA+B,QAAQ,OAAO,WAAW;AACzD,qBAAqB;AACrB,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,eAAe,yEAAgB;AAC/B,oBAAoB,MAAM;AAC1B;AACA,gCAAgC,mEAAe;AAC/C,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,IAAI;AAC1E;AACA;AACA,SAAS;AACT;AACA,wBAAwB,SAAS;AACjC,CAAC;AACD;;;;;;;;;;ACzGA;;;;;;;;;;ACAA","sources":["webpack://taxonium/./node_modules/@jbrowse/plugin-variants/esm/VcfTabixAdapter/VcfTabixAdapter.js","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|./localFile","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|file-uri-to-path"],"sourcesContent":["import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { bytesForRegions } from '@jbrowse/core/util';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { TabixIndexedFile } from '@gmod/tabix';\nimport VcfParser from '@gmod/vcf';\nimport { readConfObject } from '@jbrowse/core/configuration';\nimport VcfFeature from './VcfFeature';\nexport default class extends BaseFeatureDataAdapter {\n    async configurePre() {\n        const vcfGzLocation = readConfObject(this.config, 'vcfGzLocation');\n        const location = readConfObject(this.config, ['index', 'location']);\n        const indexType = readConfObject(this.config, ['index', 'indexType']);\n        const filehandle = openLocation(vcfGzLocation, this.pluginManager);\n        const isCSI = indexType === 'CSI';\n        const vcf = new TabixIndexedFile({\n            filehandle,\n            csiFilehandle: isCSI\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            tbiFilehandle: !isCSI\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n            chunkSizeLimit: 1000000000,\n        });\n        const header = await vcf.getHeader();\n        return {\n            filehandle,\n            vcf,\n            parser: new VcfParser({ header }),\n        };\n    }\n    async configure() {\n        if (!this.configured) {\n            this.configured = this.configurePre().catch(e => {\n                this.configured = undefined;\n                throw e;\n            });\n        }\n        return this.configured;\n    }\n    async getRefNames(opts = {}) {\n        const { vcf } = await this.configure();\n        return vcf.getReferenceSequenceNames(opts);\n    }\n    async getHeader() {\n        const { vcf } = await this.configure();\n        return vcf.getHeader();\n    }\n    async getMetadata() {\n        const { parser } = await this.configure();\n        return parser.getMetadata();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { refName, start, end } = query;\n            const { vcf, parser } = await this.configure();\n            await vcf.getLines(refName, start, end, {\n                lineCallback: (line, fileOffset) => {\n                    observer.next(new VcfFeature({\n                        variant: parser.parseLine(line),\n                        parser,\n                        id: `${this.id}-vcf-${fileOffset}`,\n                    }));\n                },\n                ...opts,\n            });\n            observer.complete();\n        }, opts.signal);\n    }\n    /**\n     * Checks if the data source has data for the given reference sequence,\n     * and then gets the features in the region if it does\n     *\n     * Currently this just calls getFeatureInRegion for each region. Adapters that\n     * are frequently called on multiple regions simultaneously may want to\n     * implement a more efficient custom version of this method.\n     *\n     * Also includes a bit of extra logging to warn when fetching a large portion\n     * of a VCF\n     * @param regions - Regions\n     * @param opts - Feature adapter options\n     * @returns Observable of Feature objects in the regions\n     */\n    getFeaturesInMultipleRegions(regions, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { vcf } = await this.configure();\n            // @ts-ignore\n            const bytes = await bytesForRegions(regions, vcf.index);\n            const { filehandle } = await this.configure();\n            const stat = await filehandle.stat();\n            let pct = Math.round((bytes / stat.size) * 100);\n            if (pct > 100) {\n                // this is just a bad estimate, make 100% if it goes over\n                pct = 100;\n            }\n            if (pct > 60) {\n                console.warn(`getFeaturesInMultipleRegions fetching ${pct}% of VCF file, but whole-file streaming not yet implemented`);\n            }\n            super.getFeaturesInMultipleRegions(regions, opts).subscribe(observer);\n        });\n    }\n    freeResources( /* { region } */) { }\n}\n//# sourceMappingURL=VcfTabixAdapter.js.map","/* (ignored) */","/* (ignored) */"],"names":[],"sourceRoot":""}