"use strict";
(self["webpackChunktaxonium"] = self["webpackChunktaxonium"] || []).push([["vendors-node_modules_jbrowse_plugin-legacy-jbrowse_esm_NCListAdapter_NCListAdapter_js"],{

/***/ "./node_modules/@gmod/nclist/esm/array_representation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@gmod/nclist/esm/array_representation.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
//@ts-nocheck
/**
 * @class ArrayRepr
 *
 * Class for operating on indexed array representations of objects.
 *
 * For example, if we have a lot of objects with similar attrbutes, e.g.:
 *
 * <pre class="code">
 *     [
 *         {start: 1, end: 2, strand: -1},
 *         {start: 5, end: 6, strand: 1},
 *         ...
 *     ]
 * </pre>
 *
 * @description
 * we can represent them more compactly (e.g., in JSON) something like this:
 *
 * <pre class="code">
 *     class = ["start", "end", "strand"]
 *     [
 *         [1, 2, -1],
 *         [5, 6, 1],
 *         ...
 *     ]
 * </pre>
 *
 * If we want to represent a few different kinds of objects in our big list,
 * we can have multiple "class" arrays, and tag each object to identify
 * which "class" array describes it.
 *
 * For example, if we have a lot of instances of a few types of objects,
 * like this:
 *
 * <pre class="code">
 *     [
 *         {start: 1, end: 2, strand: 1, id: 1},
 *         {start: 5, end: 6, strand: 1, id: 2},
 *         ...
 *         {start: 10, end: 20, chunk: 1},
 *         {start: 30, end: 40, chunk: 2},
 *         ...
 *     ]
 * </pre>
 *
 * We could use the first array position to indicate the "class" for the
 * object, like this:
 *
 * <pre class="code">
 *     classes = [["start", "end", "strand", "id"], ["start", "end", "chunk"]]
 *     [
 *         [0, 1, 2, 1, 1],
 *         [0, 5, 6, 1, 2],
 *         ...
 *         [1, 10, 20, 1],
 *         [1, 30, 40, 1]
 *     ]
 * </pre>
 *
 * Also, if we occasionally want to add an ad-hoc attribute, we could just
 * stick an optional dictionary onto the end:
 *
 * <pre class="code">
 *     classes = [["start", "end", "strand", "id"], ["start", "end", "chunk"]]
 *     [
 *         [0, 1, 2, 1, 1],
 *         [0, 5, 6, 1, 2, {foo: 1}]
 *     ]
 * </pre>
 *
 * Given that individual objects are being represented by arrays, generic
 * code needs some way to differentiate arrays that are meant to be objects
 * from arrays that are actually meant to be arrays.
 * So for each class, we include a dict with <attribute name>: true mappings
 * for each attribute that is meant to be an array.
 *
 * Also, in cases where some attribute values are the same for all objects
 * in a particular set, it may be convenient to define a "prototype"
 * with default values for all objects in the set
 *
 * In the end, we get something like this:
 *
 * <pre class="code">
 *     classes=[
 *         {'attributes': ['Start', 'End', 'Subfeatures'],
 *          'proto': {'Chrom': 'chr1'},
 *          'isArrayAttr': {Subfeatures: true}}
 *         ]
 * </pre>
 *
 * That's what this class facilitates.
 */
class ArrayRepr {
    constructor(classes) {
        this.classes = classes;
        this.fields = [];
        for (let cl = 0; cl < classes.length; cl += 1) {
            this.fields[cl] = {};
            for (let f = 0; f < classes[cl].attributes.length; f += 1) {
                this.fields[cl][classes[cl].attributes[f]] = f + 1;
            }
            if (classes[cl].proto === undefined) {
                classes[cl].proto = {};
            }
            if (classes[cl].isArrayAttr === undefined) {
                classes[cl].isArrayAttr = {};
            }
        }
    }
    /**
     * @private
     */
    attrIndices(attr) {
        return this.classes.map(x => x.attributes.indexOf(attr) + 1 ||
            x.attributes.indexOf(attr.toLowerCase()) + 1 ||
            undefined);
    }
    get(obj, attr) {
        if (attr in this.fields[obj[0]]) {
            return obj[this.fields[obj[0]][attr]];
        }
        // try lowercase
        const lcattr = attr.toLowerCase();
        if (lcattr in this.fields[obj[0]]) {
            return obj[this.fields[obj[0]][lcattr]];
        }
        const adhocIndex = this.classes[obj[0]].attributes.length + 1;
        if (adhocIndex >= obj.length || !(attr in obj[adhocIndex])) {
            if (attr in this.classes[obj[0]].proto) {
                return this.classes[obj[0]].proto[attr];
            }
            return undefined;
        }
        return obj[adhocIndex][attr];
    }
    makeSetter(attr) {
        return (obj, val) => {
            this.set(obj, attr, val);
        };
    }
    makeGetter(attr) {
        return obj => {
            return this.get(obj, attr);
        };
    }
    makeFastGetter(attr) {
        // can be used only if attr is guaranteed to be in
        // the "classes" array for this object
        const indices = this.attrIndices(attr);
        return function get(obj) {
            if (indices[obj[0]] !== undefined) {
                return obj[indices[obj[0]]];
            }
            return undefined;
        };
    }
    // construct(self, obj, klass) {
    //   const result = new Array(self.classes[klass].length)
    //   Object.keys(obj).forEach(attr => {
    //     this.set(result, attr, obj[attr])
    //   })
    //   return result
    // }
    /**
     * Returns fast pre-compiled getter and setter functions for use with
     * Arrays that use this representation.
     * When the returned <code>get</code> and <code>set</code> functions are
     * added as methods to an Array that contains data in this
     * representation, they provide fast access by name to the data.
     *
     * @returns {Object} <code>{ get: function() {...}, set: function(val) {...} }</code>
     *
     * @example
     * var accessors = attrs.accessors();
     * var feature = get_feature_from_someplace();
     * feature.get = accessors.get;
     * // print out the feature start and end
     * console.log( feature.get('start') + ',' + feature.get('end') );
     */
    accessors() {
        if (!this._accessors) {
            this._accessors = this._makeAccessors();
        }
        return this._accessors;
    }
    /**
     * @private
     */
    _makeAccessors() {
        const indices = {};
        const accessors = {
            get(field) {
                const f = this.get.field_accessors[field.toLowerCase()];
                if (f) {
                    return f.call(this);
                }
                return undefined;
            },
            set(field, val) {
                const f = this.set.field_accessors[field];
                if (f) {
                    return f.call(this, val);
                }
                return undefined;
            },
            tags() {
                return tags[this[0]] || [];
            },
        };
        accessors.get.field_accessors = {};
        accessors.set.field_accessors = {};
        // make a data structure as: { attr_name: [offset,offset,offset], }
        // that will be convenient for finding the location of the attr
        // for a given class like: indexForAttr{attrname}[classnum]
        this.classes.forEach((cdef, classnum) => {
            ;
            (cdef.attributes || []).forEach((attrname, offset) => {
                indices[attrname] = indices[attrname] || [];
                indices[attrname][classnum] = offset + 1;
                attrname = attrname.toLowerCase();
                indices[attrname] = indices[attrname] || [];
                indices[attrname][classnum] = offset + 1;
            });
        });
        // lowercase all the class attributes
        const tags = this.classes.map(c => c.attributes);
        // use that to make precalculated get and set accessors for each field
        Object.keys(indices).forEach(attrname => {
            const attrIndices = indices[attrname];
            // get
            accessors.get.field_accessors[attrname] = !attrIndices
                ? function get() {
                    return undefined;
                }
                : function get() {
                    return this[attrIndices[this[0]]];
                };
            // // set
            // accessors.set.field_accessors[attrname] = !attrIndices
            //   ? () => undefined
            //   : v => {
            //       this[attrIndices[this[0]]] = v
            //       return v
            //     }
        });
        return accessors;
    }
}
/* harmony default export */ __webpack_exports__["default"] = (ArrayRepr);
/*

Copyright (c) 2007-2010 The Evolutionary Software Foundation

Created by Mitchell Skinner <mitch_skinner@berkeley.edu>

This package and its accompanying libraries are free software; you can
redistribute it and/or modify it under the terms of the LGPL (either
version 2.1, or at your option, any later version) or the Artistic
License 2.0.  Refer to LICENSE for the full license text.

*/
//# sourceMappingURL=array_representation.js.map

/***/ }),

/***/ "./node_modules/@gmod/nclist/esm/feature_store.js":
/*!********************************************************!*\
  !*** ./node_modules/@gmod/nclist/esm/feature_store.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ NCListStore; }
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! quick-lru */ "./node_modules/@gmod/nclist/node_modules/quick-lru/index.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(quick_lru__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abortable-promise-cache */ "./node_modules/abortable-promise-cache/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _nclist__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nclist */ "./node_modules/@gmod/nclist/esm/nclist.js");
/* harmony import */ var _array_representation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array_representation */ "./node_modules/@gmod/nclist/esm/array_representation.js");
/* harmony import */ var _lazy_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lazy_array */ "./node_modules/@gmod/nclist/esm/lazy_array.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/nclist/esm/util.js");
//@ts-nocheck







function idfunc() {
    return this._uniqueID;
}
function parentfunc() {
    return this._parent;
}
function childrenfunc() {
    return this.get('subfeatures');
}
/**
 * Sequence feature store using nested containment
 * lists held in JSON files that are lazily read.
 *
 * @param {object} args constructor args
 * @param {string} args.baseUrl base URL for resolving relative URLs
 * @param {string} args.urlTemplate Template string for
 *  the root file of each reference sequence. The reference sequence
 *  name will be interpolated into this string where `{refseq}` appears.
 * @param {function} args.readFile function to use for reading remote from URLs.
 */
class NCListStore {
    constructor({ baseUrl, urlTemplate, readFile, cacheSize = 10 }) {
        this.baseUrl = baseUrl;
        this.urlTemplates = { root: urlTemplate };
        this.readFile = readFile;
        if (!this.readFile) {
            throw new Error(`must provide a "readFile" function argument`);
        }
        this.dataRootCache = new (abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2___default())({
            cache: new (quick_lru__WEBPACK_IMPORTED_MODULE_1___default())({ maxSize: cacheSize }),
            fill: this.fetchDataRoot.bind(this),
        });
    }
    makeNCList() {
        return new _nclist__WEBPACK_IMPORTED_MODULE_3__["default"]({ readFile: this.readFile });
    }
    loadNCList(refData, trackInfo, listUrl) {
        refData.nclist.importExisting(trackInfo.intervals.nclist, refData.attrs, listUrl, trackInfo.intervals.urlTemplate, trackInfo.intervals.lazyClass);
    }
    getDataRoot(refName) {
        return this.dataRootCache.get(refName, refName);
    }
    fetchDataRoot(refName) {
        const url = url__WEBPACK_IMPORTED_MODULE_0__.resolve(this.baseUrl, this.urlTemplates.root.replace(/{\s*refseq\s*}/g, refName));
        // fetch the trackdata
        return (0,_util__WEBPACK_IMPORTED_MODULE_6__.readJSON)(url, this.readFile).then(trackInfo => 
        // trackInfo = JSON.parse( trackInfo );
        this.parseTrackInfo(trackInfo, url));
    }
    parseTrackInfo(trackInfo, url) {
        const refData = {
            nclist: this.makeNCList(),
            stats: {
                featureCount: trackInfo.featureCount || 0,
            },
        };
        if (trackInfo.intervals) {
            refData.attrs = new _array_representation__WEBPACK_IMPORTED_MODULE_4__["default"](trackInfo.intervals.classes);
            this.loadNCList(refData, trackInfo, url);
        }
        const { histograms } = trackInfo;
        if (histograms && histograms.meta) {
            for (let i = 0; i < histograms.meta.length; i += 1) {
                histograms.meta[i].lazyArray = new _lazy_array__WEBPACK_IMPORTED_MODULE_5__["default"]({ ...histograms.meta[i].arrayParams, readFile: this.readFile }, url);
            }
            refData._histograms = histograms;
        }
        // parse any strings in the histogram data that look like numbers
        if (refData._histograms) {
            Object.keys(refData._histograms).forEach(key => {
                const entries = refData._histograms[key];
                entries.forEach(entry => {
                    Object.keys(entry).forEach(key2 => {
                        if (typeof entry[key2] === 'string' &&
                            String(Number(entry[key2])) === entry[key2]) {
                            entry[key2] = Number(entry[key2]);
                        }
                    });
                });
            });
        }
        return refData;
    }
    async getRegionStats(query) {
        const data = await this.getDataRoot(query.ref);
        return data.stats;
    }
    /**
     * fetch binned counts of feature coverage in the given region.
     *
     * @param {object} query
     * @param {string} query.refName reference sequence name
     * @param {number} query.start region start
     * @param {number} query.end region end
     * @param {number} query.numBins number of bins desired in the feature counts
     * @param {number} query.basesPerBin number of bp desired in each feature counting bin
     * @returns {object} as:
     *    `{ bins: hist, stats: statEntry }`
     */
    async getRegionFeatureDensities({ refName, start, end, numBins, basesPerBin, }) {
        const data = await this.getDataRoot(refName);
        if (numBins) {
            basesPerBin = (end - start) / numBins;
        }
        else if (basesPerBin) {
            numBins = Math.ceil((end - start) / basesPerBin);
        }
        else {
            throw new TypeError('numBins or basesPerBin arg required for getRegionFeatureDensities');
        }
        // pick the relevant entry in our pre-calculated stats
        const stats = data._histograms.stats || [];
        const statEntry = stats.find(entry => entry.basesPerBin >= basesPerBin);
        // The histogramMeta array describes multiple levels of histogram detail,
        // going from the finest (smallest number of bases per bin) to the
        // coarsest (largest number of bases per bin).
        // We want to use coarsest histogramMeta that's at least as fine as the
        // one we're currently rendering.
        // TODO: take into account that the histogramMeta chosen here might not
        // fit neatly into the current histogram (e.g., if the current histogram
        // is at 50,000 bases/bin, and we have server histograms at 20,000
        // and 2,000 bases/bin, then we should choose the 2,000 histogramMeta
        // rather than the 20,000)
        let histogramMeta = data._histograms.meta[0];
        for (let i = 0; i < data._histograms.meta.length; i += 1) {
            if (basesPerBin >= data._histograms.meta[i].basesPerBin) {
                histogramMeta = data._histograms.meta[i];
            }
        }
        // number of bins in the server-supplied histogram for each current bin
        let binRatio = basesPerBin / histogramMeta.basesPerBin;
        // if the server-supplied histogram fits neatly into our requested
        if (binRatio > 0.9 && Math.abs(binRatio - Math.round(binRatio)) < 0.0001) {
            // console.log('server-supplied',query);
            // we can use the server-supplied counts
            const firstServerBin = Math.floor(start / histogramMeta.basesPerBin);
            binRatio = Math.round(binRatio);
            const histogram = [];
            for (let bin = 0; bin < numBins; bin += 1) {
                histogram[bin] = 0;
            }
            for await (const [i, val] of histogramMeta.lazyArray.range(firstServerBin, firstServerBin + binRatio * numBins - 1)) {
                // this will count features that span the boundaries of
                // the original histogram multiple times, so it's not
                // perfectly quantitative.  Hopefully it's still useful, though.
                histogram[Math.floor((i - firstServerBin) / binRatio)] += val;
            }
            return { bins: histogram, stats: statEntry };
        }
        // console.log('make own',query);
        // make our own counts
        const hist = await data.nclist.histogram(start, end, numBins);
        return { bins: hist, stats: statEntry };
    }
    /**
     * Fetch features in a given region. This method is an asynchronous generator
     * yielding feature objects.
     *
     * @param {object} args
     * @param {string} args.refName reference sequence name
     * @param {number} args.start start of region. 0-based half-open.
     * @param {number} args.end end of region. 0-based half-open.
     * @yields {object}
     */
    async *getFeatures({ refName, start, end }) {
        const data = await this.getDataRoot(refName);
        const accessors = data.attrs && data.attrs.accessors();
        for await (const [feature, path] of data.nclist.iterate(start, end)) {
            // the unique ID is a stringification of the path in the
            // NCList where the feature lives; it's unique across the
            // top-level NCList (the top-level NCList covers a
            // track/chromosome combination)
            // only need to decorate a feature once
            if (!feature.decorated) {
                const uniqueID = path.join(',');
                this.decorateFeature(accessors, feature, `${refName},${uniqueID}`);
            }
            yield feature;
        }
    }
    // helper method to recursively add .get and .tags methods to a feature and its
    // subfeatures
    decorateFeature(accessors, feature, id, parent) {
        feature.get = accessors.get;
        feature.tags = accessors.tags;
        feature._uniqueID = id;
        feature.id = idfunc;
        feature._parent = parent;
        feature.parent = parentfunc;
        feature.children = childrenfunc;
        (feature.get('subfeatures') || []).forEach((f, i) => {
            this.decorateFeature(accessors, f, `${id}-${i}`, feature);
        });
        feature.decorated = true;
    }
}
//# sourceMappingURL=feature_store.js.map

/***/ }),

/***/ "./node_modules/@gmod/nclist/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@gmod/nclist/esm/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _feature_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature_store */ "./node_modules/@gmod/nclist/esm/feature_store.js");
//@ts-nocheck

/* harmony default export */ __webpack_exports__["default"] = (_feature_store__WEBPACK_IMPORTED_MODULE_0__["default"]);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@gmod/nclist/esm/lazy_array.js":
/*!*****************************************************!*\
  !*** ./node_modules/@gmod/nclist/esm/lazy_array.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LazyArray; }
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! quick-lru */ "./node_modules/@gmod/nclist/node_modules/quick-lru/index.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(quick_lru__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abortable-promise-cache */ "./node_modules/abortable-promise-cache/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/nclist/esm/util.js");
//@ts-nocheck




/**
 * For a JSON array that gets too large to load in one go, this class
 * helps break it up into chunks and provides an
 * async API for using the information in the array.
 */
class LazyArray {
    constructor({ urlTemplate, chunkSize, length, cacheSize = 100, readFile }, baseUrl) {
        this.urlTemplate = urlTemplate;
        this.chunkSize = chunkSize;
        this.length = length;
        this.baseUrl = baseUrl === undefined ? '' : baseUrl;
        this.readFile = readFile;
        if (!readFile) {
            throw new Error('must provide readFile callback');
        }
        this.chunkCache = new (abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2___default())({
            cache: new (quick_lru__WEBPACK_IMPORTED_MODULE_1___default())({ maxSize: cacheSize }),
            fill: this.getChunk.bind(this),
        });
    }
    /**
     * call the callback on one element of the array
     * @param i index
     * @param callback callback, gets called with (i, value, param)
     * @param param (optional) callback will get this as its last parameter
     */
    index(i, callback, param) {
        this.range(i, i, callback, undefined, param);
    }
    /**
     * async generator for the elements in the range [start,end]
     *
     * @param start index of first element to call the callback on
     * @param end index of last element to call the callback on
     */
    async *range(start, end) {
        start = Math.max(0, start);
        end = Math.min(end, this.length - 1);
        const firstChunk = Math.floor(start / this.chunkSize);
        const lastChunk = Math.floor(end / this.chunkSize);
        const chunkreadFiles = [];
        for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {
            chunkreadFiles.push(this.chunkCache.get(chunk, chunk));
        }
        for (let i = 0; i < chunkreadFiles.length; i += 1) {
            const [chunkNumber, chunkData] = await chunkreadFiles[i];
            yield* this.filterChunkData(start, end, chunkNumber, chunkData);
        }
    }
    async getChunk(chunkNumber) {
        let url = this.urlTemplate.replace(/\{Chunk\}/gi, chunkNumber);
        if (this.baseUrl) {
            url = url__WEBPACK_IMPORTED_MODULE_0__.resolve(this.baseUrl, url);
        }
        const data = await (0,_util__WEBPACK_IMPORTED_MODULE_3__.readJSON)(url, this.readFile);
        return [chunkNumber, data];
    }
    *filterChunkData(queryStart, queryEnd, chunkNumber, chunkData) {
        // index (in the overall lazy array) of the first position in this chunk
        const firstIndex = chunkNumber * this.chunkSize;
        const chunkStart = Math.max(0, queryStart - firstIndex);
        const chunkEnd = Math.min(queryEnd - firstIndex, this.chunkSize - 1);
        for (let i = chunkStart; i <= chunkEnd; i += 1) {
            yield [i + firstIndex, chunkData[i]];
        }
    }
}
//# sourceMappingURL=lazy_array.js.map

/***/ }),

/***/ "./node_modules/@gmod/nclist/esm/nclist.js":
/*!*************************************************!*\
  !*** ./node_modules/@gmod/nclist/esm/nclist.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ NCList; }
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! quick-lru */ "./node_modules/@gmod/nclist/node_modules/quick-lru/index.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(quick_lru__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abortable-promise-cache */ "./node_modules/abortable-promise-cache/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/nclist/esm/util.js");
//@ts-nocheck




class NCList {
    constructor({ readFile, cacheSize = 100 }) {
        this.topList = [];
        this.chunkCache = new (abortable_promise_cache__WEBPACK_IMPORTED_MODULE_2___default())({
            cache: new (quick_lru__WEBPACK_IMPORTED_MODULE_1___default())({ maxSize: cacheSize }),
            fill: this.readChunkItems.bind(this),
        });
        this.readFile = readFile;
        if (!this.readFile) {
            throw new Error(`must provide a "readFile" function`);
        }
    }
    importExisting(nclist, attrs, baseURL, lazyUrlTemplate, lazyClass) {
        this.topList = nclist;
        this.attrs = attrs;
        this.start = attrs.makeFastGetter('Start');
        this.end = attrs.makeFastGetter('End');
        this.lazyClass = lazyClass;
        this.baseURL = baseURL;
        this.lazyUrlTemplate = lazyUrlTemplate;
    }
    binarySearch(arr, item, getter) {
        let low = -1;
        let high = arr.length;
        let mid;
        while (high - low > 1) {
            mid = (low + high) >>> 1;
            if (getter(arr[mid]) >= item) {
                high = mid;
            }
            else {
                low = mid;
            }
        }
        // if we're iterating rightward, return the high index;
        // if leftward, the low index
        if (getter === this.end) {
            return high;
        }
        return low;
    }
    readChunkItems(chunkNum) {
        const url = url__WEBPACK_IMPORTED_MODULE_0__.resolve(this.baseURL, this.lazyUrlTemplate.replace(/\{Chunk\}/gi, chunkNum));
        return (0,_util__WEBPACK_IMPORTED_MODULE_3__.readJSON)(url, this.readFile, { defaultContent: [] });
    }
    async *iterateSublist(arr, from, to, inc, searchGet, testGet, path) {
        const getChunk = this.attrs.makeGetter('Chunk');
        const getSublist = this.attrs.makeGetter('Sublist');
        const pendingPromises = [];
        for (let i = this.binarySearch(arr, from, searchGet); i < arr.length && i >= 0 && inc * testGet(arr[i]) < inc * to; i += inc) {
            if (arr[i][0] === this.lazyClass) {
                // this is a lazily-loaded chunk of the nclist
                const chunkNum = getChunk(arr[i]);
                const chunkItemsP = this.chunkCache
                    .get(chunkNum, chunkNum)
                    .then(item => [item, chunkNum]);
                pendingPromises.push(chunkItemsP);
            }
            else {
                // this is just a regular feature
                yield [arr[i], path.concat(i)];
            }
            // if this node has a contained sublist, process that too
            const sublist = getSublist(arr[i]);
            if (sublist) {
                yield* this.iterateSublist(sublist, from, to, inc, searchGet, testGet, path.concat(i));
            }
        }
        for (let i = 0; i < pendingPromises.length; i += 1) {
            const [item, chunkNum] = await pendingPromises[i];
            if (item) {
                yield* this.iterateSublist(item, from, to, inc, searchGet, testGet, [
                    ...path,
                    chunkNum,
                ]);
            }
        }
    }
    async *iterate(from, to) {
        // calls the given function once for each of the
        // intervals that overlap the given interval
        // if from <= to, iterates left-to-right, otherwise iterates right-to-left
        // inc: iterate leftward or rightward
        const inc = from > to ? -1 : 1;
        // searchGet: search on start or end
        const searchGet = from > to ? this.start : this.end;
        // testGet: test on start or end
        const testGet = from > to ? this.end : this.start;
        if (this.topList.length > 0) {
            yield* this.iterateSublist(this.topList, from, to, inc, searchGet, testGet, [0]);
        }
    }
    async histogram(from, to, numBins) {
        // calls callback with a histogram of the feature density
        // in the given interval
        const result = new Array(numBins);
        result.fill(0);
        const binWidth = (to - from) / numBins;
        for await (const feat of this.iterate(from, to)) {
            const firstBin = Math.max(0, ((this.start(feat) - from) / binWidth) | 0);
            const lastBin = Math.min(numBins, ((this.end(feat) - from) / binWidth) | 0);
            for (let bin = firstBin; bin <= lastBin; bin += 1) {
                result[bin] += 1;
            }
        }
        return result;
    }
}
//# sourceMappingURL=nclist.js.map

/***/ }),

/***/ "./node_modules/@gmod/nclist/esm/util.js":
/*!***********************************************!*\
  !*** ./node_modules/@gmod/nclist/esm/util.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "foo": function() { return /* binding */ foo; },
/* harmony export */   "readJSON": function() { return /* binding */ readJSON; }
/* harmony export */ });
//@ts-nocheck
async function readJSON(url, readFile, options = {}) {
    const { defaultContent = {} } = options;
    let str;
    try {
        str = await readFile(url, { encoding: 'utf8' });
        return JSON.parse(str);
    }
    catch (error) {
        if (error.code === 'ENOENT' || error.status === 404) {
            return defaultContent;
        }
        throw error;
    }
}
function foo() { }
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@gmod/nclist/node_modules/quick-lru/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@gmod/nclist/node_modules/quick-lru/index.js ***!
  \*******************************************************************/
/***/ (function(module) {



class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;
			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return this._size + oldCacheSize;
	}
}

module.exports = QuickLRU;


/***/ }),

/***/ "./node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListAdapter.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListAdapter.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ NCListAdapter; }
/* harmony export */ });
/* harmony import */ var _gmod_nclist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @gmod/nclist */ "./node_modules/@gmod/nclist/esm/index.js");
/* harmony import */ var _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jbrowse/core/data_adapters/BaseAdapter */ "./node_modules/@jbrowse/core/data_adapters/BaseAdapter.js");
/* harmony import */ var _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jbrowse_core_util_rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jbrowse/core/util/rxjs */ "./node_modules/@jbrowse/core/util/rxjs.js");
/* harmony import */ var _jbrowse_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jbrowse/core/util */ "./node_modules/@jbrowse/core/util/index.js");
/* harmony import */ var _jbrowse_core_util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_util__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var generic_filehandle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! generic-filehandle */ "./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/index.js");
/* harmony import */ var _jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jbrowse/core/configuration */ "./node_modules/@jbrowse/core/configuration/index.js");
/* harmony import */ var _jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _NCListFeature__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./NCListFeature */ "./node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListFeature.js");







class NCListAdapter extends _jbrowse_core_data_adapters_BaseAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseFeatureDataAdapter {
    constructor(config, getSubAdapter, pluginManager) {
        super(config, getSubAdapter, pluginManager);
        const refNames = (0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(config, 'refNames');
        const rootUrlTemplate = (0,_jbrowse_core_configuration__WEBPACK_IMPORTED_MODULE_5__.readConfObject)(config, 'rootUrlTemplate');
        this.configRefNames = refNames;
        this.nclist = new _gmod_nclist__WEBPACK_IMPORTED_MODULE_0__["default"]({
            baseUrl: '',
            urlTemplate: rootUrlTemplate.uri,
            readFile: (url) => new generic_filehandle__WEBPACK_IMPORTED_MODULE_4__.RemoteFile(String(rootUrlTemplate.baseUri
                ? new URL(url, rootUrlTemplate.baseUri).toString()
                : url)).readFile(),
        });
    }
    /**
     * Fetch features for a certain region. Use getFeaturesInRegion() if you also
     * want to verify that the store has features for the given reference sequence
     * before fetching.
     * @param region -
     * @param opts - [signal] optional signalling object for aborting the fetch
     * @returns Observable of Feature objects in the region
     */
    getFeatures(region, opts = {}) {
        return (0,_jbrowse_core_util_rxjs__WEBPACK_IMPORTED_MODULE_2__.ObservableCreate)(async (observer) => {
            const { signal } = opts;
            for await (const feature of this.nclist.getFeatures(region, opts)) {
                (0,_jbrowse_core_util__WEBPACK_IMPORTED_MODULE_3__.checkAbortSignal)(signal);
                observer.next(this.wrapFeature(feature));
            }
            observer.complete();
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    wrapFeature(ncFeature) {
        return new _NCListFeature__WEBPACK_IMPORTED_MODULE_6__["default"](ncFeature, undefined, `${this.id}-${ncFeature.id()}`);
    }
    async hasDataForRefName(refName) {
        const root = await this.nclist.getDataRoot(refName);
        return !!(root && root.stats && root.stats.featureCount);
    }
    /*
     * NCList is unable to get list of ref names so returns empty
     * @return Promise<string[]> of empty list
     */
    getRefNames() {
        return Promise.resolve(this.configRefNames || []);
    }
    /**
     * called to provide a hint that data tied to a certain region
     * will not be needed for the forseeable future and can be purged
     * from caches, etc
     */
    freeResources() { }
}
//# sourceMappingURL=NCListAdapter.js.map

/***/ }),

/***/ "./node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListFeature.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListFeature.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ NCListFeature; }
/* harmony export */ });
const jb2ToJb1 = { refName: 'seq_id' };
const jb1ToJb2 = { seq_id: 'refName' };
/**
 * wrapper to adapt nclist features to act like jbrowse 2 features
 */
class NCListFeature {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(ncFeature, parent, id) {
        this.ncFeature = ncFeature;
        this.uniqueId = id || ncFeature.id();
        this.parentHandle = parent;
    }
    set() {
        throw new Error('not implemented');
    }
    jb2TagToJb1Tag(tag) {
        // @ts-ignore
        const mapped = jb2ToJb1[tag] || tag;
        return mapped.toLowerCase();
    }
    jb1TagToJb2Tag(tag) {
        const t = tag.toLowerCase();
        // @ts-ignore
        const mapped = jb1ToJb2[t] || t;
        return mapped;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get(attrName) {
        const attr = this.ncFeature.get(this.jb2TagToJb1Tag(attrName));
        if (attr && attrName === 'subfeatures') {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return attr.map((subfeature) => new NCListFeature(subfeature, this));
        }
        return attr;
    }
    /**
     * Get an array listing which data keys are present in this feature.
     */
    tags() {
        return this.ncFeature.tags().map((t) => this.jb1TagToJb2Tag(t));
    }
    /**
     * Get the unique ID of this feature.
     */
    id() {
        return this.uniqueId;
    }
    /**
     * Get this feature's parent feature, or undefined if none.
     */
    parent() {
        return this.parentHandle;
    }
    /**
     * Get an array of child features, or undefined if none.
     */
    children() {
        return this.get('subfeatures');
    }
    toJSON() {
        const data = { uniqueId: this.id() };
        this.ncFeature.tags().forEach((tag) => {
            const mappedTag = this.jb1TagToJb2Tag(tag);
            const value = this.ncFeature.get(tag);
            if (mappedTag === 'subfeatures') {
                data.subfeatures = (value || []).map((f) => {
                    // note: was new NCListFeature(f, `${this.id()}-${i}`, this).toJSON()
                    return new NCListFeature(f, this).toJSON();
                });
            }
            else {
                data[mappedTag] = value;
            }
        });
        return data;
    }
}
//# sourceMappingURL=NCListFeature.js.map

/***/ }),

/***/ "./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/blobFile.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/blobFile.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BlobFile; }
/* harmony export */ });
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

// Using this you can "await" the file like a normal promise
// https://blog.shovonhasan.com/using-promises-with-filereader/
function readBlobAsArrayBuffer(blob) {
    const fileReader = new FileReader();
    return new Promise((resolve, reject) => {
        fileReader.onerror = () => {
            fileReader.abort();
            reject(new Error('problem reading blob'));
        };
        fileReader.onabort = () => {
            reject(new Error('blob reading was aborted'));
        };
        fileReader.onload = () => {
            if (fileReader.result && typeof fileReader.result !== 'string') {
                resolve(fileReader.result);
            }
            else {
                reject(new Error('unknown error reading blob'));
            }
        };
        fileReader.readAsArrayBuffer(blob);
    });
}
function readBlobAsText(blob) {
    const fileReader = new FileReader();
    return new Promise((resolve, reject) => {
        fileReader.onerror = () => {
            fileReader.abort();
            reject(new Error('problem reading blob'));
        };
        fileReader.onabort = () => {
            reject(new Error('blob reading was aborted'));
        };
        fileReader.onload = () => {
            if (fileReader.result && typeof fileReader.result === 'string') {
                resolve(fileReader.result);
            }
            else {
                reject(new Error('unknown error reading blob'));
            }
        };
        fileReader.readAsText(blob);
    });
}
/**
 * Blob of binary data fetched from a local file (with FileReader).
 *
 * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in
 * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.
 */
class BlobFile {
    constructor(blob) {
        this.blob = blob;
        this.size = blob.size;
    }
    async read(buffer, offset = 0, length, position = 0) {
        // short-circuit a read of 0 bytes here, because browsers actually sometimes
        // crash if you try to read 0 bytes from a local file!
        if (!length) {
            return { bytesRead: 0, buffer };
        }
        const start = position;
        const end = start + length;
        const result = await readBlobAsArrayBuffer(this.blob.slice(start, end));
        const resultBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(result);
        const bytesCopied = resultBuffer.copy(buffer, offset);
        return { bytesRead: bytesCopied, buffer: resultBuffer };
    }
    async readFile(options) {
        let encoding;
        if (typeof options === 'string') {
            encoding = options;
        }
        else {
            encoding = options && options.encoding;
        }
        if (encoding === 'utf8') {
            return readBlobAsText(this.blob);
        }
        if (encoding) {
            throw new Error(`unsupported encoding: ${encoding}`);
        }
        const result = await readBlobAsArrayBuffer(this.blob);
        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(result);
    }
    async stat() {
        return { size: this.size };
    }
    async close() {
        return;
    }
}


/***/ }),

/***/ "./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/filehandle.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/filehandle.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/index.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobFile": function() { return /* reexport safe */ _blobFile__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "LocalFile": function() { return /* reexport default from dynamic */ _localFile__WEBPACK_IMPORTED_MODULE_0___default.a; },
/* harmony export */   "RemoteFile": function() { return /* reexport safe */ _remoteFile__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "fromUrl": function() { return /* binding */ fromUrl; },
/* harmony export */   "open": function() { return /* binding */ open; }
/* harmony export */ });
/* harmony import */ var _localFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./localFile */ "?1ea1");
/* harmony import */ var _localFile__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_localFile__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _remoteFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./remoteFile */ "./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/remoteFile.js");
/* harmony import */ var _blobFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blobFile */ "./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/blobFile.js");
/* harmony import */ var _filehandle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filehandle */ "./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/filehandle.js");




function fromUrl(source, opts = {}) {
    return new _remoteFile__WEBPACK_IMPORTED_MODULE_1__["default"](source, opts);
}
function open(maybeUrl, maybePath, maybeFilehandle, opts = {}) {
    if (maybeFilehandle !== undefined) {
        return maybeFilehandle;
    }
    if (maybeUrl !== undefined) {
        return fromUrl(maybeUrl, opts);
    }
    if (maybePath !== undefined) {
        return new (_localFile__WEBPACK_IMPORTED_MODULE_0___default())(maybePath, opts);
    }
    throw new Error('no url, path, or filehandle provided, cannot open');
}



/***/ }),

/***/ "./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/remoteFile.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@jbrowse/plugin-legacy-jbrowse/node_modules/generic-filehandle/esm/remoteFile.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RemoteFile; }
/* harmony export */ });
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

const myGlobal = typeof window !== 'undefined'
    ? window
    : typeof self !== 'undefined'
        ? self
        : { fetch: undefined };
class RemoteFile {
    constructor(source, opts = {}) {
        this.baseOverrides = {};
        this.url = source;
        const fetch = opts.fetch || (myGlobal.fetch && myGlobal.fetch.bind(myGlobal));
        if (!fetch) {
            throw new TypeError(`no fetch function supplied, and none found in global environment`);
        }
        if (opts.overrides) {
            this.baseOverrides = opts.overrides;
        }
        this.fetchImplementation = fetch;
    }
    async getBufferFromResponse(response) {
        if (typeof response.buffer === 'function') {
            return response.buffer();
        }
        else if (typeof response.arrayBuffer === 'function') {
            const resp = await response.arrayBuffer();
            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(resp);
        }
        else {
            throw new TypeError('invalid HTTP response object, has no buffer method, and no arrayBuffer method');
        }
    }
    async fetch(input, init) {
        let response;
        try {
            response = await this.fetchImplementation(input, init);
        }
        catch (e) {
            if (`${e}`.includes('Failed to fetch')) {
                // refetch to to help work around a chrome bug (discussed in
                // generic-filehandle issue #72) in which the chrome cache returns a
                // CORS error for content in its cache.  see also
                // https://github.com/GMOD/jbrowse-components/pull/1511
                console.warn(`generic-filehandle: refetching ${input} to attempt to work around chrome CORS header caching bug`);
                response = await this.fetchImplementation(input, {
                    ...init,
                    cache: 'reload',
                });
            }
            else {
                throw e;
            }
        }
        return response;
    }
    async read(buffer, offset = 0, length, position = 0, opts = {}) {
        const { headers = {}, signal, overrides = {} } = opts;
        if (length < Infinity) {
            headers.range = `bytes=${position}-${position + length}`;
        }
        else if (length === Infinity && position !== 0) {
            headers.range = `bytes=${position}-`;
        }
        const args = {
            ...this.baseOverrides,
            ...overrides,
            headers: {
                ...headers,
                ...overrides.headers,
                ...this.baseOverrides.headers,
            },
            method: 'GET',
            redirect: 'follow',
            mode: 'cors',
            signal,
        };
        const response = await this.fetch(this.url, args);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status} ${response.statusText} ${this.url}`);
        }
        if ((response.status === 200 && position === 0) ||
            response.status === 206) {
            const responseData = await this.getBufferFromResponse(response);
            const bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length));
            // try to parse out the size of the remote file
            const res = response.headers.get('content-range');
            const sizeMatch = /\/(\d+)$/.exec(res || '');
            if (sizeMatch && sizeMatch[1]) {
                this._stat = { size: parseInt(sizeMatch[1], 10) };
            }
            return { bytesRead: bytesCopied, buffer };
        }
        if (response.status === 200) {
            throw new Error('${this.url} fetch returned status 200, expected 206');
        }
        // TODO: try harder here to gather more information about what the problem is
        throw new Error(`HTTP ${response.status} fetching ${this.url}`);
    }
    async readFile(options = {}) {
        let encoding;
        let opts;
        if (typeof options === 'string') {
            encoding = options;
            opts = {};
        }
        else {
            encoding = options.encoding;
            opts = options;
            delete opts.encoding;
        }
        const { headers = {}, signal, overrides = {} } = opts;
        const args = {
            headers,
            method: 'GET',
            redirect: 'follow',
            mode: 'cors',
            signal,
            ...this.baseOverrides,
            ...overrides,
        };
        const response = await this.fetch(this.url, args);
        if (!response) {
            throw new Error('generic-filehandle failed to fetch');
        }
        if (response.status !== 200) {
            throw Object.assign(new Error(`HTTP ${response.status} fetching ${this.url}`), {
                status: response.status,
            });
        }
        if (encoding === 'utf8') {
            return response.text();
        }
        if (encoding) {
            throw new Error(`unsupported encoding: ${encoding}`);
        }
        return this.getBufferFromResponse(response);
    }
    async stat() {
        if (!this._stat) {
            const buf = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.allocUnsafe(10);
            await this.read(buf, 0, 10, 0);
            if (!this._stat) {
                throw new Error(`unable to determine size of file at ${this.url}`);
            }
        }
        return this._stat;
    }
    async close() {
        return;
    }
}


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jbrowse_plugin-legacy-jbrowse_esm_NCListAdapter_NCListAdapter_js.bundle.js.map