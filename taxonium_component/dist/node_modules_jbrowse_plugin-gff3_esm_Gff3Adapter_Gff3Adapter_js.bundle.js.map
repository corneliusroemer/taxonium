{"version":3,"file":"node_modules_jbrowse_plugin-gff3_esm_Gff3Adapter_Gff3Adapter_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;AAAkF;AAC7B;AACM;AACN;AACQ;AACf;AAClB;AAC5B;AACA;AACA;AACA,+DAAe,cAAc,2FAAsB;AACnD;AACA;AACA,0BAA0B,mEAAY;AACtC,2CAA2C,4DAAK;AAChD;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA,wBAAwB,8CAA8C;AACtE;AACA;AACA;AACA,sBAAsB,iEAAmB;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,wEAAa;AAC5C;AACA,mBAAmB,QAAQ,UAAU,EAAE;AACvC,SAAS;AACT;AACA;AACA;AACA,+BAA+B,iEAAY;AAC3C;AACA;AACA;AACA,SAAS,IAAI;AACb,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B;AAC/B,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,gCAAgC;AAChC,eAAe,yEAAgB;AAC/B;AACA;AACA,wBAAwB,sBAAsB;AAC9C,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,CAAC;AACD;;;;;;;;;;ACjJA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA","sources":["webpack://taxonium/./node_modules/@jbrowse/plugin-gff3/esm/Gff3Adapter/Gff3Adapter.js","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|./localFile","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|file-uri-to-path","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/readable-stream/lib/internal/streams|util","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/readable-stream/lib|util"],"sourcesContent":["import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { unzip } from '@gmod/bgzf-filehandle';\nimport gff from '@gmod/gff';\nfunction isGzip(buf) {\n    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;\n}\nexport default class extends BaseFeatureDataAdapter {\n    async loadDataP() {\n        const pm = this.pluginManager;\n        const buf = await openLocation(this.getConf('gffLocation'), pm).readFile();\n        const buffer = isGzip(buf) ? await unzip(buf) : buf;\n        // 512MB  max chrome string length is 512MB\n        if (buffer.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);\n        const lines = data.split('\\n');\n        const headerLines = [];\n        for (let i = 0; i < lines.length && lines[i].startsWith('#'); i++) {\n            headerLines.push(lines[i]);\n        }\n        const header = headerLines.join('\\n');\n        const feats = gff.parseStringSync(data, {\n            parseFeatures: true,\n            parseComments: false,\n            parseDirectives: false,\n            parseSequences: false,\n        });\n        const intervalTree = feats\n            .flat()\n            .map((f, i) => new SimpleFeature({\n            data: this.featureData(f),\n            id: `${this.id}-offset-${i}`,\n        }))\n            .reduce((acc, obj) => {\n            const key = obj.get('refName');\n            if (!acc[key]) {\n                acc[key] = new IntervalTree();\n            }\n            acc[key].insert([obj.get('start'), obj.get('end')], obj);\n            return acc;\n        }, {});\n        return { header, intervalTree };\n    }\n    async loadData() {\n        if (!this.gffFeatures) {\n            this.gffFeatures = this.loadDataP().catch(e => {\n                this.gffFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.gffFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { intervalTree } = await this.loadData();\n        return Object.keys(intervalTree);\n    }\n    async getHeader() {\n        const { header } = await this.loadData();\n        return header;\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = query;\n                const { intervalTree } = await this.loadData();\n                (_a = intervalTree[refName]) === null || _a === void 0 ? void 0 : _a.search([start, end]).forEach(f => observer.next(f));\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.signal);\n    }\n    featureData(data) {\n        const f = { ...data };\n        f.start -= 1; // convert to interbase\n        if (data.strand === '+') {\n            f.strand = 1;\n        }\n        else if (data.strand === '-') {\n            f.strand = -1;\n        }\n        else if (data.strand === '.') {\n            f.strand = 0;\n        }\n        else {\n            f.strand = undefined;\n        }\n        f.phase = Number(data.phase);\n        f.refName = data.seq_id;\n        if (data.score === null) {\n            delete f.score;\n        }\n        if (data.phase === null) {\n            delete f.score;\n        }\n        const defaultFields = [\n            'start',\n            'end',\n            'seq_id',\n            'score',\n            'type',\n            'source',\n            'phase',\n            'strand',\n        ];\n        const dataAttributes = data.attributes || {};\n        Object.keys(dataAttributes).forEach(a => {\n            let b = a.toLowerCase();\n            if (defaultFields.includes(b)) {\n                // add \"suffix\" to tag name if it already exists\n                // reproduces behavior of NCList\n                b += '2';\n            }\n            if (dataAttributes[a] !== null) {\n                let attr = dataAttributes[a];\n                if (Array.isArray(attr) && attr.length === 1) {\n                    ;\n                    [attr] = attr;\n                }\n                f[b] = attr;\n            }\n        });\n        f.refName = f.seq_id;\n        // the SimpleFeature constructor takes care of recursively inflating subfeatures\n        if (data.child_features && data.child_features.length) {\n            f.subfeatures = data.child_features\n                .map(childLocs => childLocs.map(childLoc => this.featureData(childLoc)))\n                .flat();\n        }\n        delete f.child_features;\n        delete f.data;\n        delete f.derived_features;\n        delete f.attributes;\n        delete f.seq_id;\n        return f;\n    }\n    freeResources( /* { region } */) { }\n}\n//# sourceMappingURL=Gff3Adapter.js.map","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */"],"names":[],"sourceRoot":""}