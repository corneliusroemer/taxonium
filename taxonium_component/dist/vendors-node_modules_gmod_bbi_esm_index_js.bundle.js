"use strict";
(self["webpackChunktaxonium"] = self["webpackChunktaxonium"] || []).push([["vendors-node_modules_gmod_bbi_esm_index_js"],{

/***/ "./node_modules/@gmod/bbi/esm/bbi.js":
/*!*******************************************!*\
  !*** ./node_modules/@gmod/bbi/esm/bbi.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BBI": function() { return /* binding */ BBI; }
/* harmony export */ });
/* harmony import */ var binary_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! binary-parser */ "./node_modules/binary-parser/dist/esm/binary_parser.mjs");
/* harmony import */ var generic_filehandle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! generic-filehandle */ "./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/internal/Observable.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/internal/operators/reduce.js");
/* harmony import */ var _blockView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockView */ "./node_modules/@gmod/bbi/esm/blockView.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];





const BIG_WIG_MAGIC = -2003829722;
const BIG_BED_MAGIC = -2021002517;
/* get the compiled parsers for different sections of the bigwig file
 *
 * @param isBE - is big endian, typically false
 * @return an object with compiled parsers
 */
function getParsers(isBE) {
    const le = isBE ? 'big' : 'little';
    const headerParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
        .endianess(le)
        .int32('magic')
        .uint16('version')
        .uint16('numZoomLevels')
        .uint64('chromTreeOffset')
        .uint64('unzoomedDataOffset')
        .uint64('unzoomedIndexOffset')
        .uint16('fieldCount')
        .uint16('definedFieldCount')
        .uint64('asOffset') // autoSql offset, used in bigbed
        .uint64('totalSummaryOffset')
        .uint32('uncompressBufSize')
        .uint64('extHeaderOffset') // name index offset, used in bigbed
        .array('zoomLevels', {
        length: 'numZoomLevels',
        type: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
            .endianess(le)
            .uint32('reductionLevel')
            .uint32('reserved')
            .uint64('dataOffset')
            .uint64('indexOffset'),
    });
    const totalSummaryParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
        .endianess(le)
        .uint64('basesCovered')
        .doublele('scoreMin')
        .doublele('scoreMax')
        .doublele('scoreSum')
        .doublele('scoreSumSquares');
    const chromTreeParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
        .endianess(le)
        .uint32('magic')
        .uint32('blockSize')
        .uint32('keySize')
        .uint32('valSize')
        .uint64('itemCount');
    const isLeafNode = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
        .endianess(le)
        .uint8('isLeafNode')
        .skip(1)
        .uint16('cnt')
        .saveOffset('offset');
    return {
        chromTreeParser,
        totalSummaryParser,
        headerParser,
        isLeafNode,
    };
}
class BBI {
    /*
     * @param filehandle - a filehandle from generic-filehandle or implementing something similar to the node10 fs.promises API
     * @param path - a Local file path as a string
     * @param url - a URL string
     * @param renameRefSeqs - an optional method to rename the internal reference sequences using a mapping function
     */
    constructor(options = {}) {
        const { filehandle, renameRefSeqs = s => s, path, url } = options;
        this.renameRefSeqs = renameRefSeqs;
        if (filehandle) {
            this.bbi = filehandle;
        }
        else if (url) {
            this.bbi = new generic_filehandle__WEBPACK_IMPORTED_MODULE_1__.RemoteFile(url);
        }
        else if (path) {
            this.bbi = new generic_filehandle__WEBPACK_IMPORTED_MODULE_1__.LocalFile(path);
        }
        else {
            throw new Error('no file given');
        }
    }
    /* fetch and parse header information from a bigwig or bigbed file
     * @param abortSignal - abort the operation, can be null
     * @return a Header object
     */
    getHeader(opts = {}) {
        const options = 'aborted' in opts ? { signal: opts } : opts;
        if (!this.headerP) {
            this.headerP = this._getHeader(options).catch(e => {
                this.headerP = undefined;
                throw e;
            });
        }
        return this.headerP;
    }
    async _getHeader(opts) {
        const header = await this._getMainHeader(opts);
        const chroms = await this._readChromTree(header, opts);
        return { ...header, ...chroms };
    }
    async _getMainHeader(opts, requestSize = 2000) {
        const { buffer } = await this.bbi.read(Buffer.alloc(requestSize), 0, requestSize, 0, opts);
        const isBigEndian = this._isBigEndian(buffer);
        const ret = getParsers(isBigEndian);
        const header = ret.headerParser.parse(buffer);
        const { magic, asOffset, totalSummaryOffset } = header;
        header.fileType = magic === BIG_BED_MAGIC ? 'bigbed' : 'bigwig';
        if (asOffset > requestSize || totalSummaryOffset > requestSize) {
            return this._getMainHeader(opts, requestSize * 2);
        }
        if (asOffset) {
            const off = Number(header.asOffset);
            header.autoSql = buffer
                .subarray(off, buffer.indexOf(0, off))
                .toString('utf8');
        }
        if (header.totalSummaryOffset > requestSize) {
            return this._getMainHeader(opts, requestSize * 2);
        }
        if (header.totalSummaryOffset) {
            const tail = buffer.subarray(Number(header.totalSummaryOffset));
            const sum = ret.totalSummaryParser.parse(tail);
            header.totalSummary = { ...sum, basesCovered: Number(sum.basesCovered) };
        }
        return { ...header, isBigEndian };
    }
    _isBigEndian(buffer) {
        let ret = buffer.readInt32LE(0);
        if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
            return false;
        }
        ret = buffer.readInt32BE(0);
        if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
            return true;
        }
        throw new Error('not a BigWig/BigBed file');
    }
    // todo: add progress if long running
    async _readChromTree(header, opts) {
        const isBE = header.isBigEndian;
        const le = isBE ? 'big' : 'little';
        const refsByNumber = [];
        const refsByName = {};
        let unzoomedDataOffset = Number(header.unzoomedDataOffset);
        const chromTreeOffset = Number(header.chromTreeOffset);
        while (unzoomedDataOffset % 4 !== 0) {
            unzoomedDataOffset += 1;
        }
        const off = unzoomedDataOffset - chromTreeOffset;
        const { buffer } = await this.bbi.read(Buffer.alloc(off), 0, off, Number(chromTreeOffset), opts);
        const p = getParsers(isBE);
        const { keySize } = p.chromTreeParser.parse(buffer);
        const leafNodeParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
            .endianess(le)
            .string('key', { stripNull: true, length: keySize })
            .uint32('refId')
            .uint32('refSize')
            .saveOffset('offset');
        const nonleafNodeParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
            .endianess(le)
            .skip(keySize)
            .uint64('childOffset')
            .saveOffset('offset');
        const rootNodeOffset = 32;
        const bptReadNode = async (currentOffset) => {
            let offset = currentOffset;
            if (offset >= buffer.length) {
                throw new Error('reading beyond end of buffer');
            }
            const ret = p.isLeafNode.parse(buffer.subarray(offset));
            const { isLeafNode, cnt } = ret;
            offset += ret.offset;
            if (isLeafNode) {
                for (let n = 0; n < cnt; n += 1) {
                    const leafRet = leafNodeParser.parse(buffer.subarray(offset));
                    offset += leafRet.offset;
                    const { key, refId, refSize } = leafRet;
                    const refRec = { name: key, id: refId, length: refSize };
                    refsByName[this.renameRefSeqs(key)] = refId;
                    refsByNumber[refId] = refRec;
                }
            }
            else {
                // parse index node
                const nextNodes = [];
                for (let n = 0; n < cnt; n += 1) {
                    const nonleafRet = nonleafNodeParser.parse(buffer.subarray(offset));
                    const { childOffset } = nonleafRet;
                    offset += nonleafRet.offset;
                    nextNodes.push(bptReadNode(Number(childOffset) - Number(chromTreeOffset)));
                }
                await Promise.all(nextNodes);
            }
        };
        await bptReadNode(rootNodeOffset);
        return {
            refsByName,
            refsByNumber,
        };
    }
    /*
     * fetches the "unzoomed" view of the bigwig data. this is the default for bigbed
     * @param abortSignal - a signal to optionally abort this operation
     */
    async getUnzoomedView(opts) {
        const { unzoomedIndexOffset, refsByName, uncompressBufSize, isBigEndian, fileType, } = await this.getHeader(opts);
        return new _blockView__WEBPACK_IMPORTED_MODULE_2__.BlockView(this.bbi, refsByName, unzoomedIndexOffset, isBigEndian, uncompressBufSize > 0, fileType);
    }
    /**
     * Gets features from a BigWig file
     *
     * @param refName - The chromosome name
     * @param start - The start of a region
     * @param end - The end of a region
     * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
     */
    async getFeatureStream(refName, start, end, opts = {
        scale: 1,
    }) {
        await this.getHeader(opts);
        const chrName = this.renameRefSeqs(refName);
        let view;
        if (opts.basesPerSpan) {
            view = await this.getView(1 / opts.basesPerSpan, opts);
        }
        else if (opts.scale) {
            view = await this.getView(opts.scale, opts);
        }
        else {
            view = await this.getView(1, opts);
        }
        if (!view) {
            throw new Error('unable to get block view for data');
        }
        return new rxjs__WEBPACK_IMPORTED_MODULE_3__.Observable((observer) => {
            view.readWigData(chrName, start, end, observer, opts);
        });
    }
    async getFeatures(refName, start, end, opts = {
        scale: 1,
    }) {
        const ob = await this.getFeatureStream(refName, start, end, opts);
        const ret = await ob
            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.reduce)((acc, curr) => acc.concat(curr)))
            .toPromise();
        return ret || [];
    }
}
//# sourceMappingURL=bbi.js.map

/***/ }),

/***/ "./node_modules/@gmod/bbi/esm/bigbed.js":
/*!**********************************************!*\
  !*** ./node_modules/@gmod/bbi/esm/bigbed.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BigBed": function() { return /* binding */ BigBed; },
/* harmony export */   "filterUndef": function() { return /* binding */ filterUndef; }
/* harmony export */ });
/* harmony import */ var binary_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! binary-parser */ "./node_modules/binary-parser/dist/esm/binary_parser.mjs");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/internal/Observable.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/internal/observable/merge.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/internal/operators/reduce.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/internal/operators/map.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abortable-promise-cache */ "./node_modules/abortable-promise-cache/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(abortable_promise_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! quick-lru */ "./node_modules/@gmod/bbi/node_modules/quick-lru/index.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(quick_lru__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _bbi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bbi */ "./node_modules/@gmod/bbi/esm/bbi.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];






function filterUndef(ts) {
    return ts.filter((t) => !!t);
}
class BigBed extends _bbi__WEBPACK_IMPORTED_MODULE_3__.BBI {
    constructor() {
        super(...arguments);
        this.readIndicesCache = new (abortable_promise_cache__WEBPACK_IMPORTED_MODULE_1___default())({
            cache: new (quick_lru__WEBPACK_IMPORTED_MODULE_2___default())({ maxSize: 1 }),
            fill: async (args, signal) => {
                return this._readIndices({ ...args, signal });
            },
        });
    }
    readIndices(opts = {}) {
        const options = 'aborted' in opts ? { signal: opts } : opts;
        return this.readIndicesCache.get(JSON.stringify(options), options, options.signal);
    }
    /*
     * retrieve unzoomed view for any scale
     * @param scale - unused
     * @param abortSignal - an optional AbortSignal to kill operation
     * @return promise for a BlockView
     */
    async getView(_scale, opts) {
        return this.getUnzoomedView(opts);
    }
    /*
     * parse the bigbed extraIndex fields
     * @param abortSignal to abort operation
     * @return a Promise for an array of Index data structure since there can be multiple extraIndexes in a bigbed, see bedToBigBed documentation
     */
    async _readIndices(opts) {
        const { extHeaderOffset, isBigEndian } = await this.getHeader(opts);
        const { buffer: data } = await this.bbi.read(Buffer.alloc(64), 0, 64, Number(extHeaderOffset));
        const le = isBigEndian ? 'big' : 'little';
        const ret = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
            .endianess(le)
            .uint16('size')
            .uint16('count')
            .uint64('offset')
            .parse(data);
        const { count, offset } = ret;
        // no extra index is defined if count==0
        if (count === 0) {
            return [];
        }
        const blocklen = 20;
        const len = blocklen * count;
        const { buffer } = await this.bbi.read(Buffer.alloc(len), 0, len, Number(offset));
        const extParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
            .endianess(le)
            .int16('type')
            .int16('fieldcount')
            .uint64('offset')
            .skip(4)
            .int16('field');
        const indices = [];
        for (let i = 0; i < count; i += 1) {
            indices.push(extParser.parse(buffer.subarray(i * blocklen)));
        }
        return indices;
    }
    /*
     * perform a search in the bigbed extraIndex to find which blocks in the bigbed data to look for the
     * actual feature data
     *
     * @param name - the name to search for
     * @param opts - a SearchOptions argument with optional signal
     * @return a Promise for an array of bigbed block Loc entries
     */
    async searchExtraIndexBlocks(name, opts = {}) {
        const { isBigEndian } = await this.getHeader(opts);
        const indices = await this.readIndices(opts);
        if (!indices.length) {
            return [];
        }
        const locs = indices.map(async (index) => {
            const { offset, field } = index;
            const { buffer: data } = await this.bbi.read(Buffer.alloc(32), 0, 32, Number(offset), opts);
            const le = isBigEndian ? 'big' : 'little';
            const p = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
                .endianess(le)
                .int32('magic')
                .int32('blockSize')
                .int32('keySize')
                .int32('valSize')
                .uint64('itemCount');
            const { blockSize, keySize, valSize } = p.parse(data);
            // console.log({blockSize,keySize,valSize})
            const bpt = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
                .endianess(le)
                .int8('nodeType')
                .skip(1)
                .int16('cnt')
                .choice({
                tag: 'nodeType',
                choices: {
                    0: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().array('leafkeys', {
                        length: 'cnt',
                        type: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
                            .endianess(le)
                            .string('key', { length: keySize, stripNull: true })
                            .uint64('offset'),
                    }),
                    1: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().array('keys', {
                        length: 'cnt',
                        type: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
                            .endianess(le)
                            .string('key', { length: keySize, stripNull: true })
                            .uint64('offset')
                            .uint32('length')
                            .uint32('reserved'),
                    }),
                },
            });
            const bptReadNode = async (nodeOffset) => {
                const val = Number(nodeOffset);
                const len = 4 + blockSize * (keySize + valSize);
                const { buffer } = await this.bbi.read(Buffer.alloc(len), 0, len, val, opts);
                const node = bpt.parse(buffer);
                if (node.leafkeys) {
                    let lastOffset;
                    for (let i = 0; i < node.leafkeys.length; i += 1) {
                        const { key } = node.leafkeys[i];
                        if (name.localeCompare(key) < 0 && lastOffset) {
                            return bptReadNode(lastOffset);
                        }
                        lastOffset = node.leafkeys[i].offset;
                    }
                    return bptReadNode(lastOffset);
                }
                for (let i = 0; i < node.keys.length; i += 1) {
                    if (node.keys[i].key === name) {
                        return { ...node.keys[i], field };
                    }
                }
                return undefined;
            };
            const rootNodeOffset = 32;
            return bptReadNode(Number(offset) + rootNodeOffset);
        });
        return filterUndef(await Promise.all(locs));
    }
    /*
     * retrieve the features from the bigbed data that were found through the lookup of the extraIndex
     * note that there can be multiple extraIndex, see the BigBed specification and the -extraIndex argument to bedToBigBed
     *
     * @param name - the name to search for
     * @param opts - a SearchOptions argument with optional signal
     * @return a Promise for an array of Feature
     */
    async searchExtraIndex(name, opts = {}) {
        const blocks = await this.searchExtraIndexBlocks(name, opts);
        if (!blocks.length) {
            return [];
        }
        const view = await this.getUnzoomedView(opts);
        const res = blocks.map(block => {
            return new rxjs__WEBPACK_IMPORTED_MODULE_4__.Observable(observer => {
                view.readFeatures(observer, [block], opts);
            }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.reduce)((acc, curr) => acc.concat(curr)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(x => {
                for (let i = 0; i < x.length; i += 1) {
                    x[i].field = block.field;
                }
                return x;
            }));
        });
        const ret = await (0,rxjs__WEBPACK_IMPORTED_MODULE_7__.merge)(...res).toPromise();
        return ret.filter(f => { var _a; return ((_a = f.rest) === null || _a === void 0 ? void 0 : _a.split('\t')[(f.field || 0) - 3]) === name; });
    }
}
//# sourceMappingURL=bigbed.js.map

/***/ }),

/***/ "./node_modules/@gmod/bbi/esm/bigwig.js":
/*!**********************************************!*\
  !*** ./node_modules/@gmod/bbi/esm/bigwig.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BigWig": function() { return /* binding */ BigWig; }
/* harmony export */ });
/* harmony import */ var _blockView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blockView */ "./node_modules/@gmod/bbi/esm/blockView.js");
/* harmony import */ var _bbi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bbi */ "./node_modules/@gmod/bbi/esm/bbi.js");


class BigWig extends _bbi__WEBPACK_IMPORTED_MODULE_1__.BBI {
    /**
     * Retrieves a BlockView of a specific zoomLevel
     *
     * @param scale - number
     * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
     */
    async getView(scale, opts) {
        const { zoomLevels, refsByName, fileSize, isBigEndian, uncompressBufSize } = await this.getHeader(opts);
        const basesPerPx = 1 / scale;
        let maxLevel = zoomLevels.length;
        if (!fileSize) {
            // if we don't know the file size, we can't fetch the highest zoom level :-(
            maxLevel -= 1;
        }
        for (let i = maxLevel; i >= 0; i -= 1) {
            const zh = zoomLevels[i];
            if (zh && zh.reductionLevel <= 2 * basesPerPx) {
                const indexOffset = Number(zh.indexOffset);
                return new _blockView__WEBPACK_IMPORTED_MODULE_0__.BlockView(this.bbi, refsByName, indexOffset, isBigEndian, uncompressBufSize > 0, 'summary');
            }
        }
        return this.getUnzoomedView(opts);
    }
}
//# sourceMappingURL=bigwig.js.map

/***/ }),

/***/ "./node_modules/@gmod/bbi/esm/blockView.js":
/*!*************************************************!*\
  !*** ./node_modules/@gmod/bbi/esm/blockView.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlockView": function() { return /* binding */ BlockView; }
/* harmony export */ });
/* harmony import */ var binary_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! binary-parser */ "./node_modules/binary-parser/dist/esm/binary_parser.mjs");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abortable-promise-cache */ "./node_modules/abortable-promise-cache/esm/index.js");
/* harmony import */ var abortable_promise_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(abortable_promise_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! quick-lru */ "./node_modules/@gmod/bbi/node_modules/quick-lru/index.js");
/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(quick_lru__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./range */ "./node_modules/@gmod/bbi/esm/range.js");
/* harmony import */ var _unzip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./unzip */ "./node_modules/@gmod/bbi/esm/unzip-pako.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./node_modules/@gmod/bbi/esm/util.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];



// locals



const BIG_WIG_TYPE_GRAPH = 1;
const BIG_WIG_TYPE_VSTEP = 2;
const BIG_WIG_TYPE_FSTEP = 3;
function coordFilter(s1, e1, s2, e2) {
    return s1 < e2 && e1 >= s2;
}
function getParsers(isBigEndian) {
    const le = isBigEndian ? 'big' : 'little';
    const summaryParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
        .endianess(le)
        .uint32('chromId')
        .uint32('start')
        .uint32('end')
        .uint32('validCnt')
        .floatle('minScore')
        .floatle('maxScore')
        .floatle('sumData')
        .floatle('sumSqData')
        .saveOffset('offset');
    const leafParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
        .endianess(le)
        .uint8('isLeaf')
        .skip(1)
        .uint16('cnt')
        .choice({
        tag: 'isLeaf',
        choices: {
            1: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().endianess(le).array('blocksToFetch', {
                length: 'cnt',
                type: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
                    .endianess(le)
                    .uint32('startChrom')
                    .uint32('startBase')
                    .uint32('endChrom')
                    .uint32('endBase')
                    .uint64('blockOffset')
                    .uint64('blockSize')
                    .saveOffset('offset'),
            }),
            0: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().array('recurOffsets', {
                length: 'cnt',
                type: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
                    .endianess(le)
                    .uint32('startChrom')
                    .uint32('startBase')
                    .uint32('endChrom')
                    .uint32('endBase')
                    .uint64('blockOffset')
                    .saveOffset('offset'),
            }),
        },
    });
    const bigBedParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
        .endianess(le)
        .uint32('chromId')
        .int32('start')
        .int32('end')
        .string('rest', {
        zeroTerminated: true,
    })
        .saveOffset('offset');
    const bigWigParser = new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
        .endianess(le)
        .skip(4)
        .int32('blockStart')
        .skip(4)
        .uint32('itemStep')
        .uint32('itemSpan')
        .uint8('blockType')
        .skip(1)
        .uint16('itemCount')
        .choice({
        tag: 'blockType',
        choices: {
            [BIG_WIG_TYPE_FSTEP]: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().array('items', {
                length: 'itemCount',
                type: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().floatle('score'),
            }),
            [BIG_WIG_TYPE_VSTEP]: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().array('items', {
                length: 'itemCount',
                type: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().endianess(le).int32('start').floatle('score'),
            }),
            [BIG_WIG_TYPE_GRAPH]: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser().array('items', {
                length: 'itemCount',
                type: new binary_parser__WEBPACK_IMPORTED_MODULE_0__.Parser()
                    .endianess(le)
                    .int32('start')
                    .int32('end')
                    .floatle('score'),
            }),
        },
    });
    return {
        bigWigParser,
        bigBedParser,
        summaryParser,
        leafParser,
    };
}
/**
 * View into a subset of the data in a BigWig file.
 *
 * Adapted by Robert Buels and Colin Diesh from bigwig.js in the Dalliance Genome
 * Explorer by Thomas Down.
 * @constructs
 */
class BlockView {
    constructor(bbi, refsByName, cirTreeOffset, isBigEndian, isCompressed, blockType) {
        this.bbi = bbi;
        this.refsByName = refsByName;
        this.cirTreeOffset = cirTreeOffset;
        this.isBigEndian = isBigEndian;
        this.isCompressed = isCompressed;
        this.blockType = blockType;
        this.featureCache = new (abortable_promise_cache__WEBPACK_IMPORTED_MODULE_1___default())({
            cache: new (quick_lru__WEBPACK_IMPORTED_MODULE_2___default())({ maxSize: 1000 }),
            fill: async (requestData, signal) => {
                const len = Number(requestData.length);
                const off = Number(requestData.offset);
                const { buffer } = await this.bbi.read(Buffer.alloc(len), 0, len, off, {
                    signal,
                });
                return buffer;
            },
        });
        if (!(cirTreeOffset >= 0)) {
            throw new Error('invalid cirTreeOffset!');
        }
        const parsers = getParsers(isBigEndian);
        this.leafParser = parsers.leafParser;
        this.bigBedParser = parsers.bigBedParser;
    }
    async readWigData(chrName, start, end, observer, opts) {
        try {
            const { refsByName, bbi, cirTreeOffset, isBigEndian } = this;
            const chrId = refsByName[chrName];
            if (chrId === undefined) {
                observer.complete();
            }
            const request = { chrId, start, end };
            if (!this.cirTreePromise) {
                const off = Number(cirTreeOffset);
                this.cirTreePromise = bbi.read(Buffer.alloc(48), 0, 48, off, opts);
            }
            const { buffer } = await this.cirTreePromise;
            const cirBlockSize = isBigEndian
                ? buffer.readUInt32BE(4)
                : buffer.readUInt32LE(4);
            let blocksToFetch = [];
            let outstanding = 0;
            const cirFobRecur2 = (cirBlockData, offset, level) => {
                try {
                    const data = cirBlockData.subarray(offset);
                    const p = this.leafParser.parse(data);
                    if (p.blocksToFetch) {
                        blocksToFetch = blocksToFetch.concat(p.blocksToFetch
                            .filter(filterFeats)
                            .map((l) => ({
                            offset: l.blockOffset,
                            length: l.blockSize,
                        })));
                    }
                    if (p.recurOffsets) {
                        const recurOffsets = p.recurOffsets
                            .filter(filterFeats)
                            .map((l) => Number(l.blockOffset));
                        if (recurOffsets.length > 0) {
                            cirFobRecur(recurOffsets, level + 1);
                        }
                    }
                }
                catch (e) {
                    observer.error(e);
                }
            };
            const filterFeats = (b) => {
                const { startChrom, startBase, endChrom, endBase } = b;
                return ((startChrom < chrId || (startChrom === chrId && startBase <= end)) &&
                    (endChrom > chrId || (endChrom === chrId && endBase >= start)));
            };
            const cirFobStartFetch = async (off, fr, level) => {
                try {
                    const length = fr.max() - fr.min();
                    const offset = fr.min();
                    const resultBuffer = await this.featureCache.get(`${length}_${offset}`, { length, offset }, opts.signal);
                    for (let i = 0; i < off.length; i += 1) {
                        if (fr.contains(off[i])) {
                            cirFobRecur2(resultBuffer, off[i] - offset, level);
                            outstanding -= 1;
                            if (outstanding === 0) {
                                this.readFeatures(observer, blocksToFetch, { ...opts, request });
                            }
                        }
                    }
                }
                catch (e) {
                    observer.error(e);
                }
            };
            const cirFobRecur = (offset, level) => {
                try {
                    outstanding += offset.length;
                    const maxCirBlockSpan = 4 + Number(cirBlockSize) * 32; // Upper bound on size, based on a completely full leaf node.
                    let spans = new _range__WEBPACK_IMPORTED_MODULE_3__["default"](offset[0], offset[0] + maxCirBlockSpan);
                    for (let i = 1; i < offset.length; i += 1) {
                        const blockSpan = new _range__WEBPACK_IMPORTED_MODULE_3__["default"](offset[i], offset[i] + maxCirBlockSpan);
                        spans = spans.union(blockSpan);
                    }
                    spans.getRanges().map(fr => cirFobStartFetch(offset, fr, level));
                }
                catch (e) {
                    observer.error(e);
                }
            };
            return cirFobRecur([Number(cirTreeOffset) + 48], 1);
        }
        catch (e) {
            observer.error(e);
        }
    }
    parseSummaryBlock(buffer, startOffset, request) {
        const features = [];
        let offset = startOffset;
        const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);
        while (offset < buffer.byteLength) {
            // this was extracted from looking at the runtime code generated by
            // binary-parser
            const chromId = dataView.getUint32(offset, true);
            offset += 4;
            const start = dataView.getUint32(offset, true);
            offset += 4;
            const end = dataView.getUint32(offset, true);
            offset += 4;
            const validCnt = dataView.getUint32(offset, true);
            offset += 4;
            const minScore = dataView.getFloat32(offset, true);
            offset += 4;
            const maxScore = dataView.getFloat32(offset, true);
            offset += 4;
            const sumData = dataView.getFloat32(offset, true);
            offset += 4;
            // unused
            // const sumSqData = dataView.getFloat32(offset, true)
            offset += 4;
            if (request
                ? chromId === request.chrId &&
                    coordFilter(start, end, request.start, request.end)
                : true) {
                features.push({
                    start,
                    end,
                    maxScore,
                    minScore,
                    summary: true,
                    score: sumData / (validCnt || 1),
                });
            }
        }
        return features;
    }
    parseBigBedBlock(data, startOffset, offset, request) {
        const items = [];
        let currOffset = startOffset;
        while (currOffset < data.byteLength) {
            const res = this.bigBedParser.parse(data.subarray(currOffset));
            items.push({ ...res, uniqueId: `bb-${offset + currOffset}` });
            currOffset += res.offset;
        }
        return request
            ? items.filter((f) => coordFilter(f.start, f.end, request.start, request.end))
            : items;
    }
    parseBigWigBlock(buffer, startOffset, request) {
        const b = buffer.subarray(startOffset);
        const dataView = new DataView(b.buffer, b.byteOffset, b.length);
        let offset = 0;
        offset += 4;
        const blockStart = dataView.getInt32(offset, true);
        offset += 8;
        const itemStep = dataView.getUint32(offset, true);
        offset += 4;
        const itemSpan = dataView.getUint32(offset, true);
        offset += 4;
        const blockType = dataView.getUint8(offset);
        offset += 2;
        const itemCount = dataView.getUint16(offset, true);
        offset += 2;
        const items = new Array(itemCount);
        switch (blockType) {
            case 1:
                for (let i = 0; i < itemCount; i++) {
                    const start = dataView.getInt32(offset, true);
                    offset += 4;
                    const end = dataView.getInt32(offset, true);
                    offset += 4;
                    const score = dataView.getFloat32(offset, true);
                    offset += 4;
                    items[i] = { start, end, score };
                }
                break;
            case 2:
                for (let i = 0; i < itemCount; i++) {
                    const start = dataView.getInt32(offset, true);
                    offset += 4;
                    const score = dataView.getFloat32(offset, true);
                    offset += 4;
                    items[i] = { score, start, end: start + itemSpan };
                }
                break;
            case 3:
                for (let i = 0; i < itemCount; i++) {
                    const score = dataView.getFloat32(offset, true);
                    offset += 4;
                    const start = blockStart + i * itemStep;
                    items[i] = { score, start, end: start + itemSpan };
                }
                break;
        }
        return request
            ? items.filter((f) => coordFilter(f.start, f.end, request.start, request.end))
            : items;
    }
    async readFeatures(observer, blocks, opts = {}) {
        try {
            const { blockType, isCompressed } = this;
            const { signal, request } = opts;
            const blockGroupsToFetch = (0,_util__WEBPACK_IMPORTED_MODULE_5__.groupBlocks)(blocks);
            (0,_util__WEBPACK_IMPORTED_MODULE_5__.checkAbortSignal)(signal);
            await Promise.all(blockGroupsToFetch.map(async (blockGroup) => {
                (0,_util__WEBPACK_IMPORTED_MODULE_5__.checkAbortSignal)(signal);
                const { length, offset } = blockGroup;
                const data = await this.featureCache.get(`${length}_${offset}`, blockGroup, signal);
                blockGroup.blocks.forEach(block => {
                    (0,_util__WEBPACK_IMPORTED_MODULE_5__.checkAbortSignal)(signal);
                    let blockOffset = Number(block.offset) - Number(blockGroup.offset);
                    let resultData = data;
                    if (isCompressed) {
                        resultData = (0,_unzip__WEBPACK_IMPORTED_MODULE_4__.unzip)(data.subarray(blockOffset));
                        blockOffset = 0;
                    }
                    (0,_util__WEBPACK_IMPORTED_MODULE_5__.checkAbortSignal)(signal);
                    switch (blockType) {
                        case 'summary':
                            observer.next(this.parseSummaryBlock(resultData, blockOffset, request));
                            break;
                        case 'bigwig':
                            observer.next(this.parseBigWigBlock(resultData, blockOffset, request));
                            break;
                        case 'bigbed':
                            observer.next(this.parseBigBedBlock(resultData, blockOffset, Number(block.offset) * (1 << 8), request));
                            break;
                        default:
                            console.warn(`Don't know what to do with ${blockType}`);
                    }
                });
            }));
            observer.complete();
        }
        catch (e) {
            observer.error(e);
        }
    }
}
//# sourceMappingURL=blockView.js.map

/***/ }),

/***/ "./node_modules/@gmod/bbi/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@gmod/bbi/esm/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BigBed": function() { return /* reexport safe */ _bigbed__WEBPACK_IMPORTED_MODULE_1__.BigBed; },
/* harmony export */   "BigWig": function() { return /* reexport safe */ _bigwig__WEBPACK_IMPORTED_MODULE_0__.BigWig; }
/* harmony export */ });
/* harmony import */ var _bigwig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bigwig */ "./node_modules/@gmod/bbi/esm/bigwig.js");
/* harmony import */ var _bigbed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bigbed */ "./node_modules/@gmod/bbi/esm/bigbed.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@gmod/bbi/esm/range.js":
/*!*********************************************!*\
  !*** ./node_modules/@gmod/bbi/esm/range.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Range; }
/* harmony export */ });
/* eslint prefer-rest-params:0, no-nested-ternary:0 */
/**
 * Adapted from a combination of Range and _Compound in the
 * Dalliance Genome Explorer, (c) Thomas Down 2006-2010.
 */
class Range {
    constructor(arg1, arg2) {
        this.ranges =
            arguments.length === 2
                ? [{ min: arg1, max: arg2 }]
                : 0 in arg1
                    ? Object.assign({}, arg1)
                    : [arg1];
    }
    min() {
        return this.ranges[0].min;
    }
    max() {
        return this.ranges[this.ranges.length - 1].max;
    }
    contains(pos) {
        for (let s = 0; s < this.ranges.length; s += 1) {
            const r = this.ranges[s];
            if (r.min <= pos && r.max >= pos) {
                return true;
            }
        }
        return false;
    }
    isContiguous() {
        return this.ranges.length > 1;
    }
    getRanges() {
        return this.ranges.map((r) => new Range(r.min, r.max));
    }
    toString() {
        return this.ranges.map((r) => `[${r.min}-${r.max}]`).join(',');
    }
    union(s1) {
        const ranges = this.getRanges().concat(s1.getRanges()).sort(this.rangeOrder);
        const oranges = [];
        let current = ranges[0];
        for (let i = 1; i < ranges.length; i += 1) {
            const nxt = ranges[i];
            if (nxt.min() > current.max() + 1) {
                oranges.push(current);
                current = nxt;
            }
            else if (nxt.max() > current.max()) {
                current = new Range(current.min(), nxt.max());
            }
        }
        oranges.push(current);
        if (oranges.length === 1) {
            return oranges[0];
        }
        return new Range(oranges);
    }
    intersection(arg) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let s0 = this;
        let s1 = arg;
        const r0 = this.ranges();
        const r1 = s1.ranges();
        const l0 = r0.length;
        const l1 = r1.length;
        let i0 = 0;
        let i1 = 0;
        const or = [];
        while (i0 < l0 && i1 < l1) {
            s0 = r0[i0];
            s1 = r1[i1];
            const lapMin = Math.max(s0.min(), s1.min());
            const lapMax = Math.min(s0.max(), s1.max());
            if (lapMax >= lapMin) {
                or.push(new Range(lapMin, lapMax));
            }
            if (s0.max() > s1.max()) {
                i1 += 1;
            }
            else {
                i0 += 1;
            }
        }
        if (or.length === 0) {
            throw new Error('found range of length 0');
        }
        if (or.length === 1) {
            return or[0];
        }
        return new Range(or);
    }
    coverage() {
        let tot = 0;
        const rl = this.ranges();
        for (let ri = 0; ri < rl.length; ri += 1) {
            const r = rl[ri];
            tot += r.max() - r.min() + 1;
        }
        return tot;
    }
    rangeOrder(tmpa, tmpb) {
        let a = tmpa;
        let b = tmpb;
        if (arguments.length < 2) {
            b = a;
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            a = this;
        }
        if (a.min() < b.min()) {
            return -1;
        }
        if (a.min() > b.min()) {
            return 1;
        }
        if (a.max() < b.max()) {
            return -1;
        }
        if (b.max() > a.max()) {
            return 1;
        }
        return 0;
    }
}
//# sourceMappingURL=range.js.map

/***/ }),

/***/ "./node_modules/@gmod/bbi/esm/unzip-pako.js":
/*!**************************************************!*\
  !*** ./node_modules/@gmod/bbi/esm/unzip-pako.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unzip": function() { return /* binding */ unzip; }
/* harmony export */ });
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ "./node_modules/pako/dist/pako.esm.mjs");

function unzip(input) {
    return (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflateRaw)(input.subarray(2));
}
//# sourceMappingURL=unzip-pako.js.map

/***/ }),

/***/ "./node_modules/@gmod/bbi/esm/util.js":
/*!********************************************!*\
  !*** ./node_modules/@gmod/bbi/esm/util.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortError": function() { return /* binding */ AbortError; },
/* harmony export */   "abortBreakPoint": function() { return /* binding */ abortBreakPoint; },
/* harmony export */   "checkAbortSignal": function() { return /* binding */ checkAbortSignal; },
/* harmony export */   "groupBlocks": function() { return /* binding */ groupBlocks; }
/* harmony export */ });
/* eslint no-bitwise: ["error", { "allow": ["|"] }] */
class AbortError extends Error {
    constructor(message) {
        super(message);
        this.code = 'ERR_ABORTED';
    }
}
// sort blocks by file offset and
// group blocks that are within 2KB of eachother
function groupBlocks(blocks) {
    blocks.sort((b0, b1) => Number(b0.offset) - Number(b1.offset));
    const blockGroups = [];
    let lastBlock;
    let lastBlockEnd;
    for (let i = 0; i < blocks.length; i += 1) {
        if (lastBlock &&
            lastBlockEnd &&
            Number(blocks[i].offset) - lastBlockEnd <= 2000) {
            lastBlock.length = BigInt(Number(lastBlock.length) +
                Number(blocks[i].length) -
                lastBlockEnd +
                Number(blocks[i].offset));
            lastBlock.blocks.push(blocks[i]);
        }
        else {
            blockGroups.push((lastBlock = {
                blocks: [blocks[i]],
                length: blocks[i].length,
                offset: blocks[i].offset,
            }));
        }
        lastBlockEnd = Number(lastBlock.offset) + Number(lastBlock.length);
    }
    return blockGroups;
}
/**
 * Properly check if the given AbortSignal is aborted.
 * Per the standard, if the signal reads as aborted,
 * this function throws either a DOMException AbortError, or a regular error
 * with a `code` attribute set to `ERR_ABORTED`.
 *
 * For convenience, passing `undefined` is a no-op
 *
 * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute
 * @returns nothing
 */
function checkAbortSignal(signal) {
    if (!signal) {
        return;
    }
    if (signal.aborted) {
        // console.log('bam aborted!')
        if (typeof DOMException !== 'undefined') {
            throw new DOMException('aborted', 'AbortError');
        }
        else {
            const e = new AbortError('aborted');
            e.code = 'ERR_ABORTED';
            throw e;
        }
    }
}
/**
 * Skips to the next tick, then runs `checkAbortSignal`.
 * Await this to inside an otherwise synchronous loop to
 * provide a place to break when an abort signal is received.
 * @param {AbortSignal} signal
 */
async function abortBreakPoint(signal) {
    await Promise.resolve();
    checkAbortSignal(signal);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/blobFile.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/blobFile.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BlobFile; }
/* harmony export */ });
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

// Using this you can "await" the file like a normal promise
// https://blog.shovonhasan.com/using-promises-with-filereader/
function readBlobAsArrayBuffer(blob) {
    const fileReader = new FileReader();
    return new Promise((resolve, reject) => {
        fileReader.onerror = () => {
            fileReader.abort();
            reject(new Error('problem reading blob'));
        };
        fileReader.onabort = () => {
            reject(new Error('blob reading was aborted'));
        };
        fileReader.onload = () => {
            if (fileReader.result && typeof fileReader.result !== 'string') {
                resolve(fileReader.result);
            }
            else {
                reject(new Error('unknown error reading blob'));
            }
        };
        fileReader.readAsArrayBuffer(blob);
    });
}
function readBlobAsText(blob) {
    const fileReader = new FileReader();
    return new Promise((resolve, reject) => {
        fileReader.onerror = () => {
            fileReader.abort();
            reject(new Error('problem reading blob'));
        };
        fileReader.onabort = () => {
            reject(new Error('blob reading was aborted'));
        };
        fileReader.onload = () => {
            if (fileReader.result && typeof fileReader.result === 'string') {
                resolve(fileReader.result);
            }
            else {
                reject(new Error('unknown error reading blob'));
            }
        };
        fileReader.readAsText(blob);
    });
}
/**
 * Blob of binary data fetched from a local file (with FileReader).
 *
 * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in
 * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.
 */
class BlobFile {
    constructor(blob) {
        this.blob = blob;
        this.size = blob.size;
    }
    async read(buffer, offset = 0, length, position = 0) {
        // short-circuit a read of 0 bytes here, because browsers actually sometimes
        // crash if you try to read 0 bytes from a local file!
        if (!length) {
            return { bytesRead: 0, buffer };
        }
        const start = position;
        const end = start + length;
        const result = await readBlobAsArrayBuffer(this.blob.slice(start, end));
        const resultBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(result);
        const bytesCopied = resultBuffer.copy(buffer, offset);
        return { bytesRead: bytesCopied, buffer: resultBuffer };
    }
    async readFile(options) {
        let encoding;
        if (typeof options === 'string') {
            encoding = options;
        }
        else {
            encoding = options && options.encoding;
        }
        if (encoding === 'utf8') {
            return readBlobAsText(this.blob);
        }
        if (encoding) {
            throw new Error(`unsupported encoding: ${encoding}`);
        }
        const result = await readBlobAsArrayBuffer(this.blob);
        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(result);
    }
    async stat() {
        return { size: this.size };
    }
    async close() {
        return;
    }
}


/***/ }),

/***/ "./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/filehandle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/filehandle.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobFile": function() { return /* reexport safe */ _blobFile__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "LocalFile": function() { return /* reexport default from dynamic */ _localFile__WEBPACK_IMPORTED_MODULE_0___default.a; },
/* harmony export */   "RemoteFile": function() { return /* reexport safe */ _remoteFile__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "fromUrl": function() { return /* binding */ fromUrl; },
/* harmony export */   "open": function() { return /* binding */ open; }
/* harmony export */ });
/* harmony import */ var _localFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./localFile */ "?f1ee");
/* harmony import */ var _localFile__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_localFile__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _remoteFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./remoteFile */ "./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/remoteFile.js");
/* harmony import */ var _blobFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blobFile */ "./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/blobFile.js");
/* harmony import */ var _filehandle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filehandle */ "./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/filehandle.js");




function fromUrl(source, opts = {}) {
    return new _remoteFile__WEBPACK_IMPORTED_MODULE_1__["default"](source, opts);
}
function open(maybeUrl, maybePath, maybeFilehandle, opts = {}) {
    if (maybeFilehandle !== undefined) {
        return maybeFilehandle;
    }
    if (maybeUrl !== undefined) {
        return fromUrl(maybeUrl, opts);
    }
    if (maybePath !== undefined) {
        return new (_localFile__WEBPACK_IMPORTED_MODULE_0___default())(maybePath, opts);
    }
    throw new Error('no url, path, or filehandle provided, cannot open');
}



/***/ }),

/***/ "./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/remoteFile.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@gmod/bbi/node_modules/generic-filehandle/esm/remoteFile.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RemoteFile; }
/* harmony export */ });
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

const myGlobal = typeof window !== 'undefined'
    ? window
    : typeof self !== 'undefined'
        ? self
        : { fetch: undefined };
class RemoteFile {
    constructor(source, opts = {}) {
        this.baseOverrides = {};
        this.url = source;
        const fetch = opts.fetch || (myGlobal.fetch && myGlobal.fetch.bind(myGlobal));
        if (!fetch) {
            throw new TypeError(`no fetch function supplied, and none found in global environment`);
        }
        if (opts.overrides) {
            this.baseOverrides = opts.overrides;
        }
        this.fetchImplementation = fetch;
    }
    async getBufferFromResponse(response) {
        if (typeof response.buffer === 'function') {
            return response.buffer();
        }
        else if (typeof response.arrayBuffer === 'function') {
            const resp = await response.arrayBuffer();
            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(resp);
        }
        else {
            throw new TypeError('invalid HTTP response object, has no buffer method, and no arrayBuffer method');
        }
    }
    async fetch(input, init) {
        let response;
        try {
            response = await this.fetchImplementation(input, init);
        }
        catch (e) {
            if (`${e}`.includes('Failed to fetch')) {
                // refetch to to help work around a chrome bug (discussed in
                // generic-filehandle issue #72) in which the chrome cache returns a
                // CORS error for content in its cache.  see also
                // https://github.com/GMOD/jbrowse-components/pull/1511
                console.warn(`generic-filehandle: refetching ${input} to attempt to work around chrome CORS header caching bug`);
                response = await this.fetchImplementation(input, {
                    ...init,
                    cache: 'reload',
                });
            }
            else {
                throw e;
            }
        }
        return response;
    }
    async read(buffer, offset = 0, length, position = 0, opts = {}) {
        const { headers = {}, signal, overrides = {} } = opts;
        if (length < Infinity) {
            headers.range = `bytes=${position}-${position + length}`;
        }
        else if (length === Infinity && position !== 0) {
            headers.range = `bytes=${position}-`;
        }
        const args = {
            ...this.baseOverrides,
            ...overrides,
            headers: {
                ...headers,
                ...overrides.headers,
                ...this.baseOverrides.headers,
            },
            method: 'GET',
            redirect: 'follow',
            mode: 'cors',
            signal,
        };
        const response = await this.fetch(this.url, args);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status} ${response.statusText} ${this.url}`);
        }
        if ((response.status === 200 && position === 0) ||
            response.status === 206) {
            const responseData = await this.getBufferFromResponse(response);
            const bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length));
            // try to parse out the size of the remote file
            const res = response.headers.get('content-range');
            const sizeMatch = /\/(\d+)$/.exec(res || '');
            if (sizeMatch && sizeMatch[1]) {
                this._stat = { size: parseInt(sizeMatch[1], 10) };
            }
            return { bytesRead: bytesCopied, buffer };
        }
        if (response.status === 200) {
            throw new Error('${this.url} fetch returned status 200, expected 206');
        }
        // TODO: try harder here to gather more information about what the problem is
        throw new Error(`HTTP ${response.status} fetching ${this.url}`);
    }
    async readFile(options = {}) {
        let encoding;
        let opts;
        if (typeof options === 'string') {
            encoding = options;
            opts = {};
        }
        else {
            encoding = options.encoding;
            opts = options;
            delete opts.encoding;
        }
        const { headers = {}, signal, overrides = {} } = opts;
        const args = {
            headers,
            method: 'GET',
            redirect: 'follow',
            mode: 'cors',
            signal,
            ...this.baseOverrides,
            ...overrides,
        };
        const response = await this.fetch(this.url, args);
        if (!response) {
            throw new Error('generic-filehandle failed to fetch');
        }
        if (response.status !== 200) {
            throw Object.assign(new Error(`HTTP ${response.status} fetching ${this.url}`), {
                status: response.status,
            });
        }
        if (encoding === 'utf8') {
            return response.text();
        }
        if (encoding) {
            throw new Error(`unsupported encoding: ${encoding}`);
        }
        return this.getBufferFromResponse(response);
    }
    async stat() {
        if (!this._stat) {
            const buf = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.allocUnsafe(10);
            await this.read(buf, 0, 10, 0);
            if (!this._stat) {
                throw new Error(`unable to determine size of file at ${this.url}`);
            }
        }
        return this._stat;
    }
    async close() {
        return;
    }
}


/***/ }),

/***/ "./node_modules/@gmod/bbi/node_modules/quick-lru/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@gmod/bbi/node_modules/quick-lru/index.js ***!
  \****************************************************************/
/***/ (function(module) {



class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;
			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return this._size + oldCacheSize;
	}
}

module.exports = QuickLRU;


/***/ }),

/***/ "./node_modules/binary-parser/dist/esm/binary_parser.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/binary-parser/dist/esm/binary_parser.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Parser": function() { return /* binding */ Parser; }
/* harmony export */ });
class Context {
    constructor(importPath, useContextVariables) {
        this.code = "";
        this.scopes = [["vars"]];
        this.bitFields = [];
        this.tmpVariableCount = 0;
        this.references = new Map();
        this.imports = [];
        this.reverseImports = new Map();
        this.useContextVariables = false;
        this.importPath = importPath;
        this.useContextVariables = useContextVariables;
    }
    generateVariable(name) {
        const scopes = [...this.scopes[this.scopes.length - 1]];
        if (name) {
            scopes.push(name);
        }
        return scopes.join(".");
    }
    generateOption(val) {
        switch (typeof val) {
            case "number":
                return val.toString();
            case "string":
                return this.generateVariable(val);
            case "function":
                return `${this.addImport(val)}.call(${this.generateVariable()}, vars)`;
        }
    }
    generateError(err) {
        this.pushCode(`throw new Error(${err});`);
    }
    generateTmpVariable() {
        return "$tmp" + this.tmpVariableCount++;
    }
    pushCode(code) {
        this.code += code + "\n";
    }
    pushPath(name) {
        if (name) {
            this.scopes[this.scopes.length - 1].push(name);
        }
    }
    popPath(name) {
        if (name) {
            this.scopes[this.scopes.length - 1].pop();
        }
    }
    pushScope(name) {
        this.scopes.push([name]);
    }
    popScope() {
        this.scopes.pop();
    }
    addImport(im) {
        if (!this.importPath)
            return `(${im})`;
        let id = this.reverseImports.get(im);
        if (!id) {
            id = this.imports.push(im) - 1;
            this.reverseImports.set(im, id);
        }
        return `${this.importPath}[${id}]`;
    }
    addReference(alias) {
        if (!this.references.has(alias)) {
            this.references.set(alias, { resolved: false, requested: false });
        }
    }
    markResolved(alias) {
        const reference = this.references.get(alias);
        if (reference) {
            reference.resolved = true;
        }
    }
    markRequested(aliasList) {
        aliasList.forEach((alias) => {
            const reference = this.references.get(alias);
            if (reference) {
                reference.requested = true;
            }
        });
    }
    getUnresolvedReferences() {
        return Array.from(this.references)
            .filter(([_, reference]) => !reference.resolved && !reference.requested)
            .map(([alias, _]) => alias);
    }
}
const aliasRegistry = new Map();
const FUNCTION_PREFIX = "___parser_";
const PRIMITIVE_SIZES = {
    uint8: 1,
    uint16le: 2,
    uint16be: 2,
    uint32le: 4,
    uint32be: 4,
    int8: 1,
    int16le: 2,
    int16be: 2,
    int32le: 4,
    int32be: 4,
    int64be: 8,
    int64le: 8,
    uint64be: 8,
    uint64le: 8,
    floatle: 4,
    floatbe: 4,
    doublele: 8,
    doublebe: 8,
};
const PRIMITIVE_NAMES = {
    uint8: "Uint8",
    uint16le: "Uint16",
    uint16be: "Uint16",
    uint32le: "Uint32",
    uint32be: "Uint32",
    int8: "Int8",
    int16le: "Int16",
    int16be: "Int16",
    int32le: "Int32",
    int32be: "Int32",
    int64be: "BigInt64",
    int64le: "BigInt64",
    uint64be: "BigUint64",
    uint64le: "BigUint64",
    floatle: "Float32",
    floatbe: "Float32",
    doublele: "Float64",
    doublebe: "Float64",
};
const PRIMITIVE_LITTLE_ENDIANS = {
    uint8: false,
    uint16le: true,
    uint16be: false,
    uint32le: true,
    uint32be: false,
    int8: false,
    int16le: true,
    int16be: false,
    int32le: true,
    int32be: false,
    int64be: false,
    int64le: true,
    uint64be: false,
    uint64le: true,
    floatle: true,
    floatbe: false,
    doublele: true,
    doublebe: false,
};
class Parser {
    constructor() {
        this.varName = "";
        this.type = "";
        this.options = {};
        this.endian = "be";
        this.useContextVariables = false;
    }
    static start() {
        return new Parser();
    }
    primitiveGenerateN(type, ctx) {
        const typeName = PRIMITIVE_NAMES[type];
        const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type];
        ctx.pushCode(`${ctx.generateVariable(this.varName)} = dataView.get${typeName}(offset, ${littleEndian});`);
        ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type]};`);
    }
    primitiveN(type, varName, options) {
        return this.setNextParser(type, varName, options);
    }
    useThisEndian(type) {
        return (type + this.endian.toLowerCase());
    }
    uint8(varName, options = {}) {
        return this.primitiveN("uint8", varName, options);
    }
    uint16(varName, options = {}) {
        return this.primitiveN(this.useThisEndian("uint16"), varName, options);
    }
    uint16le(varName, options = {}) {
        return this.primitiveN("uint16le", varName, options);
    }
    uint16be(varName, options = {}) {
        return this.primitiveN("uint16be", varName, options);
    }
    uint32(varName, options = {}) {
        return this.primitiveN(this.useThisEndian("uint32"), varName, options);
    }
    uint32le(varName, options = {}) {
        return this.primitiveN("uint32le", varName, options);
    }
    uint32be(varName, options = {}) {
        return this.primitiveN("uint32be", varName, options);
    }
    int8(varName, options = {}) {
        return this.primitiveN("int8", varName, options);
    }
    int16(varName, options = {}) {
        return this.primitiveN(this.useThisEndian("int16"), varName, options);
    }
    int16le(varName, options = {}) {
        return this.primitiveN("int16le", varName, options);
    }
    int16be(varName, options = {}) {
        return this.primitiveN("int16be", varName, options);
    }
    int32(varName, options = {}) {
        return this.primitiveN(this.useThisEndian("int32"), varName, options);
    }
    int32le(varName, options = {}) {
        return this.primitiveN("int32le", varName, options);
    }
    int32be(varName, options = {}) {
        return this.primitiveN("int32be", varName, options);
    }
    bigIntVersionCheck() {
        if (!DataView.prototype.getBigInt64)
            throw new Error("BigInt64 is unsupported on this runtime");
    }
    int64(varName, options = {}) {
        this.bigIntVersionCheck();
        return this.primitiveN(this.useThisEndian("int64"), varName, options);
    }
    int64be(varName, options = {}) {
        this.bigIntVersionCheck();
        return this.primitiveN("int64be", varName, options);
    }
    int64le(varName, options = {}) {
        this.bigIntVersionCheck();
        return this.primitiveN("int64le", varName, options);
    }
    uint64(varName, options = {}) {
        this.bigIntVersionCheck();
        return this.primitiveN(this.useThisEndian("uint64"), varName, options);
    }
    uint64be(varName, options = {}) {
        this.bigIntVersionCheck();
        return this.primitiveN("uint64be", varName, options);
    }
    uint64le(varName, options = {}) {
        this.bigIntVersionCheck();
        return this.primitiveN("uint64le", varName, options);
    }
    floatle(varName, options = {}) {
        return this.primitiveN("floatle", varName, options);
    }
    floatbe(varName, options = {}) {
        return this.primitiveN("floatbe", varName, options);
    }
    doublele(varName, options = {}) {
        return this.primitiveN("doublele", varName, options);
    }
    doublebe(varName, options = {}) {
        return this.primitiveN("doublebe", varName, options);
    }
    bitN(size, varName, options) {
        options.length = size;
        return this.setNextParser("bit", varName, options);
    }
    bit1(varName, options = {}) {
        return this.bitN(1, varName, options);
    }
    bit2(varName, options = {}) {
        return this.bitN(2, varName, options);
    }
    bit3(varName, options = {}) {
        return this.bitN(3, varName, options);
    }
    bit4(varName, options = {}) {
        return this.bitN(4, varName, options);
    }
    bit5(varName, options = {}) {
        return this.bitN(5, varName, options);
    }
    bit6(varName, options = {}) {
        return this.bitN(6, varName, options);
    }
    bit7(varName, options = {}) {
        return this.bitN(7, varName, options);
    }
    bit8(varName, options = {}) {
        return this.bitN(8, varName, options);
    }
    bit9(varName, options = {}) {
        return this.bitN(9, varName, options);
    }
    bit10(varName, options = {}) {
        return this.bitN(10, varName, options);
    }
    bit11(varName, options = {}) {
        return this.bitN(11, varName, options);
    }
    bit12(varName, options = {}) {
        return this.bitN(12, varName, options);
    }
    bit13(varName, options = {}) {
        return this.bitN(13, varName, options);
    }
    bit14(varName, options = {}) {
        return this.bitN(14, varName, options);
    }
    bit15(varName, options = {}) {
        return this.bitN(15, varName, options);
    }
    bit16(varName, options = {}) {
        return this.bitN(16, varName, options);
    }
    bit17(varName, options = {}) {
        return this.bitN(17, varName, options);
    }
    bit18(varName, options = {}) {
        return this.bitN(18, varName, options);
    }
    bit19(varName, options = {}) {
        return this.bitN(19, varName, options);
    }
    bit20(varName, options = {}) {
        return this.bitN(20, varName, options);
    }
    bit21(varName, options = {}) {
        return this.bitN(21, varName, options);
    }
    bit22(varName, options = {}) {
        return this.bitN(22, varName, options);
    }
    bit23(varName, options = {}) {
        return this.bitN(23, varName, options);
    }
    bit24(varName, options = {}) {
        return this.bitN(24, varName, options);
    }
    bit25(varName, options = {}) {
        return this.bitN(25, varName, options);
    }
    bit26(varName, options = {}) {
        return this.bitN(26, varName, options);
    }
    bit27(varName, options = {}) {
        return this.bitN(27, varName, options);
    }
    bit28(varName, options = {}) {
        return this.bitN(28, varName, options);
    }
    bit29(varName, options = {}) {
        return this.bitN(29, varName, options);
    }
    bit30(varName, options = {}) {
        return this.bitN(30, varName, options);
    }
    bit31(varName, options = {}) {
        return this.bitN(31, varName, options);
    }
    bit32(varName, options = {}) {
        return this.bitN(32, varName, options);
    }
    namely(alias) {
        aliasRegistry.set(alias, this);
        this.alias = alias;
        return this;
    }
    skip(length, options = {}) {
        return this.seek(length, options);
    }
    seek(relOffset, options = {}) {
        if (options.assert) {
            throw new Error("assert option on seek is not allowed.");
        }
        return this.setNextParser("seek", "", { length: relOffset });
    }
    string(varName, options) {
        if (!options.zeroTerminated && !options.length && !options.greedy) {
            throw new Error("One of length, zeroTerminated, or greedy must be defined for string.");
        }
        if ((options.zeroTerminated || options.length) && options.greedy) {
            throw new Error("greedy is mutually exclusive with length and zeroTerminated for string.");
        }
        if (options.stripNull && !(options.length || options.greedy)) {
            throw new Error("length or greedy must be defined if stripNull is enabled.");
        }
        options.encoding = options.encoding || "utf8";
        return this.setNextParser("string", varName, options);
    }
    buffer(varName, options) {
        if (!options.length && !options.readUntil) {
            throw new Error("length or readUntil must be defined for buffer.");
        }
        return this.setNextParser("buffer", varName, options);
    }
    wrapped(varName, options) {
        if (!options.length && !options.readUntil) {
            throw new Error("length or readUntil must be defined for wrapped.");
        }
        if (!options.wrapper || !options.type) {
            throw new Error("Both wrapper and type must be defined for wrapped.");
        }
        return this.setNextParser("wrapper", varName, options);
    }
    array(varName, options) {
        if (!options.readUntil && !options.length && !options.lengthInBytes) {
            throw new Error("One of readUntil, length and lengthInBytes must be defined for array.");
        }
        if (!options.type) {
            throw new Error("type is required for array.");
        }
        if (typeof options.type === "string" &&
            !aliasRegistry.has(options.type) &&
            !(options.type in PRIMITIVE_SIZES)) {
            throw new Error(`Array element type "${options.type}" is unkown.`);
        }
        return this.setNextParser("array", varName, options);
    }
    choice(varName, options) {
        if (typeof options !== "object" && typeof varName === "object") {
            options = varName;
            varName = "";
        }
        if (!options) {
            throw new Error("tag and choices are are required for choice.");
        }
        if (!options.tag) {
            throw new Error("tag is requird for choice.");
        }
        if (!options.choices) {
            throw new Error("choices is required for choice.");
        }
        for (const keyString in options.choices) {
            const key = parseInt(keyString, 10);
            const value = options.choices[key];
            if (isNaN(key)) {
                throw new Error(`Choice key "${keyString}" is not a number.`);
            }
            if (typeof value === "string" &&
                !aliasRegistry.has(value) &&
                !(value in PRIMITIVE_SIZES)) {
                throw new Error(`Choice type "${value}" is unkown.`);
            }
        }
        return this.setNextParser("choice", varName, options);
    }
    nest(varName, options) {
        if (typeof options !== "object" && typeof varName === "object") {
            options = varName;
            varName = "";
        }
        if (!options || !options.type) {
            throw new Error("type is required for nest.");
        }
        if (!(options.type instanceof Parser) && !aliasRegistry.has(options.type)) {
            throw new Error("type must be a known parser name or a Parser object.");
        }
        if (!(options.type instanceof Parser) && !varName) {
            throw new Error("type must be a Parser object if the variable name is omitted.");
        }
        return this.setNextParser("nest", varName, options || {});
    }
    pointer(varName, options) {
        if (!options.offset) {
            throw new Error("offset is required for pointer.");
        }
        if (!options.type) {
            throw new Error("type is required for pointer.");
        }
        if (typeof options.type === "string" &&
            !(options.type in PRIMITIVE_SIZES) &&
            !aliasRegistry.has(options.type)) {
            throw new Error(`Pointer type "${options.type}" is unkown.`);
        }
        return this.setNextParser("pointer", varName, options);
    }
    saveOffset(varName, options = {}) {
        return this.setNextParser("saveOffset", varName, options);
    }
    endianness(endianness) {
        switch (endianness.toLowerCase()) {
            case "little":
                this.endian = "le";
                break;
            case "big":
                this.endian = "be";
                break;
            default:
                throw new Error('endianness must be one of "little" or "big"');
        }
        return this;
    }
    endianess(endianess) {
        return this.endianness(endianess);
    }
    useContextVars(useContextVariables = true) {
        this.useContextVariables = useContextVariables;
        return this;
    }
    create(constructorFn) {
        if (!(constructorFn instanceof Function)) {
            throw new Error("Constructor must be a Function object.");
        }
        this.constructorFn = constructorFn;
        return this;
    }
    getContext(importPath) {
        const ctx = new Context(importPath, this.useContextVariables);
        ctx.pushCode("var dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);");
        if (!this.alias) {
            this.addRawCode(ctx);
        }
        else {
            this.addAliasedCode(ctx);
            ctx.pushCode(`return ${FUNCTION_PREFIX + this.alias}(0).result;`);
        }
        return ctx;
    }
    getCode() {
        const importPath = "imports";
        return this.getContext(importPath).code;
    }
    addRawCode(ctx) {
        ctx.pushCode("var offset = 0;");
        ctx.pushCode(`var vars = ${this.constructorFn ? "new constructorFn()" : "{}"};`);
        ctx.pushCode("vars.$parent = null;");
        ctx.pushCode("vars.$root = vars;");
        this.generate(ctx);
        this.resolveReferences(ctx);
        ctx.pushCode("delete vars.$parent;");
        ctx.pushCode("delete vars.$root;");
        ctx.pushCode("return vars;");
    }
    addAliasedCode(ctx) {
        ctx.pushCode(`function ${FUNCTION_PREFIX + this.alias}(offset, context) {`);
        ctx.pushCode(`var vars = ${this.constructorFn ? "new constructorFn()" : "{}"};`);
        ctx.pushCode("var ctx = Object.assign({$parent: null, $root: vars}, context || {});");
        ctx.pushCode(`vars = Object.assign(vars, ctx);`);
        this.generate(ctx);
        ctx.markResolved(this.alias);
        this.resolveReferences(ctx);
        ctx.pushCode("Object.keys(ctx).forEach(function (item) { delete vars[item]; });");
        ctx.pushCode("return { offset: offset, result: vars };");
        ctx.pushCode("}");
        return ctx;
    }
    resolveReferences(ctx) {
        const references = ctx.getUnresolvedReferences();
        ctx.markRequested(references);
        references.forEach((alias) => {
            var _a;
            (_a = aliasRegistry.get(alias)) === null || _a === void 0 ? void 0 : _a.addAliasedCode(ctx);
        });
    }
    compile() {
        const importPath = "imports";
        const ctx = this.getContext(importPath);
        this.compiled = new Function(importPath, "TextDecoder", `return function (buffer, constructorFn) { ${ctx.code} };`)(ctx.imports, TextDecoder);
    }
    sizeOf() {
        let size = NaN;
        if (Object.keys(PRIMITIVE_SIZES).indexOf(this.type) >= 0) {
            size = PRIMITIVE_SIZES[this.type];
            // if this is a fixed length string
        }
        else if (this.type === "string" &&
            typeof this.options.length === "number") {
            size = this.options.length;
            // if this is a fixed length buffer
        }
        else if (this.type === "buffer" &&
            typeof this.options.length === "number") {
            size = this.options.length;
            // if this is a fixed length array
        }
        else if (this.type === "array" &&
            typeof this.options.length === "number") {
            let elementSize = NaN;
            if (typeof this.options.type === "string") {
                elementSize = PRIMITIVE_SIZES[this.options.type];
            }
            else if (this.options.type instanceof Parser) {
                elementSize = this.options.type.sizeOf();
            }
            size = this.options.length * elementSize;
            // if this a skip
        }
        else if (this.type === "seek") {
            size = this.options.length;
            // if this is a nested parser
        }
        else if (this.type === "nest") {
            size = this.options.type.sizeOf();
        }
        else if (!this.type) {
            size = 0;
        }
        if (this.next) {
            size += this.next.sizeOf();
        }
        return size;
    }
    // Follow the parser chain till the root and start parsing from there
    parse(buffer) {
        if (!this.compiled) {
            this.compile();
        }
        return this.compiled(buffer, this.constructorFn);
    }
    setNextParser(type, varName, options) {
        const parser = new Parser();
        parser.type = type;
        parser.varName = varName;
        parser.options = options;
        parser.endian = this.endian;
        if (this.head) {
            this.head.next = parser;
        }
        else {
            this.next = parser;
        }
        this.head = parser;
        return this;
    }
    // Call code generator for this parser
    generate(ctx) {
        if (this.type) {
            switch (this.type) {
                case "uint8":
                case "uint16le":
                case "uint16be":
                case "uint32le":
                case "uint32be":
                case "int8":
                case "int16le":
                case "int16be":
                case "int32le":
                case "int32be":
                case "int64be":
                case "int64le":
                case "uint64be":
                case "uint64le":
                case "floatle":
                case "floatbe":
                case "doublele":
                case "doublebe":
                    this.primitiveGenerateN(this.type, ctx);
                    break;
                case "bit":
                    this.generateBit(ctx);
                    break;
                case "string":
                    this.generateString(ctx);
                    break;
                case "buffer":
                    this.generateBuffer(ctx);
                    break;
                case "seek":
                    this.generateSeek(ctx);
                    break;
                case "nest":
                    this.generateNest(ctx);
                    break;
                case "array":
                    this.generateArray(ctx);
                    break;
                case "choice":
                    this.generateChoice(ctx);
                    break;
                case "pointer":
                    this.generatePointer(ctx);
                    break;
                case "saveOffset":
                    this.generateSaveOffset(ctx);
                    break;
                case "wrapper":
                    this.generateWrapper(ctx);
                    break;
            }
            if (this.type !== "bit")
                this.generateAssert(ctx);
        }
        const varName = ctx.generateVariable(this.varName);
        if (this.options.formatter && this.type !== "bit") {
            this.generateFormatter(ctx, varName, this.options.formatter);
        }
        return this.generateNext(ctx);
    }
    generateAssert(ctx) {
        if (!this.options.assert) {
            return;
        }
        const varName = ctx.generateVariable(this.varName);
        switch (typeof this.options.assert) {
            case "function":
                {
                    const func = ctx.addImport(this.options.assert);
                    ctx.pushCode(`if (!${func}.call(vars, ${varName})) {`);
                }
                break;
            case "number":
                ctx.pushCode(`if (${this.options.assert} !== ${varName}) {`);
                break;
            case "string":
                ctx.pushCode(`if (${JSON.stringify(this.options.assert)} !== ${varName}) {`);
                break;
            default:
                throw new Error("assert option must be a string, number or a function.");
        }
        ctx.generateError(`"Assertion error: ${varName} is " + ${JSON.stringify(this.options.assert.toString())}`);
        ctx.pushCode("}");
    }
    // Recursively call code generators and append results
    generateNext(ctx) {
        if (this.next) {
            ctx = this.next.generate(ctx);
        }
        return ctx;
    }
    generateBit(ctx) {
        // TODO find better method to handle nested bit fields
        const parser = JSON.parse(JSON.stringify(this));
        parser.options = this.options;
        parser.generateAssert = this.generateAssert.bind(this);
        parser.generateFormatter = this.generateFormatter.bind(this);
        parser.varName = ctx.generateVariable(parser.varName);
        ctx.bitFields.push(parser);
        if (!this.next ||
            (this.next && ["bit", "nest"].indexOf(this.next.type) < 0)) {
            const val = ctx.generateTmpVariable();
            ctx.pushCode(`var ${val} = 0;`);
            const getMaxBits = (from = 0) => {
                let sum = 0;
                for (let i = from; i < ctx.bitFields.length; i++) {
                    const length = ctx.bitFields[i].options.length;
                    if (sum + length > 32)
                        break;
                    sum += length;
                }
                return sum;
            };
            const getBytes = (sum) => {
                if (sum <= 8) {
                    ctx.pushCode(`${val} = dataView.getUint8(offset);`);
                    sum = 8;
                }
                else if (sum <= 16) {
                    ctx.pushCode(`${val} = dataView.getUint16(offset);`);
                    sum = 16;
                }
                else if (sum <= 24) {
                    ctx.pushCode(`${val} = (dataView.getUint16(offset) << 8) | dataView.getUint8(offset + 2);`);
                    sum = 24;
                }
                else {
                    ctx.pushCode(`${val} = dataView.getUint32(offset);`);
                    sum = 32;
                }
                ctx.pushCode(`offset += ${sum / 8};`);
                return sum;
            };
            let bitOffset = 0;
            const isBigEndian = this.endian === "be";
            let sum = 0;
            let rem = 0;
            ctx.bitFields.forEach((parser, i) => {
                let length = parser.options.length;
                if (length > rem) {
                    if (rem) {
                        const mask = -1 >>> (32 - rem);
                        ctx.pushCode(`${parser.varName} = (${val} & 0x${mask.toString(16)}) << ${length - rem};`);
                        length -= rem;
                    }
                    bitOffset = 0;
                    rem = sum = getBytes(getMaxBits(i) - rem);
                }
                const offset = isBigEndian ? sum - bitOffset - length : bitOffset;
                const mask = -1 >>> (32 - length);
                ctx.pushCode(`${parser.varName} ${length < parser.options.length ? "|=" : "="} ${val} >> ${offset} & 0x${mask.toString(16)};`);
                // Ensure value is unsigned
                if (parser.options.length === 32) {
                    ctx.pushCode(`${parser.varName} >>>= 0`);
                }
                if (parser.options.assert) {
                    parser.generateAssert(ctx);
                }
                if (parser.options.formatter) {
                    parser.generateFormatter(ctx, parser.varName, parser.options.formatter);
                }
                bitOffset += length;
                rem -= length;
            });
            ctx.bitFields = [];
        }
    }
    generateSeek(ctx) {
        const length = ctx.generateOption(this.options.length);
        ctx.pushCode(`offset += ${length};`);
    }
    generateString(ctx) {
        const name = ctx.generateVariable(this.varName);
        const start = ctx.generateTmpVariable();
        const encoding = this.options.encoding;
        const isHex = encoding.toLowerCase() === "hex";
        const toHex = 'b => b.toString(16).padStart(2, "0")';
        if (this.options.length && this.options.zeroTerminated) {
            const len = this.options.length;
            ctx.pushCode(`var ${start} = offset;`);
            ctx.pushCode(`while(dataView.getUint8(offset++) !== 0 && offset - ${start} < ${len});`);
            const end = `offset - ${start} < ${len} ? offset - 1 : offset`;
            ctx.pushCode(isHex
                ? `${name} = Array.from(buffer.subarray(${start}, ${end}), ${toHex}).join('');`
                : `${name} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, ${end}));`);
        }
        else if (this.options.length) {
            const len = ctx.generateOption(this.options.length);
            ctx.pushCode(isHex
                ? `${name} = Array.from(buffer.subarray(offset, offset + ${len}), ${toHex}).join('');`
                : `${name} = new TextDecoder('${encoding}').decode(buffer.subarray(offset, offset + ${len}));`);
            ctx.pushCode(`offset += ${len};`);
        }
        else if (this.options.zeroTerminated) {
            ctx.pushCode(`var ${start} = offset;`);
            ctx.pushCode("while(dataView.getUint8(offset++) !== 0);");
            ctx.pushCode(isHex
                ? `${name} = Array.from(buffer.subarray(${start}, offset - 1), ${toHex}).join('');`
                : `${name} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, offset - 1));`);
        }
        else if (this.options.greedy) {
            ctx.pushCode(`var ${start} = offset;`);
            ctx.pushCode("while(buffer.length > offset++);");
            ctx.pushCode(isHex
                ? `${name} = Array.from(buffer.subarray(${start}, offset), ${toHex}).join('');`
                : `${name} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, offset));`);
        }
        if (this.options.stripNull) {
            ctx.pushCode(`${name} = ${name}.replace(/\\x00+$/g, '')`);
        }
    }
    generateBuffer(ctx) {
        const varName = ctx.generateVariable(this.varName);
        if (typeof this.options.readUntil === "function") {
            const pred = this.options.readUntil;
            const start = ctx.generateTmpVariable();
            const cur = ctx.generateTmpVariable();
            ctx.pushCode(`var ${start} = offset;`);
            ctx.pushCode(`var ${cur} = 0;`);
            ctx.pushCode(`while (offset < buffer.length) {`);
            ctx.pushCode(`${cur} = dataView.getUint8(offset);`);
            const func = ctx.addImport(pred);
            ctx.pushCode(`if (${func}.call(${ctx.generateVariable()}, ${cur}, buffer.subarray(offset))) break;`);
            ctx.pushCode(`offset += 1;`);
            ctx.pushCode(`}`);
            ctx.pushCode(`${varName} = buffer.subarray(${start}, offset);`);
        }
        else if (this.options.readUntil === "eof") {
            ctx.pushCode(`${varName} = buffer.subarray(offset);`);
        }
        else {
            const len = ctx.generateOption(this.options.length);
            ctx.pushCode(`${varName} = buffer.subarray(offset, offset + ${len});`);
            ctx.pushCode(`offset += ${len};`);
        }
        if (this.options.clone) {
            ctx.pushCode(`${varName} = buffer.constructor.from(${varName});`);
        }
    }
    generateArray(ctx) {
        const length = ctx.generateOption(this.options.length);
        const lengthInBytes = ctx.generateOption(this.options.lengthInBytes);
        const type = this.options.type;
        const counter = ctx.generateTmpVariable();
        const lhs = ctx.generateVariable(this.varName);
        const item = ctx.generateTmpVariable();
        const key = this.options.key;
        const isHash = typeof key === "string";
        if (isHash) {
            ctx.pushCode(`${lhs} = {};`);
        }
        else {
            ctx.pushCode(`${lhs} = [];`);
        }
        if (typeof this.options.readUntil === "function") {
            ctx.pushCode("do {");
        }
        else if (this.options.readUntil === "eof") {
            ctx.pushCode(`for (var ${counter} = 0; offset < buffer.length; ${counter}++) {`);
        }
        else if (lengthInBytes !== undefined) {
            ctx.pushCode(`for (var ${counter} = offset + ${lengthInBytes}; offset < ${counter}; ) {`);
        }
        else {
            ctx.pushCode(`for (var ${counter} = ${length}; ${counter} > 0; ${counter}--) {`);
        }
        if (typeof type === "string") {
            if (!aliasRegistry.get(type)) {
                const typeName = PRIMITIVE_NAMES[type];
                const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type];
                ctx.pushCode(`var ${item} = dataView.get${typeName}(offset, ${littleEndian});`);
                ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type]};`);
            }
            else {
                const tempVar = ctx.generateTmpVariable();
                ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + type}(offset, {`);
                if (ctx.useContextVariables) {
                    const parentVar = ctx.generateVariable();
                    ctx.pushCode(`$parent: ${parentVar},`);
                    ctx.pushCode(`$root: ${parentVar}.$root,`);
                    if (!this.options.readUntil && lengthInBytes === undefined) {
                        ctx.pushCode(`$index: ${length} - ${counter},`);
                    }
                }
                ctx.pushCode(`});`);
                ctx.pushCode(`var ${item} = ${tempVar}.result; offset = ${tempVar}.offset;`);
                if (type !== this.alias)
                    ctx.addReference(type);
            }
        }
        else if (type instanceof Parser) {
            ctx.pushCode(`var ${item} = {};`);
            const parentVar = ctx.generateVariable();
            ctx.pushScope(item);
            if (ctx.useContextVariables) {
                ctx.pushCode(`${item}.$parent = ${parentVar};`);
                ctx.pushCode(`${item}.$root = ${parentVar}.$root;`);
                if (!this.options.readUntil && lengthInBytes === undefined) {
                    ctx.pushCode(`${item}.$index = ${length} - ${counter};`);
                }
            }
            type.generate(ctx);
            if (ctx.useContextVariables) {
                ctx.pushCode(`delete ${item}.$parent;`);
                ctx.pushCode(`delete ${item}.$root;`);
                ctx.pushCode(`delete ${item}.$index;`);
            }
            ctx.popScope();
        }
        if (isHash) {
            ctx.pushCode(`${lhs}[${item}.${key}] = ${item};`);
        }
        else {
            ctx.pushCode(`${lhs}.push(${item});`);
        }
        ctx.pushCode("}");
        if (typeof this.options.readUntil === "function") {
            const pred = this.options.readUntil;
            const func = ctx.addImport(pred);
            ctx.pushCode(`while (!${func}.call(${ctx.generateVariable()}, ${item}, buffer.subarray(offset)));`);
        }
    }
    generateChoiceCase(ctx, varName, type) {
        if (typeof type === "string") {
            const varName = ctx.generateVariable(this.varName);
            if (!aliasRegistry.has(type)) {
                const typeName = PRIMITIVE_NAMES[type];
                const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type];
                ctx.pushCode(`${varName} = dataView.get${typeName}(offset, ${littleEndian});`);
                ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type]}`);
            }
            else {
                const tempVar = ctx.generateTmpVariable();
                ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + type}(offset, {`);
                if (ctx.useContextVariables) {
                    ctx.pushCode(`$parent: ${varName}.$parent,`);
                    ctx.pushCode(`$root: ${varName}.$root,`);
                }
                ctx.pushCode(`});`);
                ctx.pushCode(`${varName} = ${tempVar}.result; offset = ${tempVar}.offset;`);
                if (type !== this.alias)
                    ctx.addReference(type);
            }
        }
        else if (type instanceof Parser) {
            ctx.pushPath(varName);
            type.generate(ctx);
            ctx.popPath(varName);
        }
    }
    generateChoice(ctx) {
        const tag = ctx.generateOption(this.options.tag);
        const nestVar = ctx.generateVariable(this.varName);
        if (this.varName) {
            ctx.pushCode(`${nestVar} = {};`);
            if (ctx.useContextVariables) {
                const parentVar = ctx.generateVariable();
                ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
                ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
            }
        }
        ctx.pushCode(`switch(${tag}) {`);
        for (const tagString in this.options.choices) {
            const tag = parseInt(tagString, 10);
            const type = this.options.choices[tag];
            ctx.pushCode(`case ${tag}:`);
            this.generateChoiceCase(ctx, this.varName, type);
            ctx.pushCode("break;");
        }
        ctx.pushCode("default:");
        if (this.options.defaultChoice) {
            this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);
        }
        else {
            ctx.generateError(`"Met undefined tag value " + ${tag} + " at choice"`);
        }
        ctx.pushCode("}");
        if (this.varName && ctx.useContextVariables) {
            ctx.pushCode(`delete ${nestVar}.$parent;`);
            ctx.pushCode(`delete ${nestVar}.$root;`);
        }
    }
    generateNest(ctx) {
        const nestVar = ctx.generateVariable(this.varName);
        if (this.options.type instanceof Parser) {
            if (this.varName) {
                ctx.pushCode(`${nestVar} = {};`);
                if (ctx.useContextVariables) {
                    const parentVar = ctx.generateVariable();
                    ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
                    ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
                }
            }
            ctx.pushPath(this.varName);
            this.options.type.generate(ctx);
            ctx.popPath(this.varName);
            if (this.varName && ctx.useContextVariables) {
                if (ctx.useContextVariables) {
                    ctx.pushCode(`delete ${nestVar}.$parent;`);
                    ctx.pushCode(`delete ${nestVar}.$root;`);
                }
            }
        }
        else if (aliasRegistry.has(this.options.type)) {
            const tempVar = ctx.generateTmpVariable();
            ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + this.options.type}(offset, {`);
            if (ctx.useContextVariables) {
                const parentVar = ctx.generateVariable();
                ctx.pushCode(`$parent: ${parentVar},`);
                ctx.pushCode(`$root: ${parentVar}.$root,`);
            }
            ctx.pushCode(`});`);
            ctx.pushCode(`${nestVar} = ${tempVar}.result; offset = ${tempVar}.offset;`);
            if (this.options.type !== this.alias) {
                ctx.addReference(this.options.type);
            }
        }
    }
    generateWrapper(ctx) {
        const wrapperVar = ctx.generateVariable(this.varName);
        const wrappedBuf = ctx.generateTmpVariable();
        if (typeof this.options.readUntil === "function") {
            const pred = this.options.readUntil;
            const start = ctx.generateTmpVariable();
            const cur = ctx.generateTmpVariable();
            ctx.pushCode(`var ${start} = offset;`);
            ctx.pushCode(`var ${cur} = 0;`);
            ctx.pushCode(`while (offset < buffer.length) {`);
            ctx.pushCode(`${cur} = dataView.getUint8(offset);`);
            const func = ctx.addImport(pred);
            ctx.pushCode(`if (${func}.call(${ctx.generateVariable()}, ${cur}, buffer.subarray(offset))) break;`);
            ctx.pushCode(`offset += 1;`);
            ctx.pushCode(`}`);
            ctx.pushCode(`${wrappedBuf} = buffer.subarray(${start}, offset);`);
        }
        else if (this.options.readUntil === "eof") {
            ctx.pushCode(`${wrappedBuf} = buffer.subarray(offset);`);
        }
        else {
            const len = ctx.generateOption(this.options.length);
            ctx.pushCode(`${wrappedBuf} = buffer.subarray(offset, offset + ${len});`);
            ctx.pushCode(`offset += ${len};`);
        }
        if (this.options.clone) {
            ctx.pushCode(`${wrappedBuf} = buffer.constructor.from(${wrappedBuf});`);
        }
        const tempBuf = ctx.generateTmpVariable();
        const tempOff = ctx.generateTmpVariable();
        const tempView = ctx.generateTmpVariable();
        const func = ctx.addImport(this.options.wrapper);
        ctx.pushCode(`${wrappedBuf} = ${func}.call(this, ${wrappedBuf}).subarray(0);`);
        ctx.pushCode(`var ${tempBuf} = buffer;`);
        ctx.pushCode(`var ${tempOff} = offset;`);
        ctx.pushCode(`var ${tempView} = dataView;`);
        ctx.pushCode(`buffer = ${wrappedBuf};`);
        ctx.pushCode(`offset = 0;`);
        ctx.pushCode(`dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);`);
        if (this.options.type instanceof Parser) {
            if (this.varName) {
                ctx.pushCode(`${wrapperVar} = {};`);
            }
            ctx.pushPath(this.varName);
            this.options.type.generate(ctx);
            ctx.popPath(this.varName);
        }
        else if (aliasRegistry.has(this.options.type)) {
            const tempVar = ctx.generateTmpVariable();
            ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + this.options.type}(0);`);
            ctx.pushCode(`${wrapperVar} = ${tempVar}.result;`);
            if (this.options.type !== this.alias) {
                ctx.addReference(this.options.type);
            }
        }
        ctx.pushCode(`buffer = ${tempBuf};`);
        ctx.pushCode(`dataView = ${tempView};`);
        ctx.pushCode(`offset = ${tempOff};`);
    }
    generateFormatter(ctx, varName, formatter) {
        if (typeof formatter === "function") {
            const func = ctx.addImport(formatter);
            ctx.pushCode(`${varName} = ${func}.call(${ctx.generateVariable()}, ${varName});`);
        }
    }
    generatePointer(ctx) {
        const type = this.options.type;
        const offset = ctx.generateOption(this.options.offset);
        const tempVar = ctx.generateTmpVariable();
        const nestVar = ctx.generateVariable(this.varName);
        // Save current offset
        ctx.pushCode(`var ${tempVar} = offset;`);
        // Move offset
        ctx.pushCode(`offset = ${offset};`);
        if (this.options.type instanceof Parser) {
            ctx.pushCode(`${nestVar} = {};`);
            if (ctx.useContextVariables) {
                const parentVar = ctx.generateVariable();
                ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
                ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
            }
            ctx.pushPath(this.varName);
            this.options.type.generate(ctx);
            ctx.popPath(this.varName);
            if (ctx.useContextVariables) {
                ctx.pushCode(`delete ${nestVar}.$parent;`);
                ctx.pushCode(`delete ${nestVar}.$root;`);
            }
        }
        else if (aliasRegistry.has(this.options.type)) {
            const tempVar = ctx.generateTmpVariable();
            ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + this.options.type}(offset, {`);
            if (ctx.useContextVariables) {
                const parentVar = ctx.generateVariable();
                ctx.pushCode(`$parent: ${parentVar},`);
                ctx.pushCode(`$root: ${parentVar}.$root,`);
            }
            ctx.pushCode(`});`);
            ctx.pushCode(`${nestVar} = ${tempVar}.result; offset = ${tempVar}.offset;`);
            if (this.options.type !== this.alias) {
                ctx.addReference(this.options.type);
            }
        }
        else if (Object.keys(PRIMITIVE_SIZES).indexOf(this.options.type) >= 0) {
            const typeName = PRIMITIVE_NAMES[type];
            const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type];
            ctx.pushCode(`${nestVar} = dataView.get${typeName}(offset, ${littleEndian});`);
            ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type]};`);
        }
        // Restore offset
        ctx.pushCode(`offset = ${tempVar};`);
    }
    generateSaveOffset(ctx) {
        const varName = ctx.generateVariable(this.varName);
        ctx.pushCode(`${varName} = offset`);
    }
}
//# sourceMappingURL=binary_parser.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_gmod_bbi_esm_index_js.bundle.js.map