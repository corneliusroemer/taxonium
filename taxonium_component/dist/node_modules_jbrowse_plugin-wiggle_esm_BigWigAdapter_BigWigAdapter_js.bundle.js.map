{"version":3,"file":"node_modules_jbrowse_plugin-wiggle_esm_BigWigAdapter_BigWigAdapter_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAmC;AAC+C;AAC7B;AACH;AACS;AACH;AACzC,4BAA4B,2FAAsB;AACjE;AACA,gBAAgB,6BAA6B;AAC7C,2BAA2B,6CAAM;AACjC,wBAAwB,mEAAY;AACpC,SAAS;AACT,6BAA6B,gEAAY;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,UAAU,YAAY,IAAI;AAC1C;AACA;AACA;AACA;AACA,gBAAgB,UAAU,cAAc,IAAI;AAC5C;AACA;AACA;AACA,gBAAgB,UAAU,cAAc,IAAI;AAC5C,eAAe,sEAAY;AAC3B;AACA,iCAAiC;AACjC,gBAAgB,sBAAsB;AACtC,gBAAgB,+DAA+D,IAAI;AACnF,eAAe,yEAAgB;AAC/B;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,aAAa;AACb,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,GAAG,eAAe,GAAG,WAAW,GAAG,SAAS;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AChFA","sources":["webpack://taxonium/./node_modules/@jbrowse/plugin-wiggle/esm/BigWigAdapter/BigWigAdapter.js","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/@gmod/bbi/node_modules/generic-filehandle/esm|./localFile"],"sourcesContent":["import { BigWig } from '@gmod/bbi';\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { updateStatus } from '@jbrowse/core/util';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { rectifyStats } from '@jbrowse/core/util/stats';\nexport default class BigWigAdapter extends BaseFeatureDataAdapter {\n    async setupPre(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const bigwig = new BigWig({\n            filehandle: openLocation(this.getConf('bigWigLocation'), this.pluginManager),\n        });\n        const header = await updateStatus('Downloading bigwig header', statusCallback, () => bigwig.getHeader(opts));\n        return { bigwig, header };\n    }\n    async setup(opts) {\n        if (!this.setupP) {\n            this.setupP = this.setupPre(opts).catch(e => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async getRefNames(opts) {\n        const { header: { refsByName }, } = await this.setup(opts);\n        return Object.keys(refsByName);\n    }\n    async refIdToName(refId) {\n        var _a;\n        const { header: { refsByNumber }, } = await this.setup();\n        return (_a = refsByNumber[refId]) === null || _a === void 0 ? void 0 : _a.name;\n    }\n    async getGlobalStats(opts) {\n        const { header: { totalSummary }, } = await this.setup(opts);\n        return rectifyStats(totalSummary);\n    }\n    getFeatures(region, opts = {}) {\n        const { refName, start, end } = region;\n        const { bpPerPx = 0, signal, resolution = 1, statusCallback = () => { }, } = opts;\n        return ObservableCreate(async (observer) => {\n            statusCallback('Downloading bigwig data');\n            const source = this.getConf('source');\n            const { bigwig } = await this.setup(opts);\n            const feats = await bigwig.getFeatures(refName, start, end, {\n                ...opts,\n                basesPerSpan: bpPerPx / resolution,\n            });\n            for (let i = 0; i < feats.length; i++) {\n                const data = feats[i];\n                if (source) {\n                    // @ts-ignore\n                    data.source = source;\n                }\n                const uniqueId = `${source}:${region.refName}:${data.start}-${data.end}`;\n                // @ts-ignore\n                data.refName = refName;\n                data.uniqueId = uniqueId;\n                observer.next({\n                    // @ts-ignore\n                    get: (str) => data[str],\n                    id: () => uniqueId,\n                    // @ts-ignore\n                    toJSON: () => data,\n                });\n            }\n            observer.complete();\n        }, signal);\n    }\n    // always render bigwig instead of calculating a feature density for it\n    async estimateRegionsStats(_regions) {\n        return { featureDensity: 0 };\n    }\n    freeResources() { }\n}\nBigWigAdapter.capabilities = [\n    'hasResolution',\n    'hasLocalStats',\n    'hasGlobalStats',\n];\n//# sourceMappingURL=BigWigAdapter.js.map","/* (ignored) */"],"names":[],"sourceRoot":""}