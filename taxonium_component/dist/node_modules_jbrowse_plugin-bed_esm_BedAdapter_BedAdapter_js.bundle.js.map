{"version":3,"file":"node_modules_jbrowse_plugin-bed_esm_BedAdapter_BedAdapter_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAA4B;AACsD;AAC7B;AACM;AACrB;AACe;AACP;AAC9C;AACA;AACA;AACe,yBAAyB,2FAAsB;AAC9D;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,0BAA0B,mEAAY;AACtC,2CAA2C,4DAAK;AAChD;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAG,GAAG,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B;AAC/B,gBAAgB,WAAW;AAC3B;AACA;AACA,6BAA6B;AAC7B,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAY;AAC7C;AACA,gCAAgC,QAAQ,GAAG,QAAQ,GAAG,EAAE;AACxD,mBAAmB,kDAAW;AAC9B,SAAS;AACT,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC;AAChC,eAAe,yEAAgB;AAC/B,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;ACjIA;;;;;;;;;;ACAA","sources":["webpack://taxonium/./node_modules/@jbrowse/plugin-bed/esm/BedAdapter/BedAdapter.js","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|./localFile","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/generic-filehandle/esm|file-uri-to-path"],"sourcesContent":["import BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { featureData } from '../util';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport { unzip } from '@gmod/bgzf-filehandle';\nfunction isGzip(buf) {\n    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;\n}\nexport default class BedAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.intervalTrees = {};\n    }\n    async loadDataP(opts = {}) {\n        const pm = this.pluginManager;\n        const bedLoc = this.getConf('bedLocation');\n        const buf = await openLocation(bedLoc, pm).readFile(opts);\n        const buffer = isGzip(buf) ? await unzip(buf) : buf;\n        // 512MB  max chrome string length is 512MB\n        if (buffer.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);\n        const lines = data.split('\\n').filter(f => !!f);\n        const headerLines = [];\n        let i = 0;\n        for (; i < lines.length && lines[i].startsWith('#'); i++) {\n            headerLines.push(lines[i]);\n        }\n        const header = headerLines.join('\\n');\n        const features = {};\n        for (; i < lines.length; i++) {\n            const line = lines[i];\n            const tab = line.indexOf('\\t');\n            const refName = line.slice(0, tab);\n            if (!features[refName]) {\n                features[refName] = [];\n            }\n            features[refName].push(line);\n        }\n        const autoSql = this.getConf('autoSql');\n        const parser = new BED({ autoSql });\n        const columnNames = this.getConf('columnNames');\n        const scoreColumn = this.getConf('scoreColumn');\n        const colRef = this.getConf('colRef');\n        const colStart = this.getConf('colStart');\n        const colEnd = this.getConf('colEnd');\n        return {\n            header,\n            features,\n            parser,\n            columnNames,\n            scoreColumn,\n            colRef,\n            colStart,\n            colEnd,\n        };\n    }\n    async loadData(opts = {}) {\n        if (!this.bedFeatures) {\n            this.bedFeatures = this.loadDataP(opts).catch(e => {\n                this.bedFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.bedFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { features } = await this.loadData(opts);\n        return Object.keys(features);\n    }\n    async getHeader(opts = {}) {\n        const { header } = await this.loadData(opts);\n        return header;\n    }\n    async getNames() {\n        const { header, columnNames } = await this.loadData();\n        if (columnNames.length) {\n            return columnNames;\n        }\n        const defs = header.split('\\n').filter(f => !!f);\n        const defline = defs[defs.length - 1];\n        return (defline === null || defline === void 0 ? void 0 : defline.includes('\\t'))\n            ? defline\n                .slice(1)\n                .split('\\t')\n                .map(field => field.trim())\n            : undefined;\n    }\n    async loadFeatureIntervalTreeHelper(refName) {\n        const { colRef, colStart, colEnd, features, parser, scoreColumn } = await this.loadData();\n        const lines = features[refName];\n        if (!lines) {\n            return undefined;\n        }\n        const names = await this.getNames();\n        const intervalTree = new IntervalTree();\n        const ret = lines.map((f, i) => {\n            const uniqueId = `${this.id}-${refName}-${i}`;\n            return featureData(f, colRef, colStart, colEnd, scoreColumn, parser, uniqueId, names);\n        });\n        for (let i = 0; i < ret.length; i++) {\n            const obj = ret[i];\n            intervalTree.insert([obj.get('start'), obj.get('end')], obj);\n        }\n        return intervalTree;\n    }\n    async loadFeatureIntervalTree(refName) {\n        if (!this.intervalTrees[refName]) {\n            this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(refName).catch(e => {\n                this.intervalTrees[refName] = undefined;\n                throw e;\n            });\n        }\n        return this.intervalTrees[refName];\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { start, end, refName } = query;\n            const intervalTree = await this.loadFeatureIntervalTree(refName);\n            intervalTree === null || intervalTree === void 0 ? void 0 : intervalTree.search([start, end]).forEach(f => observer.next(f));\n            observer.complete();\n        }, opts.signal);\n    }\n    freeResources() { }\n}\nBedAdapter.capabilities = ['getFeatures', 'getRefNames'];\n//# sourceMappingURL=BedAdapter.js.map","/* (ignored) */","/* (ignored) */"],"names":[],"sourceRoot":""}