{"version":3,"file":"vendors-node_modules_gmod_gff_esm_index_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAmC;AACuB;AAC7B;AACwB;AACrD;AACA;AACA;AACA,QAAQ,OAAO,IAAI,OAAO;AAC1B,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAS;AACpC,iCAAiC;AACjC,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA,2BAA2B,yDAAO;AAClC;AACA,0BAA0B,8CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA;AACO,+CAA+C;AACtD;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,6CAAU;AAClC;AACA;AACA,6BAA6B,iDAAc;AAC3C;AACA;AACA;AACA,kCAAkC,6CAAS;AAC3C,4BAA4B;AAC5B,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAU;AACtC;AACA,kBAAkB,iDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qDAAqD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AClN4F;AAC7D;AAC/B,+DAAe;AACf,eAAe;AACf,mBAAmB;AACnB,cAAc;AACd,gBAAgB;AAChB,cAAc;AACd,QAAQ;AACR,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;ACV+B;AAC/B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kIAAkI,+CAA+C;AACjL;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,GAAG,6BAA6B,iBAAiB,MAAM,mCAAmC;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gEAAgE,wCAAwC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB,IAAI,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,KAAK;AAC9F;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+FAA+F,KAAK;AACpG;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4CAA4C,EAAE;AAC9C;AACA;AACA;AACA;AACA,mBAAmB,IAAI;AACvB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY,GAAG,UAAU;AACnD,KAAK;AACL,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,oBAAoB;AACvC;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,eAAe,OAAO,EAAE,sBAAsB,gBAAgB,OAAO,IAAI,aAAa;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://taxonium/./node_modules/@gmod/gff/esm/api.js","webpack://taxonium/./node_modules/@gmod/gff/esm/index.js","webpack://taxonium/./node_modules/@gmod/gff/esm/parse.js","webpack://taxonium/./node_modules/@gmod/gff/esm/util.js"],"sourcesContent":["import { Transform } from 'stream';\nimport { StringDecoder as Decoder } from 'string_decoder';\nimport Parser from './parse';\nimport { formatItem, formatSequence, } from './util';\n// call a callback on the next process tick if running in\n// an environment that supports it\nfunction _callback(callback) {\n    if (process && process.nextTick)\n        process.nextTick(callback);\n    else\n        callback();\n}\n// shared arg processing for the parse routines\nfunction _processParseOptions(options) {\n    const out = {\n        encoding: 'utf8',\n        parseFeatures: true,\n        parseDirectives: false,\n        parseSequences: true,\n        parseComments: false,\n        bufferSize: 1000,\n        ...options,\n    };\n    if (options.parseAll) {\n        out.parseFeatures = true;\n        out.parseDirectives = true;\n        out.parseComments = true;\n        out.parseSequences = true;\n    }\n    return out;\n}\nclass GFFTransform extends Transform {\n    constructor(inputOptions = {}) {\n        super({ objectMode: true });\n        this.textBuffer = '';\n        const options = _processParseOptions(inputOptions);\n        this.encoding = inputOptions.encoding || 'utf8';\n        this.decoder = new Decoder();\n        const push = this.push.bind(this);\n        this.parser = new Parser({\n            featureCallback: options.parseFeatures ? push : undefined,\n            directiveCallback: options.parseDirectives ? push : undefined,\n            commentCallback: options.parseComments ? push : undefined,\n            sequenceCallback: options.parseSequences ? push : undefined,\n            errorCallback: (err) => this.emit('error', err),\n            bufferSize: options.bufferSize,\n        });\n    }\n    _addLine(data) {\n        if (data) {\n            this.parser.addLine(data);\n        }\n    }\n    _nextText(buffer) {\n        const pieces = (this.textBuffer + buffer).split(/\\r?\\n/);\n        this.textBuffer = pieces.pop() || '';\n        pieces.forEach((piece) => this._addLine(piece));\n    }\n    _transform(chunk, _encoding, callback) {\n        this._nextText(this.decoder.write(chunk));\n        _callback(callback);\n    }\n    _flush(callback) {\n        if (this.decoder.end)\n            this._nextText(this.decoder.end());\n        if (this.textBuffer != null)\n            this._addLine(this.textBuffer);\n        this.parser.finish();\n        _callback(callback);\n    }\n}\n/**\n * Parse a stream of text data into a stream of feature, directive, comment,\n * an sequence objects.\n *\n * @param options - Parsing options\n * @returns stream (in objectMode) of parsed items\n */\nexport function parseStream(options = {}) {\n    return new GFFTransform(options);\n}\nexport function parseStringSync(str, inputOptions = {}) {\n    if (!str)\n        return [];\n    const options = _processParseOptions(inputOptions);\n    const items = [];\n    const push = items.push.bind(items);\n    const parser = new Parser({\n        featureCallback: options.parseFeatures ? push : undefined,\n        directiveCallback: options.parseDirectives ? push : undefined,\n        commentCallback: options.parseComments ? push : undefined,\n        sequenceCallback: options.parseSequences ? push : undefined,\n        bufferSize: Infinity,\n        errorCallback: (err) => {\n            throw err;\n        },\n    });\n    str.split(/\\r?\\n/).forEach(parser.addLine.bind(parser));\n    parser.finish();\n    return items;\n}\n/**\n * Format an array of GFF3 items (features,directives,comments) into string of\n * GFF3. Does not insert synchronization (###) marks.\n *\n * @param items - Array of features, directives, comments and/or sequences\n * @returns the formatted GFF3\n */\nexport function formatSync(items) {\n    // sort items into seq and other\n    const other = [];\n    const sequences = [];\n    items.forEach((i) => {\n        if ('sequence' in i)\n            sequences.push(i);\n        else\n            other.push(i);\n    });\n    let str = other.map(formatItem).join('');\n    if (sequences.length) {\n        str += '##FASTA\\n';\n        str += sequences.map(formatSequence).join('');\n    }\n    return str;\n}\nclass FormattingTransform extends Transform {\n    constructor(options = {}) {\n        super(Object.assign(options, { objectMode: true }));\n        this.linesSinceLastSyncMark = 0;\n        this.haveWeEmittedData = false;\n        this.fastaMode = false;\n        this.minLinesBetweenSyncMarks = options.minSyncLines || 100;\n        this.insertVersionDirective = options.insertVersionDirective || false;\n    }\n    _transform(chunk, _encoding, callback) {\n        // if we have not emitted anything yet, and this first\n        // chunk is not a gff-version directive, emit one\n        let str;\n        if (!this.haveWeEmittedData && this.insertVersionDirective) {\n            const thisChunk = Array.isArray(chunk) ? chunk[0] : chunk;\n            if ('directive' in thisChunk) {\n                if (thisChunk.directive !== 'gff-version') {\n                    this.push('##gff-version 3\\n');\n                }\n            }\n        }\n        // if it's a sequence chunk coming down, emit a FASTA directive and\n        // change to FASTA mode\n        if ('sequence' in chunk && !this.fastaMode) {\n            this.push('##FASTA\\n');\n            this.fastaMode = true;\n        }\n        if (Array.isArray(chunk))\n            str = chunk.map(formatItem).join('');\n        else\n            str = formatItem(chunk);\n        this.push(str);\n        if (this.linesSinceLastSyncMark >= this.minLinesBetweenSyncMarks) {\n            this.push('###\\n');\n            this.linesSinceLastSyncMark = 0;\n        }\n        else {\n            // count the number of newlines in this chunk\n            let count = 0;\n            for (let i = 0; i < str.length; i += 1) {\n                if (str[i] === '\\n')\n                    count += 1;\n            }\n            this.linesSinceLastSyncMark += count;\n        }\n        this.haveWeEmittedData = true;\n        _callback(callback);\n    }\n}\n/**\n * Format a stream of features, directives, comments and/or sequences into a\n * stream of GFF3 text.\n *\n * Inserts synchronization (###) marks automatically.\n *\n * @param options - parser options\n */\nexport function formatStream(options = {}) {\n    return new FormattingTransform(options);\n}\n/**\n * Format a stream of features, directives, comments and/or sequences into a\n * GFF3 file and write it to the filesystem.\n\n * Inserts synchronization (###) marks and a ##gff-version\n * directive automatically (if one is not already present).\n *\n * @param stream - the stream to write to the file\n * @param filename - the file path to write to\n * @param options - parser options\n * @returns promise for null that resolves when the stream has been written\n */\nexport function formatFile(stream, writeStream, options = {}) {\n    const newOptions = {\n        insertVersionDirective: true,\n        ...options,\n    };\n    return new Promise((resolve, reject) => {\n        stream\n            .pipe(new FormattingTransform(newOptions))\n            .on('end', () => resolve(null))\n            .on('error', reject)\n            .pipe(writeStream);\n    });\n}\n//# sourceMappingURL=api.js.map","import { parseStream, parseStringSync, formatSync, formatStream, formatFile, } from './api';\nimport * as util from './util';\nexport default {\n    parseStream,\n    parseStringSync,\n    formatSync,\n    formatStream,\n    formatFile,\n    util,\n};\n//# sourceMappingURL=index.js.map","import * as GFF3 from './util';\nconst containerAttributes = {\n    Parent: 'child_features',\n    Derives_from: 'derived_features',\n};\nexport class FASTAParser {\n    constructor(seqCallback) {\n        this.seqCallback = seqCallback;\n        this.currentSequence = undefined;\n    }\n    addLine(line) {\n        const defMatch = /^>\\s*(\\S+)\\s*(.*)/.exec(line);\n        if (defMatch) {\n            this._flush();\n            this.currentSequence = { id: defMatch[1], sequence: '' };\n            if (defMatch[2])\n                this.currentSequence.description = defMatch[2].trim();\n        }\n        else if (this.currentSequence && /\\S/.test(line)) {\n            this.currentSequence.sequence += line.replace(/\\s/g, '');\n        }\n    }\n    _flush() {\n        if (this.currentSequence)\n            this.seqCallback(this.currentSequence);\n    }\n    finish() {\n        this._flush();\n    }\n}\nexport default class Parser {\n    constructor(args) {\n        this.fastaParser = undefined;\n        // if this is true, the parser ignores the\n        // rest of the lines in the file.  currently\n        // set when the file switches over to FASTA\n        this.eof = false;\n        this.lineNumber = 0;\n        // features that we have to keep on hand for now because they\n        // might be referenced by something else\n        this._underConstructionTopLevel = [];\n        // index of the above by ID\n        this._underConstructionById = {};\n        this._completedReferences = {};\n        // features that reference something we have not seen yet\n        // structured as:\n        // {  'some_id' : {\n        //     'Parent' : [ orphans that have a Parent attr referencing it ],\n        //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n        //    }\n        // }\n        this._underConstructionOrphans = {};\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        const nullFunc = () => { };\n        this.featureCallback = args.featureCallback || nullFunc;\n        this.endCallback = args.endCallback || nullFunc;\n        this.commentCallback = args.commentCallback || nullFunc;\n        this.errorCallback = args.errorCallback || nullFunc;\n        this.directiveCallback = args.directiveCallback || nullFunc;\n        this.sequenceCallback = args.sequenceCallback || nullFunc;\n        // number of lines to buffer\n        this.bufferSize = args.bufferSize === undefined ? 1000 : args.bufferSize;\n    }\n    addLine(line) {\n        // if we have transitioned to a fasta section, just delegate to that parser\n        if (this.fastaParser) {\n            this.fastaParser.addLine(line);\n            return;\n        }\n        if (this.eof) {\n            // otherwise, if we are done, ignore this line\n            return;\n        }\n        this.lineNumber += 1;\n        if (/^\\s*[^#\\s>]/.test(line)) {\n            // feature line, most common case\n            this._bufferLine(line);\n            return;\n        }\n        const match = /^\\s*(#+)(.*)/.exec(line);\n        if (match) {\n            // directive or comment\n            const [, hashsigns] = match;\n            let [, , contents] = match;\n            if (hashsigns.length === 3) {\n                // sync directive, all forward-references are resolved.\n                this._emitAllUnderConstructionFeatures();\n            }\n            else if (hashsigns.length === 2) {\n                const directive = GFF3.parseDirective(line);\n                if (directive) {\n                    if (directive.directive === 'FASTA') {\n                        this._emitAllUnderConstructionFeatures();\n                        this.eof = true;\n                        this.fastaParser = new FASTAParser(this.sequenceCallback);\n                    }\n                    else {\n                        this._emitItem(directive);\n                    }\n                }\n            }\n            else {\n                contents = contents.replace(/\\s*/, '');\n                this._emitItem({ comment: contents });\n            }\n        }\n        else if (/^\\s*$/.test(line)) {\n            // blank line, do nothing\n        }\n        else if (/^\\s*>/.test(line)) {\n            // implicit beginning of a FASTA section\n            this._emitAllUnderConstructionFeatures();\n            this.eof = true;\n            this.fastaParser = new FASTAParser(this.sequenceCallback);\n            this.fastaParser.addLine(line);\n        }\n        else {\n            // it's a parse error\n            const errLine = line.replace(/\\r?\\n?$/g, '');\n            throw new Error(`GFF3 parse error.  Cannot parse '${errLine}'.`);\n        }\n    }\n    finish() {\n        this._emitAllUnderConstructionFeatures();\n        if (this.fastaParser)\n            this.fastaParser.finish();\n        this.endCallback();\n    }\n    _emitItem(i) {\n        if (Array.isArray(i))\n            this.featureCallback(i);\n        else if ('directive' in i)\n            this.directiveCallback(i);\n        else if ('comment' in i)\n            this.commentCallback(i);\n    }\n    _enforceBufferSizeLimit(additionalItemCount = 0) {\n        const _unbufferItem = (item) => {\n            if (item &&\n                Array.isArray(item) &&\n                item[0].attributes &&\n                item[0].attributes.ID &&\n                item[0].attributes.ID[0]) {\n                const ids = item[0].attributes.ID;\n                ids.forEach((id) => {\n                    delete this._underConstructionById[id];\n                    delete this._completedReferences[id];\n                });\n                item.forEach((i) => {\n                    if (i.child_features)\n                        i.child_features.forEach((c) => _unbufferItem(c));\n                    if (i.derived_features)\n                        i.derived_features.forEach((d) => _unbufferItem(d));\n                });\n            }\n        };\n        while (this._underConstructionTopLevel.length + additionalItemCount >\n            this.bufferSize) {\n            const item = this._underConstructionTopLevel.shift();\n            if (item) {\n                this._emitItem(item);\n                _unbufferItem(item);\n            }\n        }\n    }\n    /**\n     * return all under-construction features, called when we know\n     * there will be no additional data to attach to them\n     */\n    _emitAllUnderConstructionFeatures() {\n        this._underConstructionTopLevel.forEach(this._emitItem.bind(this));\n        this._underConstructionTopLevel = [];\n        this._underConstructionById = {};\n        this._completedReferences = {};\n        // if we have any orphans hanging around still, this is a\n        // problem. die with a parse error\n        if (Array.from(Object.values(this._underConstructionOrphans)).length) {\n            throw new Error(`some features reference other features that do not exist in the file (or in the same '###' scope). ${JSON.stringify(this._underConstructionOrphans)}`);\n        }\n    }\n    // do the right thing with a newly-parsed feature line\n    _bufferLine(line) {\n        var _a, _b, _c;\n        const rawFeatureLine = GFF3.parseFeature(line);\n        const featureLine = {\n            ...rawFeatureLine,\n            child_features: [],\n            derived_features: [],\n        };\n        // featureLine._lineNumber = this.lineNumber //< debugging aid\n        // NOTE: a feature is an arrayref of one or more feature lines.\n        const ids = ((_a = featureLine.attributes) === null || _a === void 0 ? void 0 : _a.ID) || [];\n        const parents = ((_b = featureLine.attributes) === null || _b === void 0 ? void 0 : _b.Parent) || [];\n        const derives = ((_c = featureLine.attributes) === null || _c === void 0 ? void 0 : _c.Derives_from) || [];\n        if (!ids.length && !parents.length && !derives.length) {\n            // if it has no IDs and does not refer to anything, we can just\n            // output it\n            this._emitItem([featureLine]);\n            return;\n        }\n        let feature = undefined;\n        ids.forEach((id) => {\n            const existing = this._underConstructionById[id];\n            if (existing) {\n                // another location of the same feature\n                if (existing[existing.length - 1].type !== featureLine.type) {\n                    this._parseError(`multi-line feature \"${id}\" has inconsistent types: \"${featureLine.type}\", \"${existing[existing.length - 1].type}\"`);\n                }\n                existing.push(featureLine);\n                feature = existing;\n            }\n            else {\n                // haven't seen it yet, so buffer it so we can attach\n                // child features to it\n                feature = [featureLine];\n                this._enforceBufferSizeLimit(1);\n                if (!parents.length && !derives.length) {\n                    this._underConstructionTopLevel.push(feature);\n                }\n                this._underConstructionById[id] = feature;\n                // see if we have anything buffered that refers to it\n                this._resolveReferencesTo(feature, id);\n            }\n        });\n        // try to resolve all its references\n        this._resolveReferencesFrom(feature || [featureLine], { Parent: parents, Derives_from: derives }, ids);\n    }\n    _resolveReferencesTo(feature, id) {\n        const references = this._underConstructionOrphans[id];\n        //   references is of the form\n        //   {\n        //     'Parent' : [ orphans that have a Parent attr referencing this feature ],\n        //     'Derives_from' : [ orphans that have a Derives_from attr referencing this feature ],\n        //    }\n        if (!references)\n            return;\n        feature.forEach((loc) => {\n            loc.child_features.push(...references.Parent);\n        });\n        feature.forEach((loc) => {\n            loc.derived_features.push(...references.Derives_from);\n        });\n        delete this._underConstructionOrphans[id];\n    }\n    _parseError(message) {\n        this.eof = true;\n        this.errorCallback(`${this.lineNumber}: ${message}`);\n    }\n    _resolveReferencesFrom(feature, references, ids) {\n        // this is all a bit more awkward in javascript than it was in perl\n        function postSet(obj, slot1, slot2) {\n            let subObj = obj[slot1];\n            if (!subObj) {\n                subObj = {};\n                obj[slot1] = subObj;\n            }\n            const returnVal = subObj[slot2] || false;\n            subObj[slot2] = true;\n            return returnVal;\n        }\n        references.Parent.forEach((toId) => {\n            const otherFeature = this._underConstructionById[toId];\n            if (otherFeature) {\n                const pname = containerAttributes.Parent;\n                if (!ids.filter((id) => postSet(this._completedReferences, id, `Parent,${toId}`)).length) {\n                    otherFeature.forEach((location) => {\n                        location[pname].push(feature);\n                    });\n                }\n            }\n            else {\n                let ref = this._underConstructionOrphans[toId];\n                if (!ref) {\n                    ref = {\n                        Parent: [],\n                        Derives_from: [],\n                    };\n                    this._underConstructionOrphans[toId] = ref;\n                }\n                ref.Parent.push(feature);\n            }\n        });\n        references.Derives_from.forEach((toId) => {\n            const otherFeature = this._underConstructionById[toId];\n            if (otherFeature) {\n                const pname = containerAttributes.Derives_from;\n                if (!ids.filter((id) => postSet(this._completedReferences, id, `Derives_from,${toId}`)).length) {\n                    otherFeature.forEach((location) => {\n                        location[pname].push(feature);\n                    });\n                }\n            }\n            else {\n                let ref = this._underConstructionOrphans[toId];\n                if (!ref) {\n                    ref = {\n                        Parent: [],\n                        Derives_from: [],\n                    };\n                    this._underConstructionOrphans[toId] = ref;\n                }\n                ref.Derives_from.push(feature);\n            }\n        });\n    }\n}\n//# sourceMappingURL=parse.js.map","// Fast, low-level functions for parsing and formatting GFF3.\n// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n/**\n * Unescape a string value used in a GFF3 attribute.\n *\n * @param stringVal - Escaped GFF3 string value\n * @returns An unescaped string value\n */\nexport function unescape(stringVal) {\n    return stringVal.replace(/%([0-9A-Fa-f]{2})/g, (_match, seq) => String.fromCharCode(parseInt(seq, 16)));\n}\nfunction _escape(regex, s) {\n    return String(s).replace(regex, (ch) => {\n        const hex = ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0');\n        return `%${hex}`;\n    });\n}\n/**\n * Escape a value for use in a GFF3 attribute value.\n *\n * @param rawVal - Raw GFF3 attribute value\n * @returns An escaped string value\n */\nexport function escape(rawVal) {\n    return _escape(/[\\n;\\r\\t=%&,\\x00-\\x1f\\x7f-\\xff]/g, rawVal);\n}\n/**\n * Escape a value for use in a GFF3 column value.\n *\n * @param rawVal - Raw GFF3 column value\n * @returns An escaped column value\n */\nexport function escapeColumn(rawVal) {\n    return _escape(/[\\n\\r\\t%\\x00-\\x1f\\x7f-\\xff]/g, rawVal);\n}\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributes(attrString) {\n    if (!(attrString && attrString.length) || attrString === '.')\n        return {};\n    const attrs = {};\n    attrString\n        .replace(/\\r?\\n$/, '')\n        .split(';')\n        .forEach((a) => {\n        const nv = a.split('=', 2);\n        if (!(nv[1] && nv[1].length))\n            return;\n        nv[0] = nv[0].trim();\n        let arec = attrs[nv[0].trim()];\n        if (!arec) {\n            arec = [];\n            attrs[nv[0]] = arec;\n        }\n        arec.push(...nv[1]\n            .split(',')\n            .map((s) => s.trim())\n            .map(unescape));\n    });\n    return attrs;\n}\n/**\n * Parse a GFF3 feature line\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeature(line) {\n    // split the line into columns and replace '.' with null in each column\n    const f = line.split('\\t').map((a) => (a === '.' || a === '' ? null : a));\n    // unescape only the ref, source, and type columns\n    const parsed = {\n        seq_id: f[0] && unescape(f[0]),\n        source: f[1] && unescape(f[1]),\n        type: f[2] && unescape(f[2]),\n        start: f[3] === null ? null : parseInt(f[3], 10),\n        end: f[4] === null ? null : parseInt(f[4], 10),\n        score: f[5] === null ? null : parseFloat(f[5]),\n        strand: f[6],\n        phase: f[7],\n        attributes: f[8] === null ? null : parseAttributes(f[8]),\n    };\n    return parsed;\n}\n/**\n * Parse a GFF3 directive line.\n *\n * @param line - GFF3 directive line\n * @returns The parsed directive\n */\nexport function parseDirective(line) {\n    const match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line);\n    if (!match)\n        return null;\n    const [, name] = match;\n    let [, , contents] = match;\n    const parsed = { directive: name };\n    if (contents.length) {\n        contents = contents.replace(/\\r?\\n$/, '');\n        parsed.value = contents;\n    }\n    // do a little additional parsing for sequence-region and genome-build directives\n    if (name === 'sequence-region') {\n        const c = contents.split(/\\s+/, 3);\n        return {\n            ...parsed,\n            seq_id: c[0],\n            start: c[1] && c[1].replace(/\\D/g, ''),\n            end: c[2] && c[2].replace(/\\D/g, ''),\n        };\n    }\n    else if (name === 'genome-build') {\n        const [source, buildName] = contents.split(/\\s+/, 2);\n        return {\n            ...parsed,\n            source,\n            buildName,\n        };\n    }\n    return parsed;\n}\n/**\n * Format an attributes object into a string suitable for the 9th column of GFF3.\n *\n * @param attrs - Attributes\n * @returns GFF3 9th column string\n */\nexport function formatAttributes(attrs) {\n    const attrOrder = [];\n    Object.entries(attrs).forEach(([tag, val]) => {\n        if (!val)\n            return;\n        let valstring;\n        if (val.hasOwnProperty('toString')) {\n            valstring = escape(val.toString());\n            // } else if (Array.isArray(val.values)) {\n            //   valstring = val.values.map(escape).join(',')\n        }\n        else if (Array.isArray(val)) {\n            valstring = val.map(escape).join(',');\n        }\n        else {\n            valstring = escape(val);\n        }\n        attrOrder.push(`${escape(tag)}=${valstring}`);\n    });\n    return attrOrder.length ? attrOrder.join(';') : '.';\n}\nfunction _formatSingleFeature(f, seenFeature) {\n    const attrString = f.attributes === null || f.attributes === undefined\n        ? '.'\n        : formatAttributes(f.attributes);\n    const fields = [\n        f.seq_id === null ? '.' : escapeColumn(f.seq_id),\n        f.source === null ? '.' : escapeColumn(f.source),\n        f.type === null ? '.' : escapeColumn(f.type),\n        f.start === null ? '.' : escapeColumn(f.start),\n        f.end === null ? '.' : escapeColumn(f.end),\n        f.score === null ? '.' : escapeColumn(f.score),\n        f.strand === null ? '.' : escapeColumn(f.strand),\n        f.phase === null ? '.' : escapeColumn(f.phase),\n        attrString,\n    ];\n    const formattedString = `${fields.join('\\t')}\\n`;\n    // if we have already output this exact feature, skip it\n    if (seenFeature[formattedString]) {\n        return '';\n    }\n    seenFeature[formattedString] = true;\n    return formattedString;\n}\nfunction _formatFeature(feature, seenFeature) {\n    if (Array.isArray(feature)) {\n        return feature.map((f) => _formatFeature(f, seenFeature)).join('');\n    }\n    const strings = [_formatSingleFeature(feature, seenFeature)];\n    if (_isFeatureLineWithRefs(feature)) {\n        strings.push(...feature.child_features.map((f) => _formatFeature(f, seenFeature)), ...feature.derived_features.map((f) => _formatFeature(f, seenFeature)));\n    }\n    return strings.join('');\n}\n/**\n * Format a feature object or array of feature objects into one or more lines of\n * GFF3.\n *\n * @param featureOrFeatures - A feature object or array of feature objects\n * @returns A string of one or more GFF3 lines\n */\nexport function formatFeature(featureOrFeatures) {\n    const seen = {};\n    return _formatFeature(featureOrFeatures, seen);\n}\n/**\n * Format a directive into a line of GFF3.\n *\n * @param directive - A directive object\n * @returns A directive line string\n */\nexport function formatDirective(directive) {\n    let str = `##${directive.directive}`;\n    if (directive.value)\n        str += ` ${directive.value}`;\n    str += '\\n';\n    return str;\n}\n/**\n * Format a comment into a GFF3 comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param comment - A comment object\n * @returns A comment line string\n */\nexport function formatComment(comment) {\n    return `# ${comment.comment}\\n`;\n}\n/**\n * Format a sequence object as FASTA\n *\n * @param seq - A sequence object\n * @returns Formatted single FASTA sequence string\n */\nexport function formatSequence(seq) {\n    return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\\n${seq.sequence}\\n`;\n}\n/**\n * Format a directive, comment, sequence, or feature, or array of such items,\n * into one or more lines of GFF3.\n *\n * @param itemOrItems - A comment, sequence, or feature, or array of such items\n * @returns A formatted string or array of strings\n */\nexport function formatItem(itemOrItems) {\n    function formatSingleItem(item) {\n        if ('attributes' in item)\n            return formatFeature(item);\n        if ('directive' in item)\n            return formatDirective(item);\n        if ('sequence' in item)\n            return formatSequence(item);\n        if ('comment' in item)\n            return formatComment(item);\n        return '# (invalid item found during format)\\n';\n    }\n    if (Array.isArray(itemOrItems)) {\n        return itemOrItems.map(formatSingleItem);\n    }\n    return formatSingleItem(itemOrItems);\n}\nfunction _isFeatureLineWithRefs(featureLine) {\n    return (featureLine.child_features !== undefined &&\n        featureLine.derived_features !== undefined);\n}\n//# sourceMappingURL=util.js.map"],"names":[],"sourceRoot":""}