{"version":3,"file":"node_modules_jbrowse_plugin-bed_esm_BigBedAdapter_BigBedAdapter_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACmC;AACP;AACsD;AAC7B;AACM;AACE;AACd;AACc;AACX;AAClD;AACA;AACA;AACe,4BAA4B,2FAAsB;AACjE;AACA,2BAA2B,6CAAM;AACjC,wBAAwB,mEAAY,CAAC,2EAAc;AACnD,SAAS;AACT;AACA,2BAA2B,iDAAG,GAAG,yBAAyB;AAC1D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,gBAAgB,oBAAoB;AACpC,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA,uBAAuB,SAAS;AAChC,qDAAqD,eAAe;AACpE;AACA;AACA,iCAAiC;AACjC,gBAAgB,sBAAsB;AACtC,gBAAgB,SAAS;AACzB,eAAe,yEAAgB;AAC/B;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,iBAAiB;AACjB,wBAAwB,wDAAQ,IAAI,mDAAG;AACvC,qDAAqD,QAAQ,IAAI,QAAQ,IAAI,MAAM,IAAI,OAAO;AAC9F;AACA,qBAAqB;AACrB,4BAA4B,mDAAmD;AAC/E;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA,6CAA6C,WAAW,GAAG,EAAE;AAC7D;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE,kCAAkC,wEAAa;AAC/C,+BAA+B,QAAQ,GAAG,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,uCAAuC,8DAAuB;AAC9D,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;ACvGA","sources":["webpack://taxonium/./node_modules/@jbrowse/plugin-bed/esm/BigBedAdapter/BigBedAdapter.js","webpack://taxonium/ignored|/workspaces/taxonium/taxonium_web_client/node_modules/@gmod/bbi/node_modules/generic-filehandle/esm|./localFile"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { BigBed } from '@gmod/bbi';\nimport BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { map, mergeAll } from 'rxjs/operators';\nimport { readConfObject } from '@jbrowse/core/configuration';\nimport { ucscProcessedTranscript } from '../util';\nfunction isUCSC(f) {\n    return f.get('thickStart') && f.get('blockCount') && f.get('strand') !== 0;\n}\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n    async configurePre(opts) {\n        const bigbed = new BigBed({\n            filehandle: openLocation(readConfObject(this.config, 'bigBedLocation'), this.pluginManager),\n        });\n        const header = await bigbed.getHeader(opts);\n        const parser = new BED({ autoSql: header.autoSql });\n        return { bigbed, header, parser };\n    }\n    async configure(opts) {\n        if (!this.cached) {\n            this.cached = this.configurePre(opts).catch(e => {\n                this.cached = undefined;\n                throw e;\n            });\n        }\n        return this.cached;\n    }\n    async getRefNames(opts) {\n        const { header } = await this.configure(opts);\n        return Object.keys(header.refsByName);\n    }\n    async getHeader(opts) {\n        const { parser, header } = await this.configure(opts);\n        const { version, fileType } = header;\n        const { fields, ...rest } = parser.autoSql;\n        return {\n            version,\n            fileType,\n            autoSql: { ...rest },\n            fields: Object.fromEntries(fields.map(({ name, comment }) => [name, comment])),\n        };\n    }\n    getFeatures(region, opts = {}) {\n        const { refName, start, end } = region;\n        const { signal } = opts;\n        return ObservableCreate(async (observer) => {\n            try {\n                const { parser, bigbed } = await this.configure(opts);\n                const ob = await bigbed.getFeatureStream(refName, start, end, {\n                    signal,\n                    basesPerSpan: end - start,\n                });\n                ob.pipe(mergeAll(), map(r => {\n                    const data = parser.parseLine(`${refName}\\t${r.start}\\t${r.end}\\t${r.rest}`, {\n                        uniqueId: r.uniqueId,\n                    });\n                    const { blockCount, blockSizes, blockStarts, chromStarts } = data;\n                    if (blockCount) {\n                        const starts = chromStarts || blockStarts || [];\n                        const sizes = blockSizes;\n                        const blocksOffset = r.start;\n                        data.subfeatures = [];\n                        for (let b = 0; b < blockCount; b += 1) {\n                            const bmin = (starts[b] || 0) + blocksOffset;\n                            const bmax = bmin + (sizes[b] || 0);\n                            data.subfeatures.push({\n                                uniqueId: `${r.uniqueId}-${b}`,\n                                start: bmin,\n                                end: bmax,\n                                type: 'block',\n                            });\n                        }\n                    }\n                    if (r.uniqueId === undefined) {\n                        throw new Error('invalid bbi feature');\n                    }\n                    const { chromStart, chromEnd, chrom, ...rest } = data;\n                    const f = new SimpleFeature({\n                        id: `${this.id}-${r.uniqueId}`,\n                        data: {\n                            ...rest,\n                            start: r.start,\n                            end: r.end,\n                            refName,\n                        },\n                    });\n                    // collection of heuristics for suggesting that this feature\n                    // should be converted to a gene, CNV bigbed has many gene like\n                    // features including thickStart and blockCount but no strand\n                    return isUCSC(f) ? ucscProcessedTranscript(f) : f;\n                })).subscribe(observer);\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.signal);\n    }\n    freeResources() { }\n}\n//# sourceMappingURL=BigBedAdapter.js.map","/* (ignored) */"],"names":[],"sourceRoot":""}